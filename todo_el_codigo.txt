----- capa_datos/categoria_repo.py -----
from typing import List, Dict, Optional
from loguru import logger

class CategoriaRepositorio:
    """Repositorio para operaciones CRUD de categoría"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar(self) -> List[Dict]:
        """Lista todas las categorías"""
        try:
            self.cursor.execute("SELECT idcategoria, nombre, descripcion FROM categoria ORDER BY nombre")
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} categorías listadas")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar categorías: {e}")
            return []
    
    def obtener_por_id(self, idcategoria: int) -> Optional[Dict]:
        """Obtiene una categoría por su ID"""
        try:
            self.cursor.execute(
                "SELECT idcategoria, nombre, descripcion FROM categoria WHERE idcategoria = ?",
                (idcategoria,)
            )
            row = self.cursor.fetchone()
            if row:
                return {
                    'idcategoria': row[0],
                    'nombre': row[1],
                    'descripcion': row[2]
                }
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener categoría {idcategoria}: {e}")
            return None
    
    def insertar(self, nombre: str, descripcion: str = None) -> bool:
        """Inserta una nueva categoría"""
        try:
            self.cursor.execute(
                "INSERT INTO categoria (nombre, descripcion) VALUES (?, ?)",
                (nombre, descripcion)
            )
            self.cursor.commit()
            logger.success(f"✅ Categoría '{nombre}' insertada")
            return True
        except Exception as e:
            logger.error(f"❌ Error al insertar categoría: {e}")
            return False
    
    def actualizar(self, idcategoria: int, nombre: str, descripcion: str = None) -> bool:
        """Actualiza una categoría existente"""
        try:
            self.cursor.execute(
                "UPDATE categoria SET nombre = ?, descripcion = ? WHERE idcategoria = ?",
                (nombre, descripcion, idcategoria)
            )
            self.cursor.commit()
            logger.success(f"✅ Categoría ID {idcategoria} actualizada")
            return True
        except Exception as e:
            logger.error(f"❌ Error al actualizar categoría: {e}")
            return False
    
    def eliminar(self, idcategoria: int) -> bool:
        """Elimina una categoría"""
        try:
            self.cursor.execute("DELETE FROM categoria WHERE idcategoria = ?", (idcategoria,))
            self.cursor.commit()
            logger.success(f"✅ Categoría ID {idcategoria} eliminada")
            return True
        except Exception as e:
            logger.error(f"❌ Error al eliminar categoría: {e}")
            return False
----- capa_datos/articulo_repo.py -----
"""
Repositorio para la gestión de artículos en la base de datos
"""
from loguru import logger

class ArticuloRepositorio:
    """Clase que maneja las operaciones de base de datos para artículos"""
    
    def __init__(self, conn):
        """
        Inicializa el repositorio con una conexión a la base de datos
        
        Args:
            conn: Conexión a la base de datos
        """
        self.conn = conn
        logger.info("✅ ArticuloRepositorio inicializado")
    
    def listar(self):
        """
        Lista todos los artículos con sus precios
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT a.idarticulo, a.codigo, a.nombre, a.descripcion, a.imagen,
                   a.idcategoria, c.nombre as categoria,
                   a.idpresentacion, p.nombre as presentacion,
                   a.precio_venta, a.precio_referencia
            FROM articulo a
            LEFT JOIN categoria c ON a.idcategoria = c.idcategoria
            LEFT JOIN presentacion p ON a.idpresentacion = p.idpresentacion
            ORDER BY a.idarticulo DESC
            """
            cursor.execute(query)
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            logger.info(f"✅ {len(result)} artículos listados")
            return result
            
        except Exception as e:
            logger.error(f"Error al listar artículos: {e}")
            return []
    
    def obtener_por_id(self, idarticulo):
        """
        Obtiene un artículo por su ID incluyendo precio_venta
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT a.idarticulo, a.codigo, a.nombre, a.descripcion, a.imagen,
                   a.idcategoria, c.nombre as categoria,
                   a.idpresentacion, p.nombre as presentacion,
                   a.precio_venta, a.precio_referencia
            FROM articulo a
            LEFT JOIN categoria c ON a.idcategoria = c.idcategoria
            LEFT JOIN presentacion p ON a.idpresentacion = p.idpresentacion
            WHERE a.idarticulo = ?
            """
            cursor.execute(query, (idarticulo,))
            
            columns = [column[0] for column in cursor.description]
            row = cursor.fetchone()
            
            if row:
                result = {}
                for i, col in enumerate(columns):
                    result[col] = row[i]
                return result
            return None
            
        except Exception as e:
            logger.error(f"Error al obtener artículo {idarticulo}: {e}")
            return None
    
    def buscar_por_codigo(self, codigo):
        """Busca un artículo por su código"""
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idarticulo, codigo, nombre, precio_venta
            FROM articulo 
            WHERE codigo = ?
            """
            cursor.execute(query, (codigo,))
            
            columns = [column[0] for column in cursor.description]
            row = cursor.fetchone()
            
            if row:
                result = {}
                for i, col in enumerate(columns):
                    result[col] = row[i]
                return result
            return None
            
        except Exception as e:
            logger.error(f"Error al buscar artículo por código {codigo}: {e}")
            return None
    
    def crear(self, codigo, nombre, idcategoria, idpresentacion, descripcion=None, 
              imagen=None, precio_venta=0, precio_referencia=None):
        """
        Inserta un nuevo artículo con precio de venta
        """
        try:
            cursor = self.conn.cursor()
            
            query = """
            INSERT INTO articulo 
            (codigo, nombre, idcategoria, idpresentacion, descripcion, imagen, 
             precio_venta, precio_referencia)
            OUTPUT INSERTED.idarticulo
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            cursor.execute(query, (
                codigo, nombre, idcategoria, idpresentacion, descripcion, imagen,
                precio_venta, precio_referencia
            ))
            
            row = cursor.fetchone()
            idarticulo = row[0] if row else None
            self.conn.commit()
            
            logger.info(f"✅ Artículo creado con ID: {idarticulo} - Código: {codigo} - Precio: {precio_venta}")
            return idarticulo
            
        except Exception as e:
            logger.error(f"❌ Error al crear artículo: {e}")
            self.conn.rollback()
            return None
    
    def actualizar(self, idarticulo, codigo, nombre, idcategoria, idpresentacion, 
                   descripcion=None, imagen=None, precio_venta=None, precio_referencia=None):
        """
        Actualiza un artículo existente incluyendo precios
        """
        try:
            cursor = self.conn.cursor()
            
            # Construir query dinámicamente según qué campos vengan
            campos = []
            valores = []
            
            campos.append("codigo = ?")
            valores.append(codigo)
            
            campos.append("nombre = ?")
            valores.append(nombre)
            
            campos.append("idcategoria = ?")
            valores.append(idcategoria)
            
            campos.append("idpresentacion = ?")
            valores.append(idpresentacion)
            
            campos.append("descripcion = ?")
            valores.append(descripcion)
            
            # Solo agregar precio_venta si se proporciona explícitamente
            if precio_venta is not None:
                campos.append("precio_venta = ?")
                valores.append(precio_venta)
            
            # Solo agregar precio_referencia si se proporciona explícitamente
            if precio_referencia is not None:
                campos.append("precio_referencia = ?")
                valores.append(precio_referencia)
            
            if imagen is not None:
                campos.append("imagen = ?")
                valores.append(imagen)
            
            # Agregar ID al final
            valores.append(idarticulo)
            
            query = f"""
            UPDATE articulo 
            SET {', '.join(campos)}
            WHERE idarticulo = ?
            """
            
            cursor.execute(query, valores)
            self.conn.commit()
            afectadas = cursor.rowcount
            
            if afectadas > 0:
                logger.info(f"✅ Artículo {idarticulo} actualizado correctamente")
                return True
            else:
                logger.warning(f"⚠️ No se encontró el artículo {idarticulo} para actualizar")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error al actualizar artículo {idarticulo}: {e}")
            self.conn.rollback()
            return False
    
    def eliminar(self, idarticulo):
        """
        Elimina un artículo (verifica si tiene movimientos asociados)
        
        Args:
            idarticulo (int): ID del artículo a eliminar
            
        Returns:
            bool: True si se eliminó correctamente, False en caso contrario
        """
        try:
            cursor = self.conn.cursor()
            
            # Verificar si el artículo tiene movimientos en kardex
            check_kardex = "SELECT COUNT(*) as total FROM kardex WHERE idarticulo = ?"
            cursor.execute(check_kardex, (idarticulo,))
            row = cursor.fetchone()
            total_kardex = row[0] if row else 0
            
            if total_kardex > 0:
                logger.warning(f"⚠️ Artículo {idarticulo} tiene movimientos en kardex. No se puede eliminar")
                return False
            
            # Verificar si el artículo tiene detalles de venta
            check_ventas = "SELECT COUNT(*) as total FROM detalle_venta WHERE idarticulo = ?"
            cursor.execute(check_ventas, (idarticulo,))
            row = cursor.fetchone()
            total_ventas = row[0] if row else 0
            
            if total_ventas > 0:
                logger.warning(f"⚠️ Artículo {idarticulo} tiene ventas asociadas. No se puede eliminar")
                return False
            
            # Verificar si el artículo tiene detalles de ingreso
            check_ingresos = "SELECT COUNT(*) as total FROM detalle_ingreso WHERE idarticulo = ?"
            cursor.execute(check_ingresos, (idarticulo,))
            row = cursor.fetchone()
            total_ingresos = row[0] if row else 0
            
            if total_ingresos > 0:
                logger.warning(f"⚠️ Artículo {idarticulo} tiene ingresos asociados. No se puede eliminar")
                return False
            
            # Si no tiene movimientos, eliminar
            query = "DELETE FROM articulo WHERE idarticulo = ?"
            cursor.execute(query, (idarticulo,))
            self.conn.commit()
            
            if cursor.rowcount > 0:
                logger.info(f"✅ Artículo {idarticulo} eliminado correctamente")
                return True
            else:
                logger.warning(f"⚠️ No se encontró el artículo {idarticulo} para eliminar")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error al eliminar artículo {idarticulo}: {e}")
            self.conn.rollback()
            return False
    
    def buscar_por_nombre(self, termino):
        """Busca artículos por nombre"""
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idarticulo, codigo, nombre, precio_venta
            FROM articulo 
            WHERE nombre LIKE ? OR codigo LIKE ?
            ORDER BY nombre
            """
            busqueda = f"%{termino}%"
            cursor.execute(query, (busqueda, busqueda))
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error buscando por nombre '{termino}': {e}")
            return []
    
    def contar_articulos(self):
        """
        Cuenta el número total de artículos
        
        Returns:
            int: Número de artículos o 0 si hay error
        """
        try:
            cursor = self.conn.cursor()
            query = "SELECT COUNT(*) as total FROM articulo"
            cursor.execute(query)
            row = cursor.fetchone()
            return row[0] if row else 0
        except Exception as e:
            logger.error(f"Error al contar artículos: {e}")
            return 0
    
    def articulos_con_stock_bajo(self, limite=5):
        """
        Obtiene artículos con stock bajo (requiere join con kardex)
        
        Args:
            limite (int): Límite de stock para considerar bajo
            
        Returns:
            list: Lista de artículos con stock bajo
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT a.idarticulo, a.codigo, a.nombre, 
                   ISNULL((
                       SELECT TOP 1 k.stock_nuevo 
                       FROM kardex k 
                       WHERE k.idarticulo = a.idarticulo 
                       ORDER BY k.fecha_movimiento DESC
                   ), 0) as stock_actual
            FROM articulo a
            HAVING stock_actual < ?
            ORDER BY stock_actual ASC
            """
            cursor.execute(query, (limite,))
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error al obtener artículos con stock bajo: {e}")
            return []

    def buscar_por_codigo_barras(self, codigo):
        """Busca artículo por código de barras"""
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idarticulo, codigo, nombre, precio_venta, tipo_medida, precio_por_kilo, es_pesado
            FROM articulo 
            WHERE codigo_barras = ?
            """
            cursor.execute(query, (codigo,))
            
            columns = [column[0] for column in cursor.description]
            row = cursor.fetchone()
            
            if row:
                result = {}
                for i, col in enumerate(columns):
                    result[col] = row[i]
                return result
            return None
            
        except Exception as e:
            logger.error(f"Error buscando por código de barras {codigo}: {e}")
            return None
    
    def buscar_por_plu(self, plu):
        """
        Busca artículo por código interno PLU
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idarticulo, codigo, nombre, tipo_medida, precio_por_kilo, es_pesado
            FROM articulo 
            WHERE plu = ?
            """
            cursor.execute(query, (plu,))
            
            columns = [column[0] for column in cursor.description]
            row = cursor.fetchone()
            
            if row:
                result = {}
                for i, col in enumerate(columns):
                    result[col] = row[i]
                return result
            return None
            
        except Exception as e:
            logger.error(f"Error buscando por PLU {plu}: {e}")
            return None    
----- capa_datos/tasa_repo.py -----
"""
Repositorio para gestión de tasas de cambio
"""
from loguru import logger

class TasaRepositorio:
    """Maneja operaciones de BD para tasas de cambio"""
    
    def __init__(self, conn):
        """
        Inicializa el repositorio con una conexión a la BD
        
        Args:
            conn: Conexión a la base de datos
        """
        self.conn = conn
        logger.info("✅ TasaRepositorio inicializado")
    
    def obtener_ultima_tasa(self, moneda='USD'):
        """
        Obtiene la última tasa registrada para una moneda
        
        Args:
            moneda (str): USD, EUR
            
        Returns:
            float: Tasa o None si no existe
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT TOP 1 tasa 
            FROM tasa_cambio 
            WHERE moneda_origen = ? 
            ORDER BY fecha_hora_registro DESC
            """
            cursor.execute(query, (moneda,))
            row = cursor.fetchone()
            
            if row and row[0] is not None:
                tasa = float(row[0])
                logger.info(f"✅ Última tasa {moneda}: {tasa:.2f}")
                return tasa
            else:
                logger.warning(f"⚠️ No hay tasa registrada para {moneda}")
                return None
            
        except Exception as e:
            logger.error(f"Error obteniendo última tasa: {e}")
            return None
    
    def insertar_tasa(self, idfuente, moneda_origen, tasa, 
                      usuario=None, observaciones=None):
        """
        Inserta una nueva tasa en el histórico
        
        Args:
            idfuente (int): ID de la fuente (1 = MANUAL)
            moneda_origen (str): USD, EUR
            tasa (float): Valor de la tasa
            usuario (str): Nombre del usuario que registra
            observaciones (str): Observaciones adicionales
            
        Returns:
            bool: True si se insertó correctamente
        """
        try:
            cursor = self.conn.cursor()
            query = """
            INSERT INTO tasa_cambio 
            (idfuente, moneda_origen, moneda_destino, tasa, 
             fecha, fecha_hora_registro, usuario_registro, observaciones)
            VALUES (?, ?, 'VES', ?, CAST(GETDATE() AS DATE), GETDATE(), ?, ?)
            """
            cursor.execute(query, (idfuente, moneda_origen, tasa, usuario, observaciones))
            self.conn.commit()
            logger.info(f"✅ Tasa {moneda_origen} registrada: {tasa:.2f}")
            return True
            
        except Exception as e:
            logger.error(f"Error insertando tasa: {e}")
            self.conn.rollback()
            return False
    
    def obtener_historial(self, moneda='USD', dias=30):
        """
        Obtiene historial de tasas para una moneda
        
        Args:
            moneda (str): USD, EUR
            dias (int): Número de días hacia atrás
            
        Returns:
            list: Lista de tasas históricas
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT 
                t.idtasa,
                t.fecha,
                t.tasa,
                f.nombre as fuente,
                t.usuario_registro,
                t.fecha_hora_registro
            FROM tasa_cambio t
            INNER JOIN fuente_tasa f ON t.idfuente = f.idfuente
            WHERE t.moneda_origen = ? 
              AND t.fecha >= DATEADD(day, -?, GETDATE())
            ORDER BY t.fecha DESC, t.fecha_hora_registro DESC
            """
            cursor.execute(query, (moneda, dias))
            
            # Convertir a diccionarios
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error obteniendo historial: {e}")
            return []
    
    def obtener_tasas_del_dia(self):
        """
        Obtiene todas las tasas registradas hoy
        
        Returns:
            list: Lista de tasas del día
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT 
                moneda_origen,
                tasa,
                usuario_registro,
                fecha_hora_registro
            FROM tasa_cambio 
            WHERE CAST(fecha_hora_registro AS DATE) = CAST(GETDATE() AS DATE)
            ORDER BY moneda_origen, fecha_hora_registro DESC
            """
            cursor.execute(query)
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error obteniendo tasas del día: {e}")
            return []
----- capa_datos/auditoria_repo.py -----
"""
Repositorio para log de auditoría
"""
from loguru import logger

class AuditoriaRepositorio:
    """Maneja las operaciones de BD para auditoría"""
    
    def __init__(self, conn):
        """
        Inicializa el repositorio con una conexión a la BD
        
        Args:
            conn: Conexión a la base de datos
        """
        self.conn = conn
    
    def insertar(self, usuario, accion, tabla, registro_id, 
                 datos_anteriores, datos_nuevos, ip_address):
        """
        Inserta un registro en el log de auditoría
        
        Returns:
            bool: True si se insertó correctamente
        """
        try:
            cursor = self.conn.cursor()
            query = """
            INSERT INTO log_auditoria 
            (usuario, accion, tabla_afectada, registro_id, 
             datos_anteriores, datos_nuevos, ip_address, fecha_hora)
            VALUES (?, ?, ?, ?, ?, ?, ?, GETDATE())
            """
            cursor.execute(query, (
                usuario, accion, tabla, registro_id,
                datos_anteriores, datos_nuevos, ip_address
            ))
            self.conn.commit()
            return True
            
        except Exception as e:
            logger.error(f"Error insertando auditoría: {e}")
            self.conn.rollback()
            return False
    
    def consultar_por_fecha(self, fecha_inicio, fecha_fin):
        """
        Consulta registros de auditoría por rango de fechas
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT * FROM log_auditoria 
            WHERE fecha_hora BETWEEN ? AND ?
            ORDER BY fecha_hora DESC
            """
            cursor.execute(query, (fecha_inicio, fecha_fin))
            
            # Convertir a diccionario
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = [dict(zip(columns, row)) for row in rows]
            
            return result
            
        except Exception as e:
            logger.error(f"Error consultando auditoría: {e}")
            return []
    
    def consultar_por_usuario(self, usuario):
        """
        Consulta registros de un usuario específico
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT * FROM log_auditoria 
            WHERE usuario = ?
            ORDER BY fecha_hora DESC
            """
            cursor.execute(query, (usuario,))
            
            # Convertir a diccionario
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = [dict(zip(columns, row)) for row in rows]
            
            return result
            
        except Exception as e:
            logger.error(f"Error consultando auditoría: {e}")
            return []
    
    def consultar_por_tabla(self, tabla, registro_id):
        """
        Consulta historial de cambios en un registro específico
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT * FROM log_auditoria 
            WHERE tabla_afectada = ? AND registro_id = ?
            ORDER BY fecha_hora DESC
            """
            cursor.execute(query, (tabla, registro_id))
            
            # Convertir a diccionario
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = [dict(zip(columns, row)) for row in rows]
            
            return result
            
        except Exception as e:
            logger.error(f"Error consultando auditoría: {e}")
            return []
----- capa_datos/venta_repo.py -----
"""
Repositorio para la gestión de ventas en la base de datos
"""
from loguru import logger

class VentaRepositorio:
    """Clase que maneja las operaciones de base de datos para ventas"""
    
    def __init__(self, conn):
        """
        Inicializa el repositorio con una conexión a la base de datos
        
        Args:
            conn: Conexión a la base de datos
        """
        self.conn = conn
    
    def listar(self):
        """
        Lista todas las ventas con todos los campos incluyendo multimoneda
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT 
                v.idventa, 
                CONVERT(varchar, v.fecha_hora, 103) + ' ' + CONVERT(varchar, v.fecha_hora, 108) as fecha,
                v.fecha_hora,
                v.tipo_comprobante, 
                v.serie, 
                v.numero_comprobante, 
                v.igv, 
                v.estado,
                v.moneda,
                v.tasa_cambio,
                v.monto_bs,
                v.monto_divisa,
                ISNULL(c.nombre + ' ' + c.apellidos, 'CONSUMIDOR FINAL') as cliente,
                t.nombre + ' ' + t.apellidos as trabajador
            FROM venta v
            LEFT JOIN cliente c ON v.idcliente = c.idcliente
            LEFT JOIN trabajador t ON v.idtrabajador = t.idtrabajador
            ORDER BY v.fecha_hora DESC
            """
            cursor.execute(query)
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            logger.info(f"✅ {len(result)} ventas listadas")
            return result
            
        except Exception as e:
            logger.error(f"Error al listar ventas: {e}")
            return []
    
    def obtener_por_id(self, idventa):
        """
        Obtiene una venta por su ID
        
        Args:
            idventa (int): ID de la venta
            
        Returns:
            dict: Datos de la venta o None si no existe
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT v.idventa, 
                   CONVERT(varchar, v.fecha_hora, 103) + ' ' + CONVERT(varchar, v.fecha_hora, 108) as fecha,
                   v.fecha_hora,
                   v.tipo_comprobante, 
                   v.serie, v.numero_comprobante, v.igv, v.estado,
                   v.moneda,
                   v.tasa_cambio,
                   v.monto_bs,
                   v.monto_divisa,
                   c.nombre + ' ' + c.apellidos as cliente,
                   c.idcliente,
                   t.nombre + ' ' + t.apellidos as trabajador,
                   t.idtrabajador
            FROM venta v
            LEFT JOIN cliente c ON v.idcliente = c.idcliente
            LEFT JOIN trabajador t ON v.idtrabajador = t.idtrabajador
            WHERE v.idventa = ?
            """
            cursor.execute(query, (idventa,))
            
            columns = [column[0] for column in cursor.description]
            row = cursor.fetchone()
            
            if row:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                return row_dict
            return None
            
        except Exception as e:
            logger.error(f"Error al obtener venta {idventa}: {e}")
            return None
    
    def crear(self, idtrabajador, idcliente, tipo_comprobante, 
              serie, numero_comprobante, igv, estado='REGISTRADO',
              moneda='VES', tasa_cambio=1.0, monto_bs=None, monto_divisa=None):
        """
        Inserta una nueva venta con soporte multimoneda
        """
        try:
            cursor = self.conn.cursor()
            
            query = """
            INSERT INTO venta 
            (idtrabajador, idcliente, fecha_hora, tipo_comprobante, 
             serie, numero_comprobante, igv, estado,
             moneda, tasa_cambio, monto_bs, monto_divisa)
            OUTPUT INSERTED.idventa
            VALUES (?, ?, GETDATE(), ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            cursor.execute(query, (
                idtrabajador, 
                idcliente,
                tipo_comprobante,
                serie, 
                numero_comprobante, 
                igv, 
                estado,
                moneda,
                tasa_cambio,
                monto_bs,
                monto_divisa
            ))
            
            row = cursor.fetchone()
            idventa = row[0] if row else None
            self.conn.commit()
            
            logger.info(f"✅ Venta #{idventa} creada - Moneda: {moneda} - Tasa: {tasa_cambio}")
            return idventa
            
        except Exception as e:
            logger.error(f"❌ Error al crear venta: {e}")
            self.conn.rollback()
            return None
    
    def agregar_detalle(self, idventa, idarticulo, cantidad, precio_venta):
        """
        Agrega un detalle a una venta
        """
        try:
            cursor = self.conn.cursor()
            
            query = """
            INSERT INTO detalle_venta 
            (idventa, idarticulo, cantidad, precio_venta)
            OUTPUT INSERTED.iddetalle_venta
            VALUES (?, ?, ?, ?)
            """
            
            cursor.execute(query, (idventa, idarticulo, cantidad, precio_venta))
            
            row = cursor.fetchone()
            iddetalle = row[0] if row else None
            self.conn.commit()
            
            logger.info(f"✅ Detalle de venta agregado: {cantidad} x {precio_venta}")
            return iddetalle
            
        except Exception as e:
            logger.error(f"❌ Error al agregar detalle: {e}")
            self.conn.rollback()
            return None
    
    def obtener_detalles(self, idventa):
        """
        Obtiene los detalles de una venta
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT dv.iddetalle_venta, dv.cantidad, dv.precio_venta,
                   a.idarticulo, a.nombre as articulo, a.codigo
            FROM detalle_venta dv
            JOIN articulo a ON dv.idarticulo = a.idarticulo
            WHERE dv.idventa = ?
            """
            cursor.execute(query, (idventa,))
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error al obtener detalles de venta {idventa}: {e}")
            return []
    
    def anular(self, idventa):
        """
        Anula una venta (cambia estado a ANULADO)
        """
        try:
            cursor = self.conn.cursor()
            query = "UPDATE venta SET estado = 'ANULADO' WHERE idventa = ?"
            cursor.execute(query, (idventa,))
            self.conn.commit()
            
            if cursor.rowcount > 0:
                logger.info(f"✅ Venta {idventa} anulada")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error al anular venta {idventa}: {e}")
            self.conn.rollback()
            return False
    
    def ventas_por_cliente(self, idcliente):
        """
        Obtiene todas las ventas de un cliente
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT v.idventa, v.fecha_hora, v.tipo_comprobante, 
                   v.serie, v.numero_comprobante, v.igv, v.estado,
                   v.moneda, v.monto_bs, v.monto_divisa
            FROM venta v
            WHERE v.idcliente = ?
            ORDER BY v.fecha_hora DESC
            """
            cursor.execute(query, (idcliente,))
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error al obtener ventas del cliente {idcliente}: {e}")
            return []
    
    def ventas_por_fecha(self, fecha_inicio, fecha_fin):
        """
        Obtiene ventas en un rango de fechas
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT 
                v.idventa, 
                CONVERT(varchar, v.fecha_hora, 103) + ' ' + CONVERT(varchar, v.fecha_hora, 108) as fecha,
                v.fecha_hora,
                v.tipo_comprobante, 
                v.serie, 
                v.numero_comprobante, 
                v.igv, 
                v.estado,
                v.moneda,
                v.tasa_cambio,
                v.monto_bs,
                v.monto_divisa,
                ISNULL(c.nombre + ' ' + c.apellidos, 'CONSUMIDOR FINAL') as cliente,
                t.nombre + ' ' + t.apellidos as trabajador
            FROM venta v
            LEFT JOIN cliente c ON v.idcliente = c.idcliente
            LEFT JOIN trabajador t ON v.idtrabajador = t.idtrabajador
            WHERE CAST(v.fecha_hora AS DATE) BETWEEN ? AND ?
            ORDER BY v.fecha_hora DESC
            """
            cursor.execute(query, (fecha_inicio, fecha_fin))
            
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            result = []
            for row in rows:
                row_dict = {}
                for i, col in enumerate(columns):
                    row_dict[col] = row[i]
                result.append(row_dict)
            
            return result
            
        except Exception as e:
            logger.error(f"Error al obtener ventas por fecha: {e}")
            return []
----- capa_datos/cliente_repo.py -----
"""
Repositorio para la gestión de clientes en la base de datos
"""
from loguru import logger

class ClienteRepositorio:
    """Clase que maneja las operaciones de base de datos para clientes"""
    
    def __init__(self, conn):
        """
        Inicializa el repositorio con una conexión a la base de datos
        
        Args:
            conn: Conexión a la base de datos
        """
        self.conn = conn
    
    def _row_to_dict(self, row, description):
        """
        Convierte una fila de pyodbc a diccionario
        """
        if not row:
            return None
        return {desc[0]: value for desc, value in zip(description, row)}
    
    def _rows_to_dicts(self, rows, description):
        """
        Convierte múltiples filas de pyodbc a lista de diccionarios
        """
        if not rows:
            return []
        return [self._row_to_dict(row, description) for row in rows]
    
    def listar(self):
        """
        Lista todos los clientes activos
        
        Returns:
            list: Lista de clientes o lista vacía si hay error
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idcliente, nombre, apellidos, fecha_nacimiento, 
                   tipo_documento, num_documento, sexo, direccion, telefono, email
            FROM cliente 
            ORDER BY idcliente DESC
            """
            cursor.execute(query)
            rows = cursor.fetchall()
            description = cursor.description
            return self._rows_to_dicts(rows, description)
        except Exception as e:
            logger.error(f"Error al listar clientes: {e}")
            return []
    
    def obtener_por_id(self, idcliente):
        """
        Obtiene un cliente por su ID
        
        Args:
            idcliente (int): ID del cliente
            
        Returns:
            dict: Datos del cliente o None si no existe
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idcliente, nombre, apellidos, fecha_nacimiento, 
                   tipo_documento, num_documento, sexo, direccion, telefono, email
            FROM cliente 
            WHERE idcliente = ?
            """
            cursor.execute(query, (idcliente,))
            row = cursor.fetchone()
            description = cursor.description
            return self._row_to_dict(row, description)
        except Exception as e:
            logger.error(f"Error al obtener cliente {idcliente}: {e}")
            return None
    
    def buscar_por_documento(self, tipo_documento, num_documento):
        """
        Busca un cliente por tipo y número de documento
        
        Args:
            tipo_documento (str): Tipo de documento (V, E, J, G, C)
            num_documento (str): Número de documento
            
        Returns:
            dict: Datos del cliente o None si no existe
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idcliente, nombre, apellidos, fecha_nacimiento, 
                   tipo_documento, num_documento
            FROM cliente 
            WHERE tipo_documento = ? AND num_documento = ?
            """
            cursor.execute(query, (tipo_documento, num_documento))
            row = cursor.fetchone()
            description = cursor.description
            return self._row_to_dict(row, description)
        except Exception as e:
            logger.error(f"Error al buscar cliente por documento {tipo_documento}-{num_documento}: {e}")
            return None
    
    def crear(self, nombre, apellidos, fecha_nacimiento, tipo_documento, 
              num_documento, sexo=None, direccion=None, telefono=None, email=None):
        """
        Inserta un nuevo cliente (fecha_nacimiento puede ser NULL)
        """
        try:
            cursor = self.conn.cursor()
            
            query = """
            INSERT INTO cliente 
            (nombre, apellidos, fecha_nacimiento, tipo_documento, num_documento, 
             sexo, direccion, telefono, email)
            OUTPUT INSERTED.idcliente
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            cursor.execute(query, (
                nombre, apellidos, fecha_nacimiento, tipo_documento, num_documento,
                sexo, direccion, telefono, email
            ))
            
            row = cursor.fetchone()
            idcliente = row[0] if row else None
            self.conn.commit()
            
            if idcliente:
                logger.info(f"✅ Cliente creado con ID: {idcliente}")
                return idcliente
            return None
                
        except Exception as e:
            logger.error(f"❌ Error al crear cliente: {e}")
            self.conn.rollback()
            return None
    
    def actualizar(self, idcliente, nombre, apellidos, fecha_nacimiento, tipo_documento,
                   num_documento, sexo=None, direccion=None, telefono=None, email=None):
        """
        Actualiza un cliente existente
        
        Returns:
            bool: True si se actualizó correctamente, False en caso contrario
        """
        try:
            cursor = self.conn.cursor()
            query = """
            UPDATE cliente 
            SET nombre = ?, apellidos = ?, fecha_nacimiento = ?,
                tipo_documento = ?, num_documento = ?, sexo = ?,
                direccion = ?, telefono = ?, email = ?
            WHERE idcliente = ?
            """
            cursor.execute(query, (
                nombre, apellidos, fecha_nacimiento, tipo_documento, num_documento,
                sexo, direccion, telefono, email, idcliente
            ))
            self.conn.commit()
            afectadas = cursor.rowcount
            if afectadas > 0:
                logger.info(f"✅ Cliente {idcliente} actualizado correctamente")
                return True
            else:
                logger.warning(f"⚠️ No se encontró el cliente {idcliente} para actualizar")
                return False
        except Exception as e:
            logger.error(f"❌ Error al actualizar cliente {idcliente}: {e}")
            self.conn.rollback()
            return False
    
    def eliminar(self, idcliente):
        """
        Elimina un cliente (físicamente de la BD)
        
        Returns:
            bool: True si se eliminó correctamente, False en caso contrario
        """
        try:
            cursor = self.conn.cursor()
            
            # Verificar si el cliente tiene ventas asociadas
            check_query = "SELECT COUNT(*) as total FROM venta WHERE idcliente = ?"
            cursor.execute(check_query, (idcliente,))
            row = cursor.fetchone()
            total = row[0] if row else 0
            
            if total > 0:
                logger.warning(f"⚠️ Cliente {idcliente} tiene ventas asociadas. No se puede eliminar")
                return False
            
            # Eliminación física
            query = "DELETE FROM cliente WHERE idcliente = ?"
            cursor.execute(query, (idcliente,))
            self.conn.commit()
            
            if cursor.rowcount > 0:
                logger.info(f"✅ Cliente {idcliente} eliminado correctamente")
                return True
            else:
                logger.warning(f"⚠️ No se encontró el cliente {idcliente} para eliminar")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error al eliminar cliente {idcliente}: {e}")
            self.conn.rollback()
            return False
    
    def buscar_por_nombre(self, termino):
        """
        Busca clientes por nombre o apellido (búsqueda parcial)
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT idcliente, nombre, apellidos, fecha_nacimiento, 
                   tipo_documento, num_documento, telefono, email
            FROM cliente 
            WHERE nombre LIKE ? OR apellidos LIKE ?
            ORDER BY nombre, apellidos
            """
            busqueda = f"%{termino}%"
            cursor.execute(query, (busqueda, busqueda))
            rows = cursor.fetchall()
            description = cursor.description
            return self._rows_to_dicts(rows, description)
        except Exception as e:
            logger.error(f"Error al buscar clientes por nombre '{termino}': {e}")
            return []
    
    def contar_clientes(self):
        """
        Cuenta el número total de clientes
        """
        try:
            cursor = self.conn.cursor()
            query = "SELECT COUNT(*) as total FROM cliente"
            cursor.execute(query)
            row = cursor.fetchone()
            return row[0] if row else 0
        except Exception as e:
            logger.error(f"Error al contar clientes: {e}")
            return 0
    
    def clientes_recientes(self, limite=10):
        """
        Obtiene los clientes más recientes
        """
        try:
            cursor = self.conn.cursor()
            query = """
            SELECT TOP (?) idcliente, nombre, apellidos, fecha_nacimiento, 
                   tipo_documento, num_documento, telefono, email
            FROM cliente 
            ORDER BY idcliente DESC
            """
            cursor.execute(query, (limite,))
            rows = cursor.fetchall()
            description = cursor.description
            return self._rows_to_dicts(rows, description)
        except Exception as e:
            logger.error(f"Error al obtener clientes recientes: {e}")
            return []
----- capa_datos/rol_repo.py -----
from typing import List, Dict, Optional
from loguru import logger

class RolRepositorio:
    """Repositorio para gestión de roles y permisos"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar_roles(self) -> List[Dict]:
        """Lista todos los roles"""
        try:
            self.cursor.execute("""
                SELECT idrol, nombre, descripcion, nivel, activo
                FROM rol
                ORDER BY nivel DESC
            """)
            columnas = [column[0] for column in self.cursor.description]
            return [dict(zip(columnas, row)) for row in self.cursor.fetchall()]
        except Exception as e:
            logger.error(f"❌ Error al listar roles: {e}")
            return []
    
    def obtener_rol(self, idrol: int) -> Optional[Dict]:
        """Obtiene un rol por su ID"""
        try:
            self.cursor.execute("""
                SELECT idrol, nombre, descripcion, nivel, activo
                FROM rol WHERE idrol = ?
            """, (idrol,))
            row = self.cursor.fetchone()
            if row:
                columnas = [column[0] for column in self.cursor.description]
                return dict(zip(columnas, row))
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener rol {idrol}: {e}")
            return None
    
    def listar_permisos(self, modulo: str = None) -> List[Dict]:
        """Lista todos los permisos, opcionalmente filtrados por módulo"""
        try:
            query = "SELECT idpermiso, nombre, descripcion, modulo FROM permiso"
            params = []
            if modulo:
                query += " WHERE modulo = ?"
                params.append(modulo)
            query += " ORDER BY modulo, nombre"
            
            self.cursor.execute(query, params)
            columnas = [column[0] for column in self.cursor.description]
            return [dict(zip(columnas, row)) for row in self.cursor.fetchall()]
        except Exception as e:
            logger.error(f"❌ Error al listar permisos: {e}")
            return []
    
    def obtener_permisos_rol(self, idrol: int) -> List[str]:
        """Obtiene los nombres de permisos de un rol"""
        try:
            self.cursor.execute("""
                SELECT p.nombre
                FROM permiso p
                INNER JOIN rol_permiso rp ON p.idpermiso = rp.idpermiso
                WHERE rp.idrol = ?
            """, (idrol,))
            return [row[0] for row in self.cursor.fetchall()]
        except Exception as e:
            logger.error(f"❌ Error al obtener permisos del rol {idrol}: {e}")
            return []
    
    def asignar_permisos_rol(self, idrol: int, permisos: List[int]) -> bool:
        """Asigna permisos a un rol (reemplaza los existentes)"""
        try:
            self.cursor.execute("BEGIN TRANSACTION")
            
            # Eliminar permisos actuales
            self.cursor.execute("DELETE FROM rol_permiso WHERE idrol = ?", (idrol,))
            
            # Insertar nuevos permisos
            for idpermiso in permisos:
                self.cursor.execute("""
                    INSERT INTO rol_permiso (idrol, idpermiso)
                    VALUES (?, ?)
                """, (idrol, idpermiso))
            
            self.cursor.execute("COMMIT TRANSACTION")
            logger.success(f"✅ Permisos asignados al rol {idrol}")
            return True
        except Exception as e:
            self.cursor.execute("ROLLBACK TRANSACTION")
            logger.error(f"❌ Error al asignar permisos: {e}")
            return False
    
    def asignar_rol_trabajador(self, idtrabajador: int, idrol: int) -> bool:
        """Asigna un rol a un trabajador"""
        try:
            self.cursor.execute("""
                UPDATE trabajador SET idrol = ? WHERE idtrabajador = ?
            """, (idrol, idtrabajador))
            self.cursor.commit()
            logger.success(f"✅ Rol {idrol} asignado al trabajador {idtrabajador}")
            return True
        except Exception as e:
            logger.error(f"❌ Error al asignar rol: {e}")
            return False
    
    def crear_rol(self, nombre: str, descripcion: str = None, nivel: int = 1) -> Optional[int]:
        """Crea un nuevo rol"""
        try:
            self.cursor.execute("""
                INSERT INTO rol (nombre, descripcion, nivel, activo)
                OUTPUT INSERTED.idrol
                VALUES (?, ?, ?, 1)
            """, (nombre, descripcion, nivel))
            idrol = self.cursor.fetchone()[0]
            self.cursor.commit()
            logger.success(f"✅ Rol '{nombre}' creado")
            return idrol
        except Exception as e:
            logger.error(f"❌ Error al crear rol: {e}")
            return None
----- capa_datos/trabajador_repo.py -----
from typing import List, Dict, Optional
from loguru import logger
import hashlib

class TrabajadorRepositorio:
    """Repositorio para operaciones CRUD de trabajadores"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def _hash_password(self, password: str) -> str:
        """Genera hash de contraseña"""
        return hashlib.sha256(password.encode()).hexdigest()
    
    def listar(self) -> List[Dict]:
        """Lista todos los trabajadores"""
        try:
            self.cursor.execute("""
                SELECT idtrabajador, nombre, apellidos, sexo,
                       fecha_nacimiento, num_documento, direccion,
                       telefono, email, usuario, idrol
                FROM trabajador ORDER BY apellidos, nombre
            """)
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} trabajadores listados")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar trabajadores: {e}")
            return []
    
    def obtener_por_id(self, idtrabajador: int) -> Optional[Dict]:
        """Obtiene un trabajador por su ID"""
        try:
            self.cursor.execute(
                "SELECT * FROM trabajador WHERE idtrabajador = ?",
                (idtrabajador,)
            )
            row = self.cursor.fetchone()
            if row:
                columnas = [column[0] for column in self.cursor.description]
                return dict(zip(columnas, row))
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener trabajador {idtrabajador}: {e}")
            return None
    
    def autenticar(self, usuario: str, password: str) -> Optional[Dict]:
        """Autentica un trabajador por usuario y contraseña"""
        try:
            password_hash = self._hash_password(password)
            self.cursor.execute("""
                SELECT idtrabajador, nombre, apellidos, usuario, email, idrol
                FROM trabajador 
                WHERE usuario = ? AND password_hash = ?
            """, (usuario, password_hash))
            row = self.cursor.fetchone()
            if row:
                return {
                    'idtrabajador': row[0],
                    'nombre': row[1],
                    'apellidos': row[2],
                    'usuario': row[3],
                    'email': row[4],
                    'idrol': row[5]
                }
            return None
        except Exception as e:
            logger.error(f"❌ Error en autenticación: {e}")
            return None
    
    def buscar_por_email(self, email: str) -> Optional[Dict]:
        """Busca un trabajador por su email"""
        try:
            self.cursor.execute("""
                SELECT idtrabajador, nombre, apellidos, usuario, email, idrol
                FROM trabajador 
                WHERE email = ?
            """, (email,))
            row = self.cursor.fetchone()
            if row:
                return {
                    'idtrabajador': row[0],
                    'nombre': row[1],
                    'apellidos': row[2],
                    'usuario': row[3],
                    'email': row[4],
                    'idrol': row[5]
                }
            return None
        except Exception as e:
            logger.error(f"❌ Error al buscar por email: {e}")
            return None
    
    def autenticar_por_email(self, email: str, password: str) -> Optional[Dict]:
        """Autentica un trabajador por email y contraseña"""
        try:
            password_hash = self._hash_password(password)
            self.cursor.execute("""
                SELECT idtrabajador, nombre, apellidos, usuario, email, idrol
                FROM trabajador 
                WHERE email = ? AND password_hash = ?
            """, (email, password_hash))
            row = self.cursor.fetchone()
            if row:
                return {
                    'idtrabajador': row[0],
                    'nombre': row[1],
                    'apellidos': row[2],
                    'usuario': row[3],
                    'email': row[4],
                    'idrol': row[5]
                }
            return None
        except Exception as e:
            logger.error(f"❌ Error en autenticación por email: {e}")
            return None
    
    def insertar(self, nombre: str, apellidos: str, sexo: str,
                 fecha_nacimiento, num_documento: str,
                 usuario: str, password: str,
                 direccion: str = None, telefono: str = None,
                 email: str = None) -> bool:
        """Inserta un nuevo trabajador"""
        try:
            password_hash = self._hash_password(password)
            self.cursor.execute("""
                INSERT INTO trabajador 
                (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                 direccion, telefono, email, usuario, password_hash) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                 direccion, telefono, email, usuario, password_hash))
            self.cursor.commit()
            logger.success(f"✅ Trabajador '{nombre} {apellidos}' insertado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al insertar trabajador: {e}")
            return False
    
    def actualizar(self, idtrabajador: int, nombre: str, apellidos: str, sexo: str,
                   fecha_nacimiento, num_documento: str, usuario: str,
                   password: str = None, direccion: str = None,
                   telefono: str = None, email: str = None) -> bool:
        """Actualiza un trabajador existente"""
        try:
            if password:
                password_hash = self._hash_password(password)
                self.cursor.execute("""
                    UPDATE trabajador 
                    SET nombre = ?, apellidos = ?, sexo = ?, fecha_nacimiento = ?,
                        num_documento = ?, direccion = ?, telefono = ?,
                        email = ?, usuario = ?, password_hash = ?
                    WHERE idtrabajador = ?
                """, (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                     direccion, telefono, email, usuario, password_hash, idtrabajador))
            else:
                self.cursor.execute("""
                    UPDATE trabajador 
                    SET nombre = ?, apellidos = ?, sexo = ?, fecha_nacimiento = ?,
                        num_documento = ?, direccion = ?, telefono = ?,
                        email = ?, usuario = ?
                    WHERE idtrabajador = ?
                """, (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                     direccion, telefono, email, usuario, idtrabajador))
            self.cursor.commit()
            logger.success(f"✅ Trabajador ID {idtrabajador} actualizado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al actualizar trabajador: {e}")
            return False
    
    def eliminar(self, idtrabajador: int) -> bool:
        """Elimina un trabajador"""
        try:
            self.cursor.execute("DELETE FROM trabajador WHERE idtrabajador = ?", (idtrabajador,))
            self.cursor.commit()
            logger.success(f"✅ Trabajador ID {idtrabajador} eliminado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al eliminar trabajador: {e}")
            return False
----- capa_datos/conexion.py -----
import pyodbc
import os
from dotenv import load_dotenv
from loguru import logger

# Cargar variables de entorno
load_dotenv()

class ConexionDB:
    """Singleton para manejar la conexión a SQL Server"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._inicializar()
        return cls._instance
    
    def _inicializar(self):
        self.server = os.getenv('DB_SERVER', 'localhost,1433')
        self.database = os.getenv('DB_NAME', 'SistemaVentas')
        self.username = os.getenv('DB_USER', 'sa')
        self.password = os.getenv('DB_PASSWORD', 'Santi07.')
        self.driver = os.getenv('DB_DRIVER', '{ODBC Driver 18 for SQL Server}')
        self.conn = None
    
    def conectar(self):
        """Establece conexión con la base de datos"""
        try:
            conn_str = (
                f"DRIVER={self.driver};"
                f"SERVER={self.server};"
                f"DATABASE={self.database};"
                f"UID={self.username};"
                f"PWD={self.password};"
                f"TrustServerCertificate=yes;"
            )
            self.conn = pyodbc.connect(conn_str)
            logger.success("✅ Conexión exitosa a SQL Server")
            return self.conn
        except Exception as e:
            logger.error(f"❌ Error de conexión: {e}")
            return None
    
    def cerrar(self):
        if self.conn:
            self.conn.close()
            logger.info("🔒 Conexión cerrada")
----- capa_datos/usuario_admin_repo.py -----
from typing import List, Dict, Optional
from loguru import logger
import hashlib

class UsuarioAdminRepositorio:
    """Repositorio para administración de usuarios (solo para admin)"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar_usuarios(self) -> List[Dict]:
        """Lista todos los usuarios con su información de rol"""
        try:
            self.cursor.execute("""
                SELECT t.idtrabajador, t.nombre, t.apellidos, t.usuario, 
                       t.email, t.telefono, t.idrol, r.nombre as rol_nombre
                FROM trabajador t
                LEFT JOIN rol r ON t.idrol = r.idrol
                ORDER BY t.idtrabajador
            """)
            columnas = [column[0] for column in self.cursor.description]
            return [dict(zip(columnas, row)) for row in self.cursor.fetchall()]
        except Exception as e:
            logger.error(f"❌ Error al listar usuarios: {e}")
            return []
    
    def obtener_usuario(self, idtrabajador: int) -> Optional[Dict]:
        """Obtiene un usuario por su ID"""
        try:
            self.cursor.execute("""
                SELECT t.*, r.nombre as rol_nombre
                FROM trabajador t
                LEFT JOIN rol r ON t.idrol = r.idrol
                WHERE t.idtrabajador = ?
            """, (idtrabajador,))
            row = self.cursor.fetchone()
            if row:
                columnas = [column[0] for column in self.cursor.description]
                return dict(zip(columnas, row))
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener usuario: {e}")
            return None
    
    def _hash_password(self, password: str) -> str:
        """Genera hash SHA256 de la contraseña"""
        return hashlib.sha256(password.encode()).hexdigest()
    
    def crear_usuario(self, nombre: str, apellidos: str, sexo: str,
                      fecha_nacimiento, num_documento: str,
                      usuario: str, password: str,
                      email: str, idrol: int,
                      direccion: str = None, telefono: str = None) -> bool:
        """Crea un nuevo usuario"""
        try:
            password_hash = self._hash_password(password)
            self.cursor.execute("""
                INSERT INTO trabajador 
                (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                 usuario, password_hash, email, idrol, direccion, telefono)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                  usuario, password_hash, email, idrol, direccion, telefono))
            self.cursor.commit()
            logger.success(f"✅ Usuario '{usuario}' creado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al crear usuario: {e}")
            return False
    
    def actualizar_usuario(self, idtrabajador: int, nombre: str, apellidos: str,
                           sexo: str, fecha_nacimiento, num_documento: str,
                           usuario: str, email: str, idrol: int,
                           direccion: str = None, telefono: str = None,
                           nueva_password: str = None) -> bool:
        """Actualiza un usuario existente"""
        try:
            if nueva_password:
                password_hash = self._hash_password(nueva_password)
                self.cursor.execute("""
                    UPDATE trabajador 
                    SET nombre = ?, apellidos = ?, sexo = ?, fecha_nacimiento = ?,
                        num_documento = ?, usuario = ?, email = ?, idrol = ?,
                        direccion = ?, telefono = ?, password_hash = ?
                    WHERE idtrabajador = ?
                """, (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                      usuario, email, idrol, direccion, telefono, 
                      password_hash, idtrabajador))
            else:
                self.cursor.execute("""
                    UPDATE trabajador 
                    SET nombre = ?, apellidos = ?, sexo = ?, fecha_nacimiento = ?,
                        num_documento = ?, usuario = ?, email = ?, idrol = ?,
                        direccion = ?, telefono = ?
                    WHERE idtrabajador = ?
                """, (nombre, apellidos, sexo, fecha_nacimiento, num_documento,
                      usuario, email, idrol, direccion, telefono, idtrabajador))
            self.cursor.commit()
            logger.success(f"✅ Usuario ID {idtrabajador} actualizado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al actualizar usuario: {e}")
            return False
    
    def eliminar_usuario(self, idtrabajador: int) -> bool:
        """Elimina un usuario"""
        try:
            self.cursor.execute("DELETE FROM trabajador WHERE idtrabajador = ?", (idtrabajador,))
            self.cursor.commit()
            logger.success(f"✅ Usuario ID {idtrabajador} eliminado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al eliminar usuario: {e}")
            return False
    
    def verificar_usuario_existe(self, usuario: str, email: str) -> bool:
        """Verifica si ya existe un usuario con ese nombre o email"""
        try:
            self.cursor.execute("""
                SELECT COUNT(*) FROM trabajador 
                WHERE usuario = ? OR email = ?
            """, (usuario, email))
            count = self.cursor.fetchone()[0]
            return count > 0
        except Exception as e:
            logger.error(f"❌ Error al verificar usuario: {e}")
            return True  # Por seguridad, asumir que existe si hay error
----- capa_datos/proveedor_repo.py -----
from typing import List, Dict, Optional
from loguru import logger

class ProveedorRepositorio:
    """Repositorio para operaciones CRUD de proveedores"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar(self) -> List[Dict]:
        """Lista todos los proveedores"""
        try:
            self.cursor.execute("""
                SELECT idproveedor, razon_social, sector_comercial,
                       tipo_documento, num_documento, direccion,
                       telefono, email, url
                FROM proveedor ORDER BY razon_social
            """)
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} proveedores listados")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar proveedores: {e}")
            return []
    
    def obtener_por_id(self, idproveedor: int) -> Optional[Dict]:
        """Obtiene un proveedor por su ID"""
        try:
            self.cursor.execute(
                "SELECT * FROM proveedor WHERE idproveedor = ?",
                (idproveedor,)
            )
            row = self.cursor.fetchone()
            if row:
                columnas = [column[0] for column in self.cursor.description]
                return dict(zip(columnas, row))
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener proveedor {idproveedor}: {e}")
            return None
    
    def insertar(self, razon_social: str, sector_comercial: str,
                 tipo_documento: str, num_documento: str,
                 direccion: str = None, telefono: str = None,
                 email: str = None, url: str = None) -> bool:
        """Inserta un nuevo proveedor"""
        try:
            self.cursor.execute(
                """INSERT INTO proveedor 
                   (razon_social, sector_comercial, tipo_documento, num_documento,
                    direccion, telefono, email, url) 
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                (razon_social, sector_comercial, tipo_documento, num_documento,
                 direccion, telefono, email, url)
            )
            self.cursor.commit()
            logger.success(f"✅ Proveedor '{razon_social}' insertado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al insertar proveedor: {e}")
            return False
    
    def actualizar(self, idproveedor: int, razon_social: str, sector_comercial: str,
                   tipo_documento: str, num_documento: str,
                   direccion: str = None, telefono: str = None,
                   email: str = None, url: str = None) -> bool:
        """Actualiza un proveedor existente"""
        try:
            self.cursor.execute(
                """UPDATE proveedor 
                   SET razon_social = ?, sector_comercial = ?,
                       tipo_documento = ?, num_documento = ?,
                       direccion = ?, telefono = ?, email = ?, url = ?
                   WHERE idproveedor = ?""",
                (razon_social, sector_comercial, tipo_documento, num_documento,
                 direccion, telefono, email, url, idproveedor)
            )
            self.cursor.commit()
            logger.success(f"✅ Proveedor ID {idproveedor} actualizado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al actualizar proveedor: {e}")
            return False
    
    def eliminar(self, idproveedor: int) -> bool:
        """Elimina un proveedor"""
        try:
            self.cursor.execute("DELETE FROM proveedor WHERE idproveedor = ?", (idproveedor,))
            self.cursor.commit()
            logger.success(f"✅ Proveedor ID {idproveedor} eliminado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al eliminar proveedor: {e}")
            return False
----- capa_datos/proveedor_archivo_repo.py -----
from typing import List, Dict, Optional
from datetime import datetime
from loguru import logger

class ProveedorArchivoRepositorio:
    """Repositorio para gestión de archivos de proveedores"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar_por_proveedor(self, idproveedor: int) -> List[Dict]:
        """Lista todos los archivos de un proveedor (sin contenido)"""
        try:
            self.cursor.execute("""
                SELECT idarchivo, nombre_archivo, tipo_archivo, tamano, fecha_subida, descripcion
                FROM proveedor_archivos
                WHERE idproveedor = ?
                ORDER BY fecha_subida DESC
            """, (idproveedor,))
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar archivos del proveedor {idproveedor}: {e}")
            return []
    
    def obtener_archivo(self, idarchivo: int) -> Optional[Dict]:
        """Obtiene un archivo por su ID (incluyendo el contenido)"""
        try:
            self.cursor.execute("""
                SELECT pv.*, p.razon_social as proveedor
                FROM proveedor_archivos pv
                INNER JOIN proveedor p ON pv.idproveedor = p.idproveedor
                WHERE pv.idarchivo = ?
            """, (idarchivo,))
            row = self.cursor.fetchone()
            if row:
                columnas = [column[0] for column in self.cursor.description]
                return dict(zip(columnas, row))
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener archivo {idarchivo}: {e}")
            return None
    
    def insertar(self, idproveedor: int, nombre_archivo: str, 
                 tipo_archivo: str, contenido: bytes, 
                 descripcion: str = None) -> Optional[int]:
        """Inserta un nuevo archivo"""
        try:
            tamano = len(contenido)
            self.cursor.execute("""
                INSERT INTO proveedor_archivos 
                (idproveedor, nombre_archivo, tipo_archivo, tamano, contenido, descripcion)
                OUTPUT INSERTED.idarchivo
                VALUES (?, ?, ?, ?, ?, ?)
            """, (idproveedor, nombre_archivo, tipo_archivo, tamano, contenido, descripcion))
            idarchivo = self.cursor.fetchone()[0]
            self.cursor.commit()
            logger.success(f"✅ Archivo '{nombre_archivo}' subido para proveedor {idproveedor}")
            return idarchivo
        except Exception as e:
            logger.error(f"❌ Error al insertar archivo: {e}")
            return None
    
    def eliminar(self, idarchivo: int) -> bool:
        """Elimina un archivo"""
        try:
            self.cursor.execute("DELETE FROM proveedor_archivos WHERE idarchivo = ?", (idarchivo,))
            self.cursor.commit()
            logger.success(f"✅ Archivo ID {idarchivo} eliminado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al eliminar archivo: {e}")
            return False
----- capa_datos/ingreso_repo.py -----
from typing import List, Dict, Optional
from datetime import datetime
from loguru import logger

class IngresoRepositorio:
    """Repositorio para operaciones CRUD de ingresos"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar(self) -> List[Dict]:
        """Lista todos los ingresos"""
        try:
            query = """
                SELECT i.idingreso, i.fecha, i.tipo_comprobante, i.serie, i.numero_comprobante,
                       i.igv, i.estado,
                       p.razon_social as proveedor,
                       t.nombre + ' ' + t.apellidos as trabajador
                FROM ingreso i
                INNER JOIN proveedor p ON i.idproveedor = p.idproveedor
                INNER JOIN trabajador t ON i.idtrabajador = t.idtrabajador
                ORDER BY i.fecha DESC
            """
            self.cursor.execute(query)
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} ingresos listados")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar ingresos: {e}")
            return []
    
    def obtener_por_id(self, idingreso: int) -> Optional[Dict]:
        """Obtiene un ingreso por su ID con su detalle"""
        try:
            # Obtener cabecera
            self.cursor.execute("""
                SELECT i.*, p.razon_social as proveedor,
                       t.nombre + ' ' + t.apellidos as trabajador
                FROM ingreso i
                INNER JOIN proveedor p ON i.idproveedor = p.idproveedor
                INNER JOIN trabajador t ON i.idtrabajador = t.idtrabajador
                WHERE i.idingreso = ?
            """, (idingreso,))
            row = self.cursor.fetchone()
            
            if not row:
                return None
            
            columnas = [column[0] for column in self.cursor.description]
            ingreso = dict(zip(columnas, row))
            
            # Obtener detalle
            ingreso['detalle'] = self.obtener_detalle(idingreso)
            
            return ingreso
        except Exception as e:
            logger.error(f"❌ Error al obtener ingreso {idingreso}: {e}")
            return None
    
    def obtener_detalle(self, idingreso: int) -> List[Dict]:
        """Obtiene el detalle de un ingreso"""
        try:
            self.cursor.execute("""
                SELECT di.iddetalle_ingreso, di.cantidad, di.precio_compra,
                       a.idarticulo, a.codigo, a.nombre as articulo
                FROM detalle_ingreso di
                INNER JOIN articulo a ON di.idarticulo = a.idarticulo
                WHERE di.idingreso = ?
            """, (idingreso,))
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al obtener detalle del ingreso: {e}")
            return []
    
    def insertar(self, idtrabajador: int, idproveedor: int,
                 tipo_comprobante: str, serie: str, numero_comprobante: str,
                 igv: float, fecha: datetime = None,
                 detalle: List[Dict] = None) -> Optional[int]:
        """Inserta un nuevo ingreso con su detalle"""
        try:
            # Iniciar transacción
            self.cursor.execute("BEGIN TRANSACTION")
            
            if not fecha:
                fecha = datetime.now()
            
            # Insertar cabecera
            self.cursor.execute("""
                INSERT INTO ingreso 
                (idtrabajador, idproveedor, fecha, tipo_comprobante, 
                 serie, numero_comprobante, igv, estado)
                OUTPUT INSERTED.idingreso
                VALUES (?, ?, ?, ?, ?, ?, ?, 'REGISTRADO')
            """, (idtrabajador, idproveedor, fecha, tipo_comprobante,
                  serie, numero_comprobante, igv))
            
            idingreso = self.cursor.fetchone()[0]
            
            # Insertar detalle
            if detalle:
                for item in detalle:
                    self.cursor.execute("""
                        INSERT INTO detalle_ingreso 
                        (idingreso, idarticulo, cantidad, precio_compra)
                        VALUES (?, ?, ?, ?)
                    """, (idingreso, item['idarticulo'], item['cantidad'], 
                          item['precio_compra']))
            
            self.cursor.execute("COMMIT TRANSACTION")
            logger.success(f"✅ Ingreso ID {idingreso} insertado")
            return idingreso
            
        except Exception as e:
            self.cursor.execute("ROLLBACK TRANSACTION")
            logger.error(f"❌ Error al insertar ingreso: {e}")
            return None
    
    def anular(self, idingreso: int) -> bool:
        """Anula un ingreso"""
        try:
            self.cursor.execute("""
                UPDATE ingreso SET estado = 'ANULADO'
                WHERE idingreso = ?
            """, (idingreso,))
            self.cursor.commit()
            logger.success(f"✅ Ingreso ID {idingreso} anulado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al anular ingreso: {e}")
            return False
----- capa_datos/lote_repo.py -----
from typing import List, Dict, Optional
from datetime import datetime
from loguru import logger

class LoteRepositorio:
    """Repositorio para operaciones CRUD de lotes"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def listar_por_articulo(self, idarticulo: int) -> List[Dict]:
        """Lista los lotes de un artículo específico"""
        try:
            self.cursor.execute("""
                SELECT l.idlote, l.codigo_lote, l.fecha_produccion,
                       l.fecha_vencimiento, l.stock_actual,
                       i.fecha as fecha_ingreso
                FROM lote l
                INNER JOIN ingreso i ON l.idingreso = i.idingreso
                WHERE l.idarticulo = ?
                ORDER BY l.fecha_vencimiento ASC
            """, (idarticulo,))
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} lotes listados para artículo {idarticulo}")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar lotes: {e}")
            return []
    
    def obtener_por_id(self, idlote: int) -> Optional[Dict]:
        """Obtiene un lote por su ID"""
        try:
            self.cursor.execute("""
                SELECT l.*, a.nombre as articulo, a.codigo
                FROM lote l
                INNER JOIN articulo a ON l.idarticulo = a.idarticulo
                WHERE l.idlote = ?
            """, (idlote,))
            row = self.cursor.fetchone()
            if row:
                columnas = [column[0] for column in self.cursor.description]
                return dict(zip(columnas, row))
            return None
        except Exception as e:
            logger.error(f"❌ Error al obtener lote {idlote}: {e}")
            return None
    
    def obtener_stock_articulo(self, idarticulo: int) -> int:
        """Obtiene el stock total de un artículo sumando todos sus lotes"""
        try:
            self.cursor.execute("""
                SELECT SUM(stock_actual) as stock_total
                FROM lote
                WHERE idarticulo = ?
            """, (idarticulo,))
            row = self.cursor.fetchone()
            return row[0] if row[0] else 0
        except Exception as e:
            logger.error(f"❌ Error al obtener stock del artículo {idarticulo}: {e}")
            return 0
    
    def insertar(self, idarticulo: int, idingreso: int,
                 codigo_lote: str = None,
                 fecha_produccion: datetime = None,
                 fecha_vencimiento: datetime = None,
                 stock_actual: int = 0) -> bool:
        """Inserta un nuevo lote"""
        try:
            self.cursor.execute("""
                INSERT INTO lote 
                (idarticulo, idingreso, codigo_lote, fecha_produccion, 
                 fecha_vencimiento, stock_actual) 
                VALUES (?, ?, ?, ?, ?, ?)
            """, (idarticulo, idingreso, codigo_lote, fecha_produccion,
                  fecha_vencimiento, stock_actual))
            self.cursor.commit()
            logger.success(f"✅ Lote insertado para artículo {idarticulo}")
            return True
        except Exception as e:
            logger.error(f"❌ Error al insertar lote: {e}")
            return False
    
    def actualizar_stock(self, idlote: int, nuevo_stock: int) -> bool:
        """Actualiza el stock de un lote específico"""
        try:
            self.cursor.execute("""
                UPDATE lote SET stock_actual = ?
                WHERE idlote = ?
            """, (nuevo_stock, idlote))
            self.cursor.commit()
            logger.success(f"✅ Stock del lote {idlote} actualizado a {nuevo_stock}")
            return True
        except Exception as e:
            logger.error(f"❌ Error al actualizar stock del lote: {e}")
            return False
    
    def eliminar(self, idlote: int) -> bool:
        """Elimina un lote"""
        try:
            self.cursor.execute("DELETE FROM lote WHERE idlote = ?", (idlote,))
            self.cursor.commit()
            logger.success(f"✅ Lote ID {idlote} eliminado")
            return True
        except Exception as e:
            logger.error(f"❌ Error al eliminar lote: {e}")
            return False
    
    def lotes_proximos_vencer(self, dias: int = 30) -> List[Dict]:
        """Lista los lotes que vencen en los próximos 'dias' días"""
        try:
            from datetime import datetime, timedelta
            fecha_limite = datetime.now() + timedelta(days=dias)
            
            self.cursor.execute("""
                SELECT l.idlote, l.codigo_lote, l.fecha_vencimiento, 
                       l.stock_actual, a.nombre as articulo, a.codigo
                FROM lote l
                INNER JOIN articulo a ON l.idarticulo = a.idarticulo
                WHERE l.fecha_vencimiento <= ? 
                  AND l.fecha_vencimiento >= GETDATE()
                  AND l.stock_actual > 0
                ORDER BY l.fecha_vencimiento ASC
            """, (fecha_limite,))
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} lotes próximos a vencer")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar lotes próximos a vencer: {e}")
            return []
    
    def lotes_vencidos(self) -> List[Dict]:
        """Lista los lotes ya vencidos"""
        try:
            self.cursor.execute("""
                SELECT l.idlote, l.codigo_lote, l.fecha_vencimiento, 
                       l.stock_actual, a.nombre as articulo, a.codigo
                FROM lote l
                INNER JOIN articulo a ON l.idarticulo = a.idarticulo
                WHERE l.fecha_vencimiento < GETDATE()
                  AND l.stock_actual > 0
                ORDER BY l.fecha_vencimiento ASC
            """)
            columnas = [column[0] for column in self.cursor.description]
            resultados = []
            for row in self.cursor.fetchall():
                resultados.append(dict(zip(columnas, row)))
            logger.info(f"✅ {len(resultados)} lotes vencidos")
            return resultados
        except Exception as e:
            logger.error(f"❌ Error al listar lotes vencidos: {e}")
            return []
----- capa_negocio/articulo_service.py -----
"""
Servicio para la gestión de artículos
"""
from loguru import logger
from capa_negocio.base_service import BaseService

class ArticuloService(BaseService):
    """Servicio que implementa la lógica de negocio para artículos"""
    
    def __init__(self, repositorio, categoria_service):
        """
        Inicializa el servicio de artículos
        
        Args:
            repositorio: Instancia de ArticuloRepositorio
            categoria_service: Servicio de categorías
        """
        super().__init__()
        self.repositorio = repositorio
        self.categoria_service = categoria_service
        logger.info("✅ ArticuloService inicializado")
    
    def listar(self):
        """
        Lista todos los artículos
        
        Returns:
            list: Lista de artículos o lista vacía si hay error
        """
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"Error al listar artículos: {e}")
            return []
    
    def obtener_por_id(self, idarticulo):
        """
        Obtiene un artículo por su ID
        
        Args:
            idarticulo (int): ID del artículo
            
        Returns:
            dict: Datos del artículo o None si no existe
        """
        try:
            if not self.validar_entero_positivo(idarticulo, "ID del artículo"):
                return None
            return self.repositorio.obtener_por_id(idarticulo)
        except Exception as e:
            logger.error(f"Error al obtener artículo {idarticulo}: {e}")
            return None
    
    def buscar_por_codigo(self, codigo):
        """
        Busca un artículo por su código
        
        Args:
            codigo (str): Código del artículo
            
        Returns:
            dict: Datos del artículo o None si no existe
        """
        try:
            return self.repositorio.buscar_por_codigo(codigo)
        except Exception as e:
            logger.error(f"Error al buscar artículo por código {codigo}: {e}")
            return None
    
    def crear(self, codigo, nombre, idcategoria, idpresentacion, descripcion=None, 
              precio_venta=0, precio_referencia=None):
        """
        Crea un nuevo artículo con precio de venta
        
        Args:
            codigo (str): Código del artículo
            nombre (str): Nombre del artículo
            idcategoria (int): ID de la categoría
            idpresentacion (int): ID de la presentación
            descripcion (str, optional): Descripción
            precio_venta (float): Precio de venta en USD
            precio_referencia (float, optional): Precio de referencia (costo)
            
        Returns:
            bool: True si se creó correctamente, False en caso contrario
        """
        try:
            # Validaciones
            if not codigo or not codigo.strip():
                logger.error("El código del artículo es obligatorio")
                return False
            
            if not nombre or not nombre.strip():
                logger.error("El nombre del artículo es obligatorio")
                return False
            
            if not self.validar_entero_positivo(idcategoria, "ID de categoría"):
                return False
            
            if not self.validar_entero_positivo(idpresentacion, "ID de presentación"):
                return False
            
            # Verificar si ya existe un artículo con el mismo código
            existente = self.repositorio.buscar_por_codigo(codigo)
            if existente:
                logger.error(f"Ya existe un artículo con el código {codigo}")
                return False
            
            # Validar precio de venta (puede ser 0)
            if not isinstance(precio_venta, (int, float)) or precio_venta < 0:
                logger.error("El precio de venta debe ser un número positivo")
                return False
            
            # Validar precio de referencia (puede ser None)
            if precio_referencia is not None:
                if not isinstance(precio_referencia, (int, float)) or precio_referencia < 0:
                    logger.error("El precio de referencia debe ser un número positivo o None")
                    return False
            
            # Crear artículo
            resultado = self.repositorio.crear(
                codigo=codigo.strip(),
                nombre=nombre.strip(),
                idcategoria=idcategoria,
                idpresentacion=idpresentacion,
                descripcion=descripcion.strip() if descripcion else None,
                precio_venta=precio_venta,
                precio_referencia=precio_referencia
            )
            
            if resultado:
                logger.info(f"✅ Artículo creado: {nombre} - Precio: ${precio_venta}")
                return True
            else:
                logger.error("No se pudo crear el artículo")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error al crear artículo: {e}")
            return False
    
    def actualizar(self, idarticulo, codigo, nombre, idcategoria, idpresentacion, 
                   descripcion=None, precio_venta=None, precio_referencia=None):
        """
        Actualiza un artículo existente incluyendo precios
        
        Args:
            idarticulo (int): ID del artículo
            codigo (str): Código del artículo
            nombre (str): Nombre del artículo
            idcategoria (int): ID de la categoría
            idpresentacion (int): ID de la presentación
            descripcion (str, optional): Descripción
            precio_venta (float, optional): Precio de venta en USD
            precio_referencia (float, optional): Precio de referencia (costo)
            
        Returns:
            bool: True si se actualizó correctamente, False en caso contrario
        """
        try:
            # Validar que el artículo existe
            articulo = self.obtener_por_id(idarticulo)
            if not articulo:
                logger.error(f"Artículo {idarticulo} no encontrado")
                return False
            
            # Validaciones básicas
            if not codigo or not codigo.strip():
                logger.error("El código del artículo es obligatorio")
                return False
            
            if not nombre or not nombre.strip():
                logger.error("El nombre del artículo es obligatorio")
                return False
            
            if not self.validar_entero_positivo(idcategoria, "ID de categoría"):
                return False
            
            if not self.validar_entero_positivo(idpresentacion, "ID de presentación"):
                return False
            
            # Validar precio_venta (FORZAR A FLOAT)
            if precio_venta is not None:
                try:
                    precio_venta = float(precio_venta)
                except (ValueError, TypeError):
                    logger.error("El precio de venta debe ser un número válido")
                    return False
                    
                if precio_venta < 0:
                    logger.error("El precio de venta no puede ser negativo")
                    return False
            else:
                # Si no viene, mantener el actual
                precio_venta = float(articulo.get('precio_venta', 0))
            
            # Validar precio_referencia (puede ser None)
            if precio_referencia is not None:
                try:
                    precio_referencia = float(precio_referencia)
                except (ValueError, TypeError):
                    logger.error("El precio de referencia debe ser un número válido")
                    return False
                    
                if precio_referencia < 0:
                    logger.error("El precio de referencia no puede ser negativo")
                    return False
            # Si es None, es válido (no se actualizará en BD)
            
            # Verificar si el código ya existe en otro artículo
            existente = self.repositorio.buscar_por_codigo(codigo)
            if existente and existente['idarticulo'] != idarticulo:
                logger.error(f"Ya existe otro artículo con el código {codigo}")
                return False
            
            # Actualizar artículo
            resultado = self.repositorio.actualizar(
                idarticulo=idarticulo,
                codigo=codigo.strip(),
                nombre=nombre.strip(),
                idcategoria=idcategoria,
                idpresentacion=idpresentacion,
                descripcion=descripcion.strip() if descripcion else None,
                precio_venta=precio_venta,
                precio_referencia=precio_referencia
            )
            
            if resultado:
                logger.info(f"✅ Artículo {idarticulo} actualizado - Precio: ${precio_venta}")
                return True
            else:
                logger.error(f"No se pudo actualizar el artículo {idarticulo}")
                return False
                
        except Exception as e:
            logger.error(f"❌ Error al actualizar artículo {idarticulo}: {e}")
            return False
    
    def eliminar(self, idarticulo):
        """
        Elimina un artículo (verifica si tiene movimientos asociados)
        
        Args:
            idarticulo (int): ID del artículo a eliminar
            
        Returns:
            bool: True si se eliminó correctamente, False en caso contrario
        """
        try:
            if not self.validar_entero_positivo(idarticulo, "ID del artículo"):
                return False
            
            # Verificar que el artículo existe
            articulo = self.obtener_por_id(idarticulo)
            if not articulo:
                logger.error(f"Artículo {idarticulo} no encontrado")
                return False
            
            resultado = self.repositorio.eliminar(idarticulo)
            
            if resultado:
                logger.info(f"✅ Artículo {idarticulo} eliminado correctamente")
                return True
            else:
                logger.error(f"No se pudo eliminar el artículo {idarticulo}")
                return False
                
        except Exception as e:
            logger.error(f"Error al eliminar artículo {idarticulo}: {e}")
            return False
    
    def buscar_por_codigo_barras(self, codigo):
        """
        Busca artículo por código de barras
        
        Args:
            codigo (str): Código de barras
            
        Returns:
            dict: Datos del artículo o None si no existe
        """
        try:
            return self.repositorio.buscar_por_codigo_barras(codigo)
        except Exception as e:
            logger.error(f"Error buscando por código de barras {codigo}: {e}")
            return None
    
    def buscar_por_plu(self, plu):
        """
        Busca artículo por código interno PLU
        
        Args:
            plu (str): Código PLU
            
        Returns:
            dict: Datos del artículo o None si no existe
        """
        try:
            return self.repositorio.buscar_por_plu(plu)
        except Exception as e:
            logger.error(f"Error buscando por PLU {plu}: {e}")
            return None
    
    def buscar_por_nombre(self, termino):
        """
        Busca artículos por nombre (búsqueda parcial)
        
        Args:
            termino (str): Término de búsqueda
            
        Returns:
            list: Lista de artículos que coinciden
        """
        try:
            return self.repositorio.buscar_por_nombre(termino)
        except Exception as e:
            logger.error(f"Error buscando por nombre {termino}: {e}")
            return []
----- capa_negocio/rol_service.py -----
from typing import List, Dict, Optional, Set
from loguru import logger
from capa_negocio.base_service import BaseService

class PermisoDenegadoError(Exception):
    """Excepción para cuando un usuario no tiene permiso"""
    pass

class RolService(BaseService):
    """Servicio para gestión de roles y permisos"""
    
    def __init__(self, repositorio):
        self.repositorio = repositorio
        self.permisos_usuario_actual: Set[str] = set()
    
    def cargar_permisos_usuario(self, idrol: int):
        """Carga los permisos del rol del usuario actual"""
        if idrol:
            self.permisos_usuario_actual = set(self.repositorio.obtener_permisos_rol(idrol))
            logger.info(f"✅ Permisos cargados para rol {idrol}: {len(self.permisos_usuario_actual)} permisos")
        else:
            self.permisos_usuario_actual = set()
    
    def tiene_permiso(self, permiso: str) -> bool:
        """Verifica si el usuario actual tiene un permiso específico"""
        return permiso in self.permisos_usuario_actual
    
    def verificar_permiso(self, permiso: str):
        """Verifica permiso o lanza excepción"""
        if not self.tiene_permiso(permiso):
            logger.warning(f"⚠️ Permiso denegado: {permiso}")
            raise PermisoDenegadoError(f"No tiene permiso para: {permiso}")
    
    def listar_roles(self) -> List[Dict]:
        """Lista roles disponibles"""
        return self.repositorio.listar_roles()
    
    def obtener_rol(self, idrol: int) -> Optional[Dict]:
        """Obtiene un rol por su ID"""
        try:
            return self.repositorio.obtener_rol(idrol)
        except Exception as e:
            logger.error(f"❌ Error al obtener rol {idrol}: {e}")
            return None
    
    def listar_permisos_por_modulo(self) -> Dict[str, List[Dict]]:
        """Lista permisos agrupados por módulo"""
        todos = self.repositorio.listar_permisos()
        por_modulo = {}
        for permiso in todos:
            modulo = permiso['modulo']
            if modulo not in por_modulo:
                por_modulo[modulo] = []
            por_modulo[modulo].append(permiso)
        return por_modulo
    
    def obtener_permisos_rol(self, idrol: int) -> List[str]:
        """Obtiene permisos de un rol"""
        return self.repositorio.obtener_permisos_rol(idrol)
    
    def asignar_permisos_rol(self, idrol: int, permisos: List[int]) -> bool:
        """Asigna permisos a un rol (requiere permiso de administrador)"""
        self.verificar_permiso('usuarios_asignar_roles')
        return self.repositorio.asignar_permisos_rol(idrol, permisos)
    
    def asignar_rol_trabajador(self, idtrabajador: int, idrol: int) -> bool:
        """Asigna rol a trabajador (requiere permiso de administrador)"""
        self.verificar_permiso('usuarios_editar')
        return self.repositorio.asignar_rol_trabajador(idtrabajador, idrol)
    
    def crear_rol(self, nombre: str, descripcion: str = None, nivel: int = 1) -> Optional[int]:
        """Crea un nuevo rol (requiere permiso de administrador)"""
        self.verificar_permiso('usuarios_crear')
        return self.repositorio.crear_rol(nombre, descripcion, nivel)
    
    def get_permisos_usuario(self) -> Set[str]:
        """Retorna los permisos del usuario actual"""
        return self.permisos_usuario_actual
----- capa_negocio/tasa_service.py -----
"""
Servicio para gestión de tasas de cambio - VERSIÓN MANUAL (ESCALABLE)
"""
from datetime import datetime, date
from loguru import logger
from capa_negocio.base_service import BaseService

class TasaService(BaseService):
    """Servicio para manejar tasas de cambio (dólar, euro)"""
    
    MONEDAS_SOPORTADAS = ['USD', 'EUR']
    
    # Colores para la consola
    COLOR_AMARILLO = '\033[93m'
    COLOR_VERDE = '\033[92m'
    COLOR_ROJO = '\033[91m'
    COLOR_RESET = '\033[0m'
    
    def __init__(self, repositorio_tasa):
        """
        Inicializa el servicio de tasas
        
        Args:
            repositorio_tasa: Repositorio para acceso a BD
        """
        super().__init__()
        self.repo = repositorio_tasa
        self.modo_automatico = False  # Por ahora manual
        logger.info("✅ TasaService inicializado en modo MANUAL")
    
    def obtener_tasa_del_dia(self, moneda='USD'):
        """
        Obtiene la última tasa registrada para una moneda
        
        Args:
            moneda: USD, EUR
            
        Returns:
            float: Tasa de cambio o None si no existe
        """
        try:
            tasa = self.repo.obtener_ultima_tasa(moneda)
            if tasa:
                logger.info(f"💱 Tasa {moneda}: {tasa:.2f} (de BD)")
                return tasa
            else:
                logger.warning(f"No hay tasa registrada para {moneda}")
                return None
        except Exception as e:
            logger.error(f"Error obteniendo tasa: {e}")
            return None
    
    def registrar_tasa_manual(self, moneda, tasa, usuario):
        """
        Registra una tasa ingresada manualmente por el usuario
        
        Args:
            moneda: USD, EUR
            tasa: Valor de la tasa
            usuario: Nombre del usuario que registra
            
        Returns:
            bool: True si se registró correctamente
        """
        try:
            if not self.validar_decimal_positivo(tasa, "Tasa"):
                return False
            
            if moneda not in self.MONEDAS_SOPORTADAS:
                logger.error(f"Moneda no soportada: {moneda}")
                return False
            
            # Fuente manual tiene ID 1
            idfuente = 1
            
            resultado = self.repo.insertar_tasa(
                idfuente=idfuente,
                moneda_origen=moneda,
                tasa=tasa,
                usuario=usuario,
                observaciones="Ingreso manual"
            )
            
            if resultado:
                logger.info(f"✅ Tasa {moneda} registrada: {tasa:.2f} por {usuario}")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error registrando tasa manual: {e}")
            return False
    
    def obtener_tasa_para_venta(self, moneda='USD', usuario=None):
        """
        Obtiene la tasa actual, solicitando al usuario si es necesario
        
        Args:
            moneda: USD, EUR
            usuario: Usuario actual (para registro)
            
        Returns:
            float: Tasa a usar o None si se cancela
        """
        # Modo MANUAL: preguntar siempre
        print(f"\n{self.COLOR_AMARILLO}💱 CONFIGURACIÓN DE TASA DE CAMBIO{self.COLOR_RESET}")
        print("=" * 50)
        
        # Intentar obtener última tasa como referencia
        tasa_anterior = self.obtener_tasa_del_dia(moneda)
        if tasa_anterior:
            print(f"📊 Última tasa registrada: 1 {moneda} = {tasa_anterior:.2f} VES")
            print(f"   Fecha: {date.today().strftime('%d/%m/%Y')}")
        else:
            print(f"📊 No hay tasa previa registrada para {moneda}")
        
        print("\nIngrese la tasa de cambio del día de HOY:")
        
        while True:
            try:
                tasa_input = input(f"💵 1 {moneda} = Bs. ").strip()
                if not tasa_input:
                    print(f"{self.COLOR_ROJO}❌ Operación cancelada{self.COLOR_RESET}")
                    return None
                
                tasa = float(tasa_input.replace(',', '.'))
                if tasa <= 0:
                    print(f"{self.COLOR_ROJO}❌ La tasa debe ser positiva{self.COLOR_RESET}")
                    continue
                
                # Confirmar
                print(f"\n✅ Tasa ingresada: 1 {moneda} = {tasa:.2f} VES")
                confirmar = input(f"{self.COLOR_AMARILLO}¿Confirmar? (s/N): {self.COLOR_RESET}").lower()
                
                if confirmar == 's':
                    # Registrar en BD
                    if usuario:
                        self.registrar_tasa_manual(moneda, tasa, usuario)
                    return tasa
                else:
                    print("Por favor, ingrese la tasa correcta:")
                    
            except ValueError:
                print(f"{self.COLOR_ROJO}❌ Ingrese un número válido (ej: 60.50){self.COLOR_RESET}")
    
    def mostrar_historial(self, moneda='USD', dias=7):
        """
        Muestra el historial reciente de tasas
        
        Args:
            moneda: USD, EUR
            dias: Número de días a mostrar
        """
        historial = self.repo.obtener_historial(moneda, dias)
        
        if not historial:
            print(f"📭 No hay historial para {moneda}")
            return
        
        print(f"\n📊 HISTORIAL DE TASAS {moneda} (últimos {dias} días)")
        print("-" * 60)
        print(f"{'FECHA':<12} {'TASA':<10} {'FUENTE':<15} {'USUARIO':<15}")
        print("-" * 60)
        
        for h in historial:
            fecha = h['fecha'].strftime('%d/%m/%Y') if hasattr(h['fecha'], 'strftime') else h['fecha']
            print(f"{fecha:<12} {h['tasa']:<10.2f} {h['fuente']:<15} {h['usuario_registro'] or '':<15}")
    
    # ========== MÉTODOS PARA FUTURAS MEJORAS AUTOMÁTICAS ==========
    
    def activar_modo_automatico(self):
        """Activa el modo automático (para futuro)"""
        self.modo_automatico = True
        logger.info("🤖 Modo automático activado")
    
    def consultar_api_bcv(self):
        """
        MÉTODO PARA FUTURO: Consulta API del BCV
        """
        # Aquí irá la lógica para consultar APIs
        pass
----- capa_negocio/trabajador_service.py -----
from typing import List, Dict, Optional
from datetime import date
from loguru import logger
from capa_negocio.base_service import BaseService

class TrabajadorService(BaseService):
    """Servicio de trabajadores con autenticación y roles"""
    
    def __init__(self, repositorio):
        self.repositorio = repositorio
        self.usuario_actual = None
        self.rol_service = None  # Se asignará desde el menú principal
    
    def listar(self) -> List[Dict]:
        """Lista todos los trabajadores"""
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"❌ Error al listar trabajadores: {e}")
            return []
    
    def obtener_por_id(self, idtrabajador: int) -> Optional[Dict]:
        """Obtiene un trabajador por ID"""
        if not self.validar_entero_positivo(idtrabajador, "ID de trabajador"):
            return None
        return self.repositorio.obtener_por_id(idtrabajador)
    
    def login(self, usuario: str, password: str) -> bool:
        """Autentica un trabajador por usuario y contraseña (compatibilidad)"""
        if not usuario or not password:
            logger.warning("⚠️ Usuario y contraseña requeridos")
            return False
        
        trabajador = self.repositorio.autenticar(usuario, password)
        if trabajador:
            # Obtener rol del trabajador
            trabajador_completo = self.repositorio.obtener_por_id(trabajador['idtrabajador'])
            trabajador['idrol'] = trabajador_completo.get('idrol')
            
            self.usuario_actual = trabajador
            logger.success(f"✅ Bienvenido {trabajador['nombre']} {trabajador['apellidos']}")
            
            # Cargar permisos si hay servicio de roles disponible
            if self.rol_service and trabajador['idrol']:
                self.rol_service.cargar_permisos_usuario(trabajador['idrol'])
                permisos = len(self.rol_service.get_permisos_usuario())
                logger.info(f"🔑 Permisos cargados: {permisos} permisos")
            
            return True
        else:
            logger.warning("❌ Usuario o contraseña incorrectos")
            return False
    
    def login_por_email(self, email: str, password: str) -> bool:
        """Autentica un trabajador por email y contraseña"""
        if not email or not password:
            logger.warning("⚠️ Email y contraseña requeridos")
            return False
        
        trabajador = self.repositorio.autenticar_por_email(email, password)
        if trabajador:
            # Obtener rol del trabajador
            trabajador_completo = self.repositorio.obtener_por_id(trabajador['idtrabajador'])
            trabajador['idrol'] = trabajador_completo.get('idrol')
            
            self.usuario_actual = trabajador
            logger.success(f"✅ Bienvenido {trabajador['nombre']} {trabajador['apellidos']}")
            
            # Cargar permisos si hay servicio de roles disponible
            if self.rol_service and trabajador['idrol']:
                self.rol_service.cargar_permisos_usuario(trabajador['idrol'])
                permisos = len(self.rol_service.get_permisos_usuario())
                logger.info(f"🔑 Permisos cargados: {permisos} permisos")
            
            return True
        else:
            logger.warning("❌ Email o contraseña incorrectos")
            return False
    
    def buscar_por_email(self, email: str) -> Optional[Dict]:
        """Busca un trabajador por su email"""
        return self.repositorio.buscar_por_email(email)
    
    def logout(self):
        """Cierra sesión del trabajador actual"""
        if self.usuario_actual:
            logger.info(f"👋 Hasta luego {self.usuario_actual['nombre']}")
            self.usuario_actual = None
            if self.rol_service:
                self.rol_service.permisos_usuario_actual = set()
    
    def get_usuario_actual(self) -> Optional[Dict]:
        """Retorna el trabajador autenticado"""
        return self.usuario_actual
    
    def crear(self, nombre: str, apellidos: str, sexo: str,
              fecha_nacimiento, num_documento: str,
              usuario: str, password: str,
              direccion: str = None, telefono: str = None,
              email: str = None) -> bool:
        """Crea un nuevo trabajador con validaciones"""
        
        # Validaciones
        if not self.validar_requerido(nombre, "nombre"):
            return False
        if not self.validar_requerido(apellidos, "apellidos"):
            return False
        if not self.validar_requerido(sexo, "sexo"):
            return False
        if not self.validar_requerido(num_documento, "documento"):
            return False
        if not self.validar_requerido(usuario, "usuario"):
            return False
        if not self.validar_requerido(password, "contraseña"):
            return False
        
        # Validaciones específicas
        if sexo not in ['M', 'F', 'O']:
            logger.warning("⚠️ Sexo debe ser M, F u O")
            return False
        
        if len(password) < 6:
            logger.warning("⚠️ La contraseña debe tener al menos 6 caracteres")
            return False
        
        if email and not self.validar_email(email):
            return False
        
        if telefono and not self.validar_telefono(telefono):
            return False
        
        # Validar mayoría de edad
        if isinstance(fecha_nacimiento, str):
            fecha_nacimiento = date.fromisoformat(fecha_nacimiento)
        
        hoy = date.today()
        edad = hoy.year - fecha_nacimiento.year - ((hoy.month, hoy.day) < (fecha_nacimiento.month, fecha_nacimiento.day))
        
        if edad < 18:
            logger.warning("⚠️ El trabajador debe ser mayor de edad")
            return False
        
        try:
            return self.repositorio.insertar(
                nombre.strip(), apellidos.strip(), sexo, fecha_nacimiento,
                num_documento, usuario, password, direccion, telefono, email
            )
        except Exception as e:
            logger.error(f"❌ Error al crear trabajador: {e}")
            return False
    
    def actualizar(self, idtrabajador: int, nombre: str, apellidos: str, sexo: str,
                   fecha_nacimiento, num_documento: str, usuario: str,
                   password: str = None, direccion: str = None,
                   telefono: str = None, email: str = None) -> bool:
        """Actualiza un trabajador existente"""
        
        if not self.validar_entero_positivo(idtrabajador, "ID de trabajador"):
            return False
        
        # Validaciones
        if not self.validar_requerido(nombre, "nombre"):
            return False
        if not self.validar_requerido(apellidos, "apellidos"):
            return False
        if not self.validar_requerido(sexo, "sexo"):
            return False
        if not self.validar_requerido(num_documento, "documento"):
            return False
        if not self.validar_requerido(usuario, "usuario"):
            return False
        
        if sexo not in ['M', 'F', 'O']:
            logger.warning("⚠️ Sexo debe ser M, F u O")
            return False
        
        if password and len(password) < 6:
            logger.warning("⚠️ La contraseña debe tener al menos 6 caracteres")
            return False
        
        if email and not self.validar_email(email):
            return False
        
        if telefono and not self.validar_telefono(telefono):
            return False
        
        try:
            return self.repositorio.actualizar(
                idtrabajador, nombre.strip(), apellidos.strip(), sexo, fecha_nacimiento,
                num_documento, usuario, password, direccion, telefono, email
            )
        except Exception as e:
            logger.error(f"❌ Error al actualizar trabajador: {e}")
            return False
    
    def eliminar(self, idtrabajador: int) -> bool:
        """Elimina un trabajador"""
        if not self.validar_entero_positivo(idtrabajador, "ID de trabajador"):
            return False
        return self.repositorio.eliminar(idtrabajador)
    
    def actualizar_password(self, email, nueva_password):
        """Actualiza la contraseña de un trabajador"""
        try:
            import hashlib
            password_hash = hashlib.sha256(nueva_password.encode()).hexdigest()
            cursor = self.repositorio.cursor
            cursor.execute("UPDATE trabajador SET password_hash = ? WHERE email = ?", 
                          (password_hash, email))
            cursor.commit()
            logger.success(f"✅ Contraseña actualizada para email: {email}")
            return True
        except Exception as e:
            logger.error(f"❌ Error al actualizar password: {e}")
            return False

----- capa_negocio/categoria_service.py -----

from typing import List, Dict, Optional
from loguru import logger
from capa_negocio.base_service import BaseService

class CategoriaService(BaseService):
    """Servicio de categorías con validaciones y lógica de negocio"""
    
    def __init__(self, repositorio):
        self.repositorio = repositorio
        self.nombre_campo = "Categoría"
    
    def listar(self) -> List[Dict]:
        """Lista todas las categorías"""
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"❌ Error al listar categorías: {e}")
            return []
    
    def obtener_por_id(self, idcategoria: int) -> Optional[Dict]:
        """Obtiene una categoría por ID con validación"""
        if not self.validar_entero_positivo(idcategoria, "ID de categoría"):
            return None
        
        try:
            return self.repositorio.obtener_por_id(idcategoria)
        except Exception as e:
            logger.error(f"❌ Error al obtener categoría {idcategoria}: {e}")
            return None
    
    def crear(self, nombre: str, descripcion: str = None) -> bool:
        """Crea una nueva categoría con validaciones"""
        # Validaciones
        if not self.validar_requerido(nombre, "nombre"):
            return False
        
        if not self.validar_longitud(nombre, "nombre", max_len=50):
            return False
        
        if descripcion and not self.validar_longitud(descripcion, "descripción", max_len=256):
            return False
        
        try:
            return self.repositorio.insertar(nombre.strip(), descripcion)
        except Exception as e:
            logger.error(f"❌ Error al crear categoría: {e}")
            return False
    
    def actualizar(self, idcategoria: int, nombre: str, descripcion: str = None) -> bool:
        """Actualiza una categoría con validaciones"""
        if not self.validar_entero_positivo(idcategoria, "ID de categoría"):
            return False
        
        if not self.validar_requerido(nombre, "nombre"):
            return False
        
        if not self.validar_longitud(nombre, "nombre", max_len=50):
            return False
        
        if descripcion and not self.validar_longitud(descripcion, "descripción", max_len=256):
            return False
        
        try:
            return self.repositorio.actualizar(idcategoria, nombre.strip(), descripcion)
        except Exception as e:
            logger.error(f"❌ Error al actualizar categoría: {e}")
            return False
    
    def eliminar(self, idcategoria: int) -> bool:
        """Elimina una categoría con validación"""
        if not self.validar_entero_positivo(idcategoria, "ID de categoría"):
            return False
        
        try:
            return self.repositorio.eliminar(idcategoria)
        except Exception as e:
            logger.error(f"❌ Error al eliminar categoría: {e}")
            return False



----- capa_negocio/proveedor_archivo_service.py -----
from typing import List, Dict, Optional
import os
from datetime import datetime
from loguru import logger
from capa_negocio.base_service import BaseService

class ProveedorArchivoService(BaseService):
    """Servicio para gestión de archivos de proveedores"""
    
    # Extensiones permitidas
    EXTENSIONES_PERMITIDAS = {
        '.jpg': 'image/jpeg',
        '.jpeg': 'image/jpeg',
        '.png': 'image/png',
        '.gif': 'image/gif',
        '.pdf': 'application/pdf',
        '.xls': 'application/vnd.ms-excel',
        '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        '.csv': 'text/csv',
        '.txt': 'text/plain',
        '.doc': 'application/msword',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    }
    
    TAMANO_MAXIMO = 10 * 1024 * 1024  # 10 MB
    
    def __init__(self, repositorio, proveedor_service=None):
        self.repositorio = repositorio
        self.proveedor_service = proveedor_service
    
    def listar_archivos_proveedor(self, idproveedor: int) -> List[Dict]:
        """Lista los archivos de un proveedor"""
        if not self.validar_entero_positivo(idproveedor, "ID de proveedor"):
            return []
        return self.repositorio.listar_por_proveedor(idproveedor)
    
    def obtener_archivo(self, idarchivo: int) -> Optional[Dict]:
        """Obtiene un archivo completo por su ID"""
        if not self.validar_entero_positivo(idarchivo, "ID de archivo"):
            return None
        return self.repositorio.obtener_archivo(idarchivo)
    
    def validar_archivo(self, nombre_archivo: str, contenido: bytes) -> bool:
        """Valida que el archivo sea válido (extensión y tamaño)"""
        if len(contenido) > self.TAMANO_MAXIMO:
            logger.warning(f"⚠️ Archivo demasiado grande: {len(contenido)} bytes")
            return False
        
        extension = os.path.splitext(nombre_archivo)[1].lower()
        if extension not in self.EXTENSIONES_PERMITIDAS:
            logger.warning(f"⚠️ Extensión '{extension}' no permitida")
            return False
        
        return True
    
    def subir_archivo(self, idproveedor: int, ruta_archivo: str, 
                      descripcion: str = None) -> Optional[int]:
        """Sube un archivo desde el sistema de archivos local"""
        
        if not self.validar_entero_positivo(idproveedor, "ID de proveedor"):
            return None
        
        if not os.path.exists(ruta_archivo):
            logger.warning(f"⚠️ El archivo '{ruta_archivo}' no existe")
            return None
        
        try:
            with open(ruta_archivo, 'rb') as f:
                contenido = f.read()
            
            nombre_archivo = os.path.basename(ruta_archivo)
            
            if not self.validar_archivo(nombre_archivo, contenido):
                return None
            
            extension = os.path.splitext(nombre_archivo)[1].lower()
            tipo_archivo = self.EXTENSIONES_PERMITIDAS.get(extension, 'application/octet-stream')
            
            return self.repositorio.insertar(
                idproveedor, nombre_archivo, tipo_archivo, contenido, descripcion
            )
        except Exception as e:
            logger.error(f"❌ Error al subir archivo: {e}")
            return None
    
    def guardar_archivo(self, idarchivo: int, ruta_destino: str) -> bool:
        """Guarda un archivo de la BD al sistema de archivos local"""
        if not self.validar_entero_positivo(idarchivo, "ID de archivo"):
            return False
        
        archivo = self.obtener_archivo(idarchivo)
        if not archivo:
            return False
        
        try:
            directorio = os.path.dirname(ruta_destino)
            if directorio and not os.path.exists(directorio):
                os.makedirs(directorio)
            
            with open(ruta_destino, 'wb') as f:
                f.write(archivo['contenido'])
            
            logger.success(f"✅ Archivo guardado en '{ruta_destino}'")
            return True
        except Exception as e:
            logger.error(f"❌ Error al guardar archivo: {e}")
            return False
    
    def eliminar_archivo(self, idarchivo: int) -> bool:
        """Elimina un archivo de la BD"""
        if not self.validar_entero_positivo(idarchivo, "ID de archivo"):
            return False
        return self.repositorio.eliminar(idarchivo)
    
    def obtener_tamano_legible(self, tamano_bytes: int) -> str:
        """Convierte tamaño de bytes a formato legible"""
        if tamano_bytes < 1024:
            return f"{tamano_bytes} B"
        elif tamano_bytes < 1024 * 1024:
            return f"{tamano_bytes / 1024:.1f} KB"
        else:
            return f"{tamano_bytes / (1024 * 1024):.1f} MB"
----- capa_negocio/venta_service.py -----
"""
Servicio para la gestión de ventas - VERSIÓN CON MULTIMONEDA Y TASAS DE CAMBIO
"""
from loguru import logger
from capa_negocio.base_service import BaseService
from capa_negocio.moneda_service import IGTFService
from capa_negocio.tasa_service import TasaService

class VentaService(BaseService):
    """Servicio que implementa la lógica de negocio para ventas con soporte multimoneda"""
    
    def __init__(self, repositorio, cliente_service, trabajador_service, inventario_service, tasa_repo=None):
        """
        Inicializa el servicio de ventas
        
        Args:
            repositorio: Instancia de VentaRepositorio
            cliente_service: Servicio de clientes
            trabajador_service: Servicio de trabajadores
            inventario_service: Servicio de inventario
            tasa_repo: Repositorio de tasas (opcional, para multimoneda)
        """
        super().__init__()
        self.repositorio = repositorio
        self.cliente_service = cliente_service
        self.trabajador_service = trabajador_service
        self.inventario_service = inventario_service
        
        # Inicializar servicio de tasas si se proporciona el repositorio
        if tasa_repo:
            self.tasa_service = TasaService(tasa_repo)
            logger.info("✅ Servicio de tasas inicializado")
        else:
            self.tasa_service = None
            logger.warning("⚠️ Servicio de tasas no disponible - solo moneda VES")
        
        logger.info("✅ VentaService inicializado")
    
    def listar(self):
        """
        Lista todas las ventas
        
        Returns:
            list: Lista de ventas o lista vacía si hay error
        """
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"Error al listar ventas: {e}")
            return []
    
    def obtener_por_id(self, idventa):
        """
        Obtiene una venta por su ID con todos los detalles
        
        Args:
            idventa (int): ID de la venta
            
        Returns:
            dict: Datos de la venta o None si no existe
        """
        try:
            if not self.validar_entero_positivo(idventa, "ID de venta"):
                return None
            
            venta = self.repositorio.obtener_por_id(idventa)
            if not venta:
                logger.warning(f"Venta {idventa} no encontrada")
                return None
            
            detalles = self.repositorio.obtener_detalles(idventa)
            venta['detalle'] = detalles
            return venta
            
        except Exception as e:
            logger.error(f"Error al obtener venta {idventa}: {e}")
            return None
    
    def registrar(self, idtrabajador, idcliente, tipo_comprobante, 
                  serie, numero_comprobante, igv, detalle,
                  moneda='VES', moneda_pago=None, tasa_cambio=None):
        """
        Registra una nueva venta con soporte multimoneda
        
        Args:
            idtrabajador (int): ID del trabajador que realiza la venta
            idcliente (int or None): ID del cliente (puede ser None para consumidor final)
            tipo_comprobante (str): FACTURA, BOLETA, TICKET
            serie (str): Serie del comprobante
            numero_comprobante (str): Número del comprobante
            igv (float): Porcentaje de IGV
            detalle (list): Lista de items de la venta
            moneda (str): Moneda de la factura (VES, USD, EUR)
            moneda_pago (str): Moneda con que paga el cliente (si es diferente)
            tasa_cambio (float): Tasa de cambio (si viene, se usa; si no, se pide)
            
        Returns:
            int or None: ID de la venta creada o None si hay error
        """
        try:
            # Validar campos obligatorios
            if not self.validar_entero_positivo(idtrabajador, "ID del trabajador"):
                logger.error("ID del trabajador inválido")
                return None
            
            # Para consumidor final, idcliente puede ser None
            if idcliente is not None:
                if not self.validar_entero_positivo(idcliente, "ID del cliente"):
                    return None
                
                # Verificar que el cliente existe
                cliente = self.cliente_service.obtener_por_id(idcliente)
                if not cliente:
                    logger.error(f"Cliente {idcliente} no encontrado")
                    return None
            
            # Validar tipo de comprobante
            tipos_validos = ['FACTURA', 'BOLETA', 'TICKET']
            if tipo_comprobante not in tipos_validos:
                logger.error(f"Tipo de comprobante inválido: {tipo_comprobante}")
                return None
            
            # Validar serie y número
            if not serie or not serie.strip():
                logger.error("La serie del comprobante es obligatoria")
                return None
            
            if not numero_comprobante or not numero_comprobante.strip():
                logger.error("El número del comprobante es obligatorio")
                return None
            
            # Validar IGV
            if not self.validar_decimal_positivo(igv, "IGV"):
                return None
            
            # Validar detalle
            if not detalle or len(detalle) == 0:
                logger.error("La venta debe tener al menos un producto")
                return None
            
            # ===== GESTIÓN DE TASA DE CAMBIO =====
            tasa_final = tasa_cambio
            usuario_nombre = None
            
            # Obtener nombre del usuario para registro
            usuario_actual = self.trabajador_service.get_usuario_actual()
            if usuario_actual:
                usuario_nombre = f"{usuario_actual['nombre']} {usuario_actual['apellidos']}"
            
            # Si la venta es en USD o el pago es en USD, necesitamos la tasa
            if moneda in ['USD', 'EUR'] or moneda_pago in ['USD', 'EUR']:
                # Si no nos pasaron la tasa, la pedimos al usuario
                if tasa_final is None:
                    if self.tasa_service is None:
                        logger.error("No hay servicio de tasas disponible")
                        return None
                    
                    # Determinar qué moneda preguntar
                    moneda_tasa = moneda if moneda != 'VES' else moneda_pago
                    
                    tasa_final = self.tasa_service.obtener_tasa_para_venta(
                        moneda=moneda_tasa,
                        usuario=usuario_nombre
                    )
                    
                    if tasa_final is None:
                        logger.info("Venta cancelada por el usuario")
                        return None
                
                logger.info(f"💱 Tasa de cambio aplicada: 1 USD = {tasa_final:.2f} VES")
            else:
                tasa_final = 1.0  # Tasa por defecto para VES
            
            # ===== CÁLCULO DE MONTOS =====
            # Calcular subtotal y total
            subtotal = sum(item['cantidad'] * item['precio_venta'] for item in detalle)
            iva_total = subtotal * (igv / 100)
            total = subtotal + iva_total
            
            # Calcular montos por moneda
            monto_bs = None
            monto_divisa = None
            
            if moneda == 'VES':
                monto_bs = total
                if moneda_pago == 'USD':
                    monto_divisa = total / tasa_final
                    logger.info(f"   Pago en USD: ${monto_divisa:.2f} (tasa {tasa_final:.2f})")
            else:  # USD u otra divisa
                monto_divisa = total
                monto_bs = total * tasa_final
                logger.info(f"   Equivalente en Bs.: Bs. {monto_bs:.2f} (tasa {tasa_final:.2f})")
            
            # Calcular IGTF si aplica (3% para pagos en divisas)
            igtf = IGTFService.calcular_igtf(
                monto=total,
                moneda_pago=moneda_pago or moneda,
                moneda_transaccion=moneda
            )
            if igtf > 0:
                logger.info(f"💰 IGTF (3%): {igtf:.2f}")
            
            # ===== VALIDAR STOCK =====
            logger.info("🔍 Verificando stock disponible...")
            for idx, item in enumerate(detalle, 1):
                # Validar que cada item tenga los campos requeridos
                if 'idarticulo' not in item:
                    logger.error(f"Item {idx} de venta sin ID de artículo")
                    return None
                
                if 'cantidad' not in item:
                    logger.error(f"Item {idx} de venta sin cantidad")
                    return None
                
                if 'precio_venta' not in item:
                    logger.error(f"Item {idx} de venta sin precio")
                    return None
                
                # Validar que cantidad sea entero positivo
                if not self.validar_entero_positivo(item['cantidad'], f"Cantidad del item {idx}"):
                    return None
                
                # Validar que precio sea positivo
                if not self.validar_decimal_positivo(item['precio_venta'], f"Precio del item {idx}"):
                    return None
                
                # Verificar stock usando inventario_service
                try:
                    stock_actual = self.inventario_service.obtener_stock_articulo(item['idarticulo'])
                    logger.info(f"   Artículo ID {item['idarticulo']}: Stock disponible {stock_actual}, Solicitado {item['cantidad']}")
                    
                    if item['cantidad'] > stock_actual:
                        logger.error(f"❌ Stock insuficiente para artículo ID {item['idarticulo']}. "
                                   f"Disponible: {stock_actual}, Solicitado: {item['cantidad']}")
                        return None
                except AttributeError as e:
                    logger.error(f"ERROR: inventario_service no tiene el método obtener_stock_articulo")
                    logger.error(f"   - Tipo de inventario_service: {type(self.inventario_service).__name__}")
                    return None
            
            # Validar que el trabajador existe
            trabajador = self.trabajador_service.obtener_por_id(idtrabajador)
            if not trabajador:
                logger.error(f"Trabajador ID {idtrabajador} no encontrado")
                return None
            
            # ===== REGISTRAR VENTA =====
            logger.info("📝 Registrando venta en base de datos...")
            idventa = self.repositorio.crear(
                idtrabajador=idtrabajador,
                idcliente=idcliente,
                tipo_comprobante=tipo_comprobante,
                serie=serie,
                numero_comprobante=numero_comprobante,
                igv=igv,
                estado='REGISTRADO',
                moneda=moneda,
                tasa_cambio=tasa_final,
                monto_bs=monto_bs,
                monto_divisa=monto_divisa
            )
            
            if not idventa:
                logger.error("No se pudo crear la venta en la base de datos")
                return None
            
            logger.info(f"✅ Venta #{idventa} creada en BD")
            
            # ===== REGISTRAR DETALLE Y DESCONTAR STOCK =====
            for item in detalle:
                # Agregar detalle a la venta
                detalle_id = self.repositorio.agregar_detalle(
                    idventa=idventa,
                    idarticulo=item['idarticulo'],
                    cantidad=item['cantidad'],
                    precio_venta=item['precio_venta']
                )
                
                if not detalle_id:
                    logger.error(f"Error al agregar detalle para artículo {item['idarticulo']}")
                    continue
                
                logger.info(f"   ✅ Detalle agregado: {item['cantidad']} x {item['precio_venta']:.2f}")
                
                # Actualizar stock usando inventario_service
                self.inventario_service.descontar_stock(
                    idarticulo=item['idarticulo'],
                    cantidad=item['cantidad'],
                    idventa=idventa,
                    precio_unitario=item['precio_venta']
                )
            
            # ===== RESUMEN FINAL =====
            tipo_cliente = "CONSUMIDOR FINAL" if idcliente is None else "CLIENTE IDENTIFICADO"
            
            logger.info(f"✅ Venta {idventa} registrada correctamente")
            logger.info(f"   Cliente: {tipo_cliente}")
            logger.info(f"   Moneda factura: {moneda}")
            
            if moneda == 'VES':
                logger.info(f"   Total: Bs. {total:.2f}")
                if moneda_pago == 'USD':
                    logger.info(f"   Pagado en USD: ${monto_divisa:.2f}")
            else:
                if moneda == 'USD':
                    logger.info(f"   Total: ${total:.2f} USD")
                elif moneda == 'EUR':
                    logger.info(f"   Total: €{total:.2f} EUR")
                logger.info(f"   Equivalente: Bs. {monto_bs:.2f}")
            
            if igtf > 0:
                logger.info(f"   IGTF (3%): {igtf:.2f}")
            
            return idventa
            
        except Exception as e:
            logger.error(f"❌ Error al registrar venta: {e}")
            return None
    
    def anular(self, idventa):
        """
        Anula una venta (cambia estado a ANULADO) y repone stock
        
        Args:
            idventa (int): ID de la venta a anular
            
        Returns:
            bool: True si se anuló correctamente, False en caso contrario
        """
        try:
            if not self.validar_entero_positivo(idventa, "ID de venta"):
                return False
            
            venta = self.obtener_por_id(idventa)
            if not venta:
                logger.error(f"Venta {idventa} no encontrada")
                return False
            
            if venta.get('estado') == 'ANULADO':
                logger.warning(f"La venta {idventa} ya está anulada")
                return False
            
            # Anular venta
            resultado = self.repositorio.anular(idventa)
            
            if resultado:
                logger.info(f"✅ Venta {idventa} anulada correctamente")
                
                # Reponer stock
                if venta.get('detalle'):
                    logger.info("   Reponiendo stock...")
                    for item in venta['detalle']:
                        self.inventario_service.reponer_stock(
                            idarticulo=item['idarticulo'],
                            cantidad=item['cantidad'],
                            idingreso=None,
                            precio_compra=item['precio_venta']
                        )
            else:
                logger.error(f"❌ No se pudo anular la venta {idventa}")
            
            return resultado
            
        except Exception as e:
            logger.error(f"Error al anular venta {idventa}: {e}")
            return False
    
    def ventas_por_cliente(self, idcliente):
        """
        Obtiene todas las ventas de un cliente específico
        
        Args:
            idcliente (int): ID del cliente
            
        Returns:
            list: Lista de ventas del cliente
        """
        try:
            if not self.validar_entero_positivo(idcliente, "ID del cliente"):
                return []
            return self.repositorio.ventas_por_cliente(idcliente)
        except Exception as e:
            logger.error(f"Error al obtener ventas del cliente {idcliente}: {e}")
            return []
    
    def ventas_por_fecha(self, fecha_inicio, fecha_fin):
        """
        Obtiene ventas en un rango de fechas
        
        Args:
            fecha_inicio: Fecha inicial
            fecha_fin: Fecha final
            
        Returns:
            list: Lista de ventas en el rango
        """
        try:
            return self.repositorio.ventas_por_fecha(fecha_inicio, fecha_fin)
        except Exception as e:
            logger.error(f"Error al obtener ventas por fecha: {e}")
            return []
    
    def total_ventas_dia(self, fecha=None):
        """
        Calcula el total de ventas de un día específico
        
        Args:
            fecha: Fecha (si es None, usa la fecha actual)
            
        Returns:
            float: Total de ventas del día
        """
        try:
            from datetime import datetime
            if fecha is None:
                fecha = datetime.now().date()
            ventas = self.repositorio.ventas_por_fecha(fecha, fecha)
            return sum(v.get('total', 0) for v in ventas)
        except Exception as e:
            logger.error(f"Error al calcular total de ventas del día: {e}")
            return 0.0
    
    def ventas_del_dia(self):
        """
        Obtiene las ventas del día actual
        
        Returns:
            list: Lista de ventas del día
        """
        try:
            from datetime import datetime
            hoy = datetime.now().date()
            return self.ventas_por_fecha(hoy, hoy)
        except Exception as e:
            logger.error(f"Error al obtener ventas del día: {e}")
            return []
    
    def resumen_ventas(self, fecha_inicio, fecha_fin):
        """
        Genera un resumen de ventas en un período
        
        Args:
            fecha_inicio: Fecha inicial
            fecha_fin: Fecha final
            
        Returns:
            dict: Resumen con totales y estadísticas
        """
        try:
            ventas = self.ventas_por_fecha(fecha_inicio, fecha_fin)
            
            total_ventas = len(ventas)
            total_ingresos = sum(v.get('total', 0) for v in ventas)
            promedio_por_venta = total_ingresos / total_ventas if total_ventas > 0 else 0
            
            # Contar por tipo de comprobante
            por_tipo = {}
            # Resumen por moneda
            por_moneda = {'VES': 0, 'USD': 0, 'EUR': 0}
            
            for v in ventas:
                tipo = v.get('tipo_comprobante', 'OTRO')
                por_tipo[tipo] = por_tipo.get(tipo, 0) + 1
                
                moneda = v.get('moneda', 'VES')
                if moneda in por_moneda:
                    por_moneda[moneda] += v.get('total', 0)
            
            return {
                'fecha_inicio': fecha_inicio,
                'fecha_fin': fecha_fin,
                'total_ventas': total_ventas,
                'total_ingresos': total_ingresos,
                'promedio_por_venta': promedio_por_venta,
                'por_tipo': por_tipo,
                'por_moneda': por_moneda,
                'ventas': ventas
            }
            
        except Exception as e:
            logger.error(f"Error al generar resumen de ventas: {e}")
            return {}
----- capa_negocio/usuario_admin_service.py -----
from typing import List, Dict, Optional
from datetime import datetime, date
from loguru import logger
from capa_negocio.base_service import BaseService

class UsuarioAdminService(BaseService):
    """Servicio para administración de usuarios (solo para admin)"""
    
    def __init__(self, repositorio, rol_service=None):
        self.repositorio = repositorio
        self.rol_service = rol_service
    
    def listar_usuarios(self) -> List[Dict]:
        """Lista todos los usuarios"""
        try:
            return self.repositorio.listar_usuarios()
        except Exception as e:
            logger.error(f"❌ Error al listar usuarios: {e}")
            return []
    
    def obtener_usuario(self, idtrabajador: int) -> Optional[Dict]:
        """Obtiene un usuario por ID"""
        if not self.validar_entero_positivo(idtrabajador, "ID de usuario"):
            return None
        return self.repositorio.obtener_usuario(idtrabajador)
    
    def crear_usuario(self, nombre: str, apellidos: str, sexo: str,
                      fecha_nacimiento, num_documento: str,
                      usuario: str, password: str,
                      email: str, idrol: int,
                      direccion: str = None, telefono: str = None) -> bool:
        """Crea un nuevo usuario con validaciones"""
        
        # Validaciones básicas
        if not self.validar_requerido(nombre, "nombre"):
            return False
        if not self.validar_requerido(apellidos, "apellidos"):
            return False
        if not self.validar_requerido(usuario, "usuario"):
            return False
        if not self.validar_requerido(password, "contraseña"):
            return False
        if not self.validar_requerido(email, "email"):
            return False
        if not self.validar_requerido(num_documento, "documento"):
            return False
        if not self.validar_entero_positivo(idrol, "rol"):
            return False
        
        # Validaciones específicas
        if len(password) < 6:
            logger.warning("⚠️ La contraseña debe tener al menos 6 caracteres")
            return False
        
        if not self.validar_email(email):
            return False
        
        if telefono and not self.validar_telefono(telefono):
            return False
        
        if sexo and sexo not in ['M', 'F', 'O']:
            logger.warning("⚠️ Sexo debe ser M, F u O")
            return False
        
        # Validar que no exista usuario con mismo username o email
        if self.repositorio.verificar_usuario_existe(usuario, email):
            logger.warning("⚠️ Ya existe un usuario con ese nombre de usuario o email")
            return False
        
        # Validar fecha de nacimiento (mayor de edad)
        if isinstance(fecha_nacimiento, str):
            fecha_nacimiento = datetime.strptime(fecha_nacimiento, '%Y-%m-%d').date()
        
        hoy = date.today()
        edad = hoy.year - fecha_nacimiento.year - ((hoy.month, hoy.day) < (fecha_nacimiento.month, fecha_nacimiento.day))
        
        if edad < 18:
            logger.warning("⚠️ El usuario debe ser mayor de edad")
            return False
        
        # Verificar que el rol existe
        if self.rol_service:
            rol = self.rol_service.obtener_rol(idrol)
            if not rol:
                logger.warning(f"⚠️ El rol {idrol} no existe")
                return False
        
        try:
            return self.repositorio.crear_usuario(
                nombre.strip(), apellidos.strip(), sexo, fecha_nacimiento,
                num_documento, usuario.strip(), password, email.strip(),
                idrol, direccion, telefono
            )
        except Exception as e:
            logger.error(f"❌ Error al crear usuario: {e}")
            return False
    
    def actualizar_usuario(self, idtrabajador: int, nombre: str, apellidos: str,
                           sexo: str, fecha_nacimiento, num_documento: str,
                           usuario: str, email: str, idrol: int,
                           direccion: str = None, telefono: str = None,
                           nueva_password: str = None) -> bool:
        """Actualiza un usuario existente"""
        
        if not self.validar_entero_positivo(idtrabajador, "ID de usuario"):
            return False
        
        # Validaciones
        if not self.validar_requerido(nombre, "nombre"):
            return False
        if not self.validar_requerido(apellidos, "apellidos"):
            return False
        if not self.validar_requerido(usuario, "usuario"):
            return False
        if not self.validar_requerido(email, "email"):
            return False
        if not self.validar_entero_positivo(idrol, "rol"):
            return False
        
        if not self.validar_email(email):
            return False
        
        if telefono and not self.validar_telefono(telefono):
            return False
        
        if sexo and sexo not in ['M', 'F', 'O']:
            logger.warning("⚠️ Sexo debe ser M, F u O")
            return False
        
        if nueva_password and len(nueva_password) < 6:
            logger.warning("⚠️ La nueva contraseña debe tener al menos 6 caracteres")
            return False
        
        try:
            return self.repositorio.actualizar_usuario(
                idtrabajador, nombre.strip(), apellidos.strip(), sexo, fecha_nacimiento,
                num_documento, usuario.strip(), email.strip(), idrol,
                direccion, telefono, nueva_password
            )
        except Exception as e:
            logger.error(f"❌ Error al actualizar usuario: {e}")
            return False
    
    def eliminar_usuario(self, idtrabajador: int) -> bool:
        """Elimina un usuario (no puede eliminarse a sí mismo)"""
        # Esta validación se hará en el menú
        if not self.validar_entero_positivo(idtrabajador, "ID de usuario"):
            return False
        return self.repositorio.eliminar_usuario(idtrabajador)
----- capa_negocio/token_service.py -----
from datetime import datetime, timedelta
import secrets
import hashlib
from loguru import logger

class TokenService:
    """Servicio para gestionar tokens de recuperación"""
    
    def __init__(self, conexion):
        self.conexion = conexion
        self.cursor = conexion.cursor()
    
    def generar_token(self):
        """Genera un token criptográficamente seguro"""
        return secrets.token_urlsafe(32)  # Ej: "x7q9p3m2k1j5h8g4f6d3s9a2w5e7r8t9"
    
    def crear_token(self, idtrabajador):
        """Crea un token único y lo guarda en BD"""
        try:
            # Generar token seguro
            token_raw = self.generar_token()
            
            # Crear hash del token para almacenar (por seguridad)
            token_hash = hashlib.sha256(token_raw.encode()).hexdigest()
            
            # Fecha de expiración (30 minutos)
            expires_at = datetime.now() + timedelta(minutes=30)
            
            # Guardar en BD
            self.cursor.execute("""
                INSERT INTO reset_tokens (idtrabajador, token, expires_at)
                VALUES (?, ?, ?)
            """, (idtrabajador, token_hash, expires_at))
            self.cursor.commit()
            
            logger.info(f"✅ Token creado para trabajador {idtrabajador}")
            
            # Devolver el token original para enviar por email
            return token_raw
            
        except Exception as e:
            logger.error(f"❌ Error al crear token: {e}")
            return None
    
    def verificar_token(self, token_raw):
        """Verifica si un token es válido y devuelve el id del trabajador"""
        try:
            # Calcular hash del token recibido
            token_hash = hashlib.sha256(token_raw.encode()).hexdigest()
            
            # Buscar token en BD
            self.cursor.execute("""
                SELECT idtrabajador, expires_at, used
                FROM reset_tokens
                WHERE token = ? AND used = 0 AND expires_at > GETDATE()
            """, (token_hash,))
            
            resultado = self.cursor.fetchone()
            if resultado:
                idtrabajador = resultado[0]
                
                # Marcar como usado (opcional - lo marcaremos después del cambio)
                # self.cursor.execute("UPDATE reset_tokens SET used = 1 WHERE token = ?", (token_hash,))
                # self.cursor.commit()
                
                logger.info(f"✅ Token válido para trabajador {idtrabajador}")
                return idtrabajador
            
            logger.warning("⚠️ Token inválido o expirado")
            return None
            
        except Exception as e:
            logger.error(f"❌ Error al verificar token: {e}")
            return None
    
    def marcar_token_usado(self, token_raw):
        """Marca un token como usado después de cambiar la contraseña"""
        try:
            token_hash = hashlib.sha256(token_raw.encode()).hexdigest()
            self.cursor.execute("UPDATE reset_tokens SET used = 1 WHERE token = ?", (token_hash,))
            self.cursor.commit()
            return True
        except Exception as e:
            logger.error(f"❌ Error al marcar token como usado: {e}")
            return False
    
    def limpiar_tokens_expirados(self):
        """Elimina tokens expirados de la BD"""
        try:
            self.cursor.execute("DELETE FROM reset_tokens WHERE expires_at < GETDATE()")
            self.cursor.commit()
            logger.info("🧹 Tokens expirados eliminados")
            return True
        except Exception as e:
            logger.error(f"❌ Error al limpiar tokens: {e}")
            return False

----- capa_negocio/reporte_contable_service.py -----
"""
Servicio para generación de reportes contables
"""
from datetime import datetime, timedelta
from loguru import logger
import csv
import os

class ReporteContableService:
    """Genera reportes contables para ventas y movimientos"""
    
    def __init__(self, venta_service, inventario_service):
        self.venta_service = venta_service
        self.inventario_service = inventario_service
        logger.info("✅ ReporteContableService inicializado")
    
    def obtener_ventas_por_periodo(self, fecha_inicio, fecha_fin):
        """
        Obtiene todas las ventas en un período
        """
        ventas = self.venta_service.ventas_por_fecha(fecha_inicio, fecha_fin)
        
        print("\n" + "="*60)
        print("🔍 DEPURACIÓN DE VENTAS")
        print("="*60)
        print(f"Total ventas encontradas: {len(ventas)}")
        
        # Calcular totales por moneda
        total_bs = 0.0
        total_usd = 0.0
        total_eur = 0.0
        igtf_total = 0.0
        
        for idx, v in enumerate(ventas):
            print(f"\n--- VENTA #{idx+1} (ID: {v.get('idventa')}) ---")
            
            # Mostrar todos los campos de la venta
            for key, value in v.items():
                print(f"   {key}: {value} (tipo: {type(value)})")
            
            # Determinar moneda
            moneda = v.get('moneda', 'NO ESPECIFICADA')
            print(f"   → Moneda detectada: {moneda}")
            
            # Obtener montos
            monto_bs = v.get('monto_bs')
            monto_divisa = v.get('monto_divisa')
            
            print(f"   → monto_bs: {monto_bs}")
            print(f"   → monto_divisa: {monto_divisa}")
            
            # Sumar según moneda
            if moneda == 'VES' and monto_bs is not None:
                total_bs += float(monto_bs)
                print(f"   ✓ Sumando a Bs.: +{float(monto_bs)}")
            elif moneda == 'USD' and monto_divisa is not None:
                total_usd += float(monto_divisa)
                print(f"   ✓ Sumando a USD: +{float(monto_divisa)}")
            elif moneda == 'EUR' and monto_divisa is not None:
                total_eur += float(monto_divisa)
                print(f"   ✓ Sumando a EUR: +{float(monto_divisa)}")
            else:
                print(f"   ✗ No se pudo sumar - moneda: {moneda}, monto_bs: {monto_bs}, monto_divisa: {monto_divisa}")
        
        print("\n" + "="*60)
        print("📊 TOTALES CALCULADOS:")
        print(f"   Bs.: {total_bs}")
        print(f"   USD: {total_usd}")
        print(f"   EUR: {total_eur}")
        print(f"   IGTF: {igtf_total}")
        print("="*60)
        
        return {
            'fecha_inicio': str(fecha_inicio),
            'fecha_fin': str(fecha_fin),
            'total_ventas': len(ventas),
            'total_bs': total_bs,
            'total_usd': total_usd,
            'total_eur': total_eur,
            'igtf_total': igtf_total,
            'ventas': ventas,
            'detalle': self._agrupar_por_dia(ventas)
        }
    
    def _agrupar_por_dia(self, ventas):
        """Agrupa ventas por día para reportes detallados"""
        dias = {}
        for v in ventas:
            # Obtener fecha
            if hasattr(v['fecha'], 'strftime'):
                fecha = v['fecha'].strftime('%Y-%m-%d')
            else:
                fecha = str(v['fecha'])[:10]
            
            if fecha not in dias:
                dias[fecha] = {
                    'ventas': 0,
                    'bs': 0.0,
                    'usd': 0.0,
                    'eur': 0.0
                }
            
            dias[fecha]['ventas'] += 1
            
            # Sumar según moneda
            moneda = v.get('moneda', 'VES')
            monto_bs = v.get('monto_bs')
            monto_divisa = v.get('monto_divisa')
            
            if moneda == 'VES' and monto_bs is not None:
                dias[fecha]['bs'] += float(monto_bs)
            elif moneda == 'USD' and monto_divisa is not None:
                dias[fecha]['usd'] += float(monto_divisa)
            elif moneda == 'EUR' and monto_divisa is not None:
                dias[fecha]['eur'] += float(monto_divisa)
        
        return dias
    
    def reporte_diario(self, fecha=None):
        """Reporte de ventas del día"""
        if fecha is None:
            fecha = datetime.now().date()
        return self.obtener_ventas_por_periodo(fecha, fecha)
    
    def reporte_semanal(self, fecha=None):
        """Reporte de la última semana"""
        if fecha is None:
            fecha = datetime.now().date()
        fecha_inicio = fecha - timedelta(days=7)
        return self.obtener_ventas_por_periodo(fecha_inicio, fecha)
    
    def reporte_mensual(self, fecha=None):
        """Reporte del último mes"""
        if fecha is None:
            fecha = datetime.now().date()
        fecha_inicio = fecha - timedelta(days=30)
        return self.obtener_ventas_por_periodo(fecha_inicio, fecha)
    
    def reporte_trimestral(self, fecha=None):
        """Reporte del último trimestre"""
        if fecha is None:
            fecha = datetime.now().date()
        fecha_inicio = fecha - timedelta(days=90)
        return self.obtener_ventas_por_periodo(fecha_inicio, fecha)
    
    def reporte_anual(self, fecha=None):
        """Reporte del último año"""
        if fecha is None:
            fecha = datetime.now().date()
        fecha_inicio = fecha - timedelta(days=365)
        return self.obtener_ventas_por_periodo(fecha_inicio, fecha)
    
    def exportar_a_csv(self, datos_reporte, nombre_archivo=None):
        """
        Exporta reporte a CSV para usar en Excel/contabilidad
        """
        if nombre_archivo is None:
            fecha = datetime.now().strftime("%Y%m%d_%H%M%S")
            nombre_archivo = f"reporte_ventas_{fecha}.csv"
        
        # Asegurar directorio de reportes
        os.makedirs("reportes", exist_ok=True)
        ruta_completa = os.path.join("reportes", nombre_archivo)
        
        with open(ruta_completa, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            
            # Encabezados contables
            writer.writerow(['REPORTE CONTABLE DE VENTAS'])
            writer.writerow([f'Período: {datos_reporte["fecha_inicio"]} al {datos_reporte["fecha_fin"]}'])
            writer.writerow([])
            
            # Totales
            writer.writerow(['RESUMEN GENERAL'])
            writer.writerow(['Total Ventas', datos_reporte['total_ventas']])
            writer.writerow(['Total Bs.', f"{datos_reporte['total_bs']:.2f}"])
            writer.writerow(['Total USD', f"{datos_reporte['total_usd']:.2f}"])
            writer.writerow(['Total EUR', f"{datos_reporte['total_eur']:.2f}"])
            writer.writerow(['IGTF Total', f"{datos_reporte['igtf_total']:.2f}"])
            writer.writerow([])
            
            # Detalle por día
            writer.writerow(['DETALLE POR DÍA'])
            writer.writerow(['Fecha', 'Ventas', 'Bs.', 'USD', 'EUR'])
            
            for fecha, datos in sorted(datos_reporte['detalle'].items()):
                writer.writerow([
                    fecha,
                    datos['ventas'],
                    f"{datos['bs']:.2f}",
                    f"{datos['usd']:.2f}",
                    f"{datos['eur']:.2f}"
                ])
        
        logger.info(f"✅ Reporte exportado: {ruta_completa}")
        return ruta_completa
----- capa_negocio/validacion_venezuela.py -----
from datetime import datetime
import re

class ValidacionVenezuela:
    """Clase con métodos de validación para documentos venezolanos"""
    
    @staticmethod
    def validar_cedula(cedula):
        """
        Valida una cédula venezolana (formato: V12345678 o E12345678)
        Retorna: (bool, mensaje_error)
        """
        if not cedula:
            return False, "La cédula no puede estar vacía"
        
        # Patrón para cédula venezolana: V/E + 8 dígitos
        patron = r'^[VE]\d{8}$'
        if not re.match(patron, cedula):
            return False, "Formato inválido. Debe ser V/E seguido de 8 dígitos (ej: V12345678)"
        
        return True, ""
    
    @staticmethod
    def validar_rif(rif):
        """
        Valida un RIF venezolano (formato: J123456789, G123456789, etc)
        Retorna: (bool, mensaje_error)
        """
        if not rif:
            return False, "El RIF no puede estar vacío"
        
        # Patrón para RIF: letra + 9 dígitos
        patron = r'^[JPGVE]\d{9}$'
        if not re.match(patron, rif):
            return False, "Formato inválido. Debe ser letra (J,P,G,V,E) seguida de 9 dígitos"
        
        return True, ""
    
    @staticmethod
    def validar_fecha(fecha_str):
        """
        Valida una fecha en formato DD/MM/YYYY
        Retorna: (bool, datetime or None, mensaje_error)
        """
        if not fecha_str or fecha_str.strip() == "":
            return True, None, ""  # Fecha vacía es válida (opcional)
        
        # Limpiar la fecha (quitar espacios)
        fecha_str = fecha_str.strip()
        
        # Patrón para DD/MM/YYYY
        patron = r'^(\d{1,2})/(\d{1,2})/(\d{4})$'
        match = re.match(patron, fecha_str)
        
        if not match:
            return False, None, "❌ Formato incorrecto. Use DD/MM/YYYY (ej: 15/05/1990)"
        
        dia, mes, año = map(int, match.groups())
        
        # Validar rangos básicos
        if mes < 1 or mes > 12:
            return False, None, "❌ Mes inválido (debe ser entre 01 y 12)"
        
        # Días por mes
        dias_por_mes = {
            1: 31, 2: 29, 3: 31, 4: 30, 5: 31, 6: 30,
            7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31
        }
        
        if dia < 1 or dia > dias_por_mes[mes]:
            return False, None, f"❌ Día inválido para el mes {mes:02d} (máximo {dias_por_mes[mes]} días)"
        
        # Validación especial para febrero en años bisiestos
        if mes == 2 and dia == 29:
            if not ValidacionVenezuela._es_bisiesto(año):
                return False, None, f"❌ El año {año} no es bisiesto, febrero solo tiene 28 días"
        
        # Validar que no sea fecha futura
        try:
            fecha_obj = datetime(año, mes, dia)
            hoy = datetime.now()
            
            if fecha_obj > hoy:
                return False, None, "❌ La fecha no puede ser futura"
            
        except ValueError:
            return False, None, "❌ Fecha inválida (ej: 31/11/2023 no existe)"
        
        return True, fecha_obj, ""
    
    @staticmethod
    def _es_bisiesto(año):
        """Determina si un año es bisiesto"""
        return (año % 4 == 0 and año % 100 != 0) or (año % 400 == 0)
    
    @staticmethod
    def formatear_fecha_para_bd(fecha_obj):
        """Convierte un objeto datetime a string YYYY-MM-DD para BD"""
        if fecha_obj:
            return fecha_obj.strftime('%Y-%m-%d')
        return None
    
    @staticmethod
    def validar_telefono(telefono):
        """
        Valida un teléfono venezolano
        Acepta: 04141234567, 0414-1234567, +584141234567, etc
        """
        if not telefono:
            return True  # Teléfono opcional
        
        # Limpiar el teléfono (quitar +, -, espacios)
        telefono_limpio = re.sub(r'[\+\-\s]', '', telefono)
        
        # Verificar que sea solo números y tenga entre 10 y 12 dígitos
        if not telefono_limpio.isdigit():
            return False
        
        if len(telefono_limpio) < 10 or len(telefono_limpio) > 12:
            return False
        
        return True
    
    @staticmethod
    def validar_email(email):
        """
        Valida un email
        """
        if not email:
            return True  # Email opcional
        
        patron = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(patron, email) is not None
----- capa_negocio/base_service.py -----
from typing import Optional, List, Dict, Any
from datetime import datetime
import re
from loguru import logger

class BaseService:
    """Clase base para servicios con validaciones comunes"""
    
    @staticmethod
    def validar_requerido(valor: Any, nombre_campo: str) -> bool:
        """Valida que un campo requerido no esté vacío"""
        if valor is None or (isinstance(valor, str) and not valor.strip()):
            logger.warning(f"⚠️ El campo {nombre_campo} es requerido")
            return False
        return True
    
    @staticmethod
    def validar_longitud(texto: str, nombre_campo: str, min_len: int = None, max_len: int = None) -> bool:
        """Valida la longitud de un texto"""
        if texto is None:
            return False
        
        if min_len is not None and len(texto) < min_len:
            logger.warning(f"⚠️ El campo {nombre_campo} debe tener al menos {min_len} caracteres")
            return False
        
        if max_len is not None and len(texto) > max_len:
            logger.warning(f"⚠️ El campo {nombre_campo} no debe exceder {max_len} caracteres")
            return False
        
        return True
    
    @staticmethod
    def validar_email(email: str) -> bool:
        """Valida formato de email"""
        if not email:
            return True  # Email puede ser opcional
        
        patron = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(patron, email):
            logger.warning(f"⚠️ El email {email} no tiene formato válido")
            return False
        return True
    
    @staticmethod
    def validar_telefono(telefono: str) -> bool:
        """Valida formato de teléfono (solo números, longitud entre 7-15)"""
        if not telefono:
            return True  # Teléfono puede ser opcional
        
        if not telefono.isdigit():
            logger.warning("⚠️ El teléfono debe contener solo números")
            return False
        
        if len(telefono) < 7 or len(telefono) > 15:
            logger.warning("⚠️ El teléfono debe tener entre 7 y 15 dígitos")
            return False
        
        return True
    
    @staticmethod
    def validar_documento(tipo: str, numero: str) -> bool:
        """Valida documento según tipo (DNI, RUC, etc.)"""
        if tipo.upper() == 'DNI':
            if len(numero) != 8 or not numero.isdigit():
                logger.warning("⚠️ DNI debe tener 8 dígitos")
                return False
        elif tipo.upper() == 'RUC':
            if len(numero) != 11 or not numero.isdigit():
                logger.warning("⚠️ RUC debe tener 11 dígitos")
                return False
        elif tipo.upper() == 'PASAPORTE':
            if len(numero) < 6 or len(numero) > 12:
                logger.warning("⚠️ Pasaporte debe tener entre 6 y 12 caracteres")
                return False
        return True
    
    @staticmethod
    def validar_fecha(fecha: datetime, nombre_campo: str, min_fecha: datetime = None, max_fecha: datetime = None) -> bool:
        """Valida que una fecha sea válida y esté en rango"""
        if not isinstance(fecha, datetime):
            logger.warning(f"⚠️ {nombre_campo} debe ser una fecha válida")
            return False
        
        if min_fecha and fecha < min_fecha:
            logger.warning(f"⚠️ {nombre_campo} no puede ser anterior a {min_fecha.strftime('%d/%m/%Y')}")
            return False
        
        if max_fecha and fecha > max_fecha:
            logger.warning(f"⚠️ {nombre_campo} no puede ser posterior a {max_fecha.strftime('%d/%m/%Y')}")
            return False
        
        return True
    
    @staticmethod
    def validar_entero_positivo(valor: int, nombre_campo: str, permitir_cero: bool = False) -> bool:
        """Valida que un número entero sea positivo"""
        if not isinstance(valor, int):
            logger.warning(f"⚠️ {nombre_campo} debe ser un número entero")
            return False
        
        if permitir_cero:
            if valor < 0:
                logger.warning(f"⚠️ {nombre_campo} no puede ser negativo")
                return False
        else:
            if valor <= 0:
                logger.warning(f"⚠️ {nombre_campo} debe ser mayor que cero")
                return False
        
        return True
    
    @staticmethod
    def validar_decimal_positivo(valor: float, nombre_campo: str, permitir_cero: bool = False) -> bool:
        """Valida que un número decimal sea positivo"""
        if not isinstance(valor, (int, float)):
            logger.warning(f"⚠️ {nombre_campo} debe ser un número")
            return False
        
        if permitir_cero:
            if valor < 0:
                logger.warning(f"⚠️ {nombre_campo} no puede ser negativo")
                return False
        else:
            if valor <= 0:
                logger.warning(f"⚠️ {nombre_campo} debe ser mayor que cero")
                return False
        
        return True

----- capa_negocio/auditoria_service.py -----
"""
Servicio de auditoría para cumplimiento SENIAT
"""
from datetime import datetime
from loguru import logger

class AuditoriaService:
    """Registra todas las acciones del sistema para cumplimiento legal"""
    
    def __init__(self, repositorio):
        """
        Inicializa el servicio de auditoría
        
        Args:
            repositorio: Instancia de AuditoriaRepositorio
        """
        self.repositorio = repositorio
    
    def registrar(self, usuario, accion, tabla, registro_id, datos_anteriores=None, datos_nuevos=None):
        """
        Registra una acción en el log de auditoría
        
        Args:
            usuario: Nombre del usuario que ejecuta la acción
            accion: Tipo de acción (CREAR, MODIFICAR, ELIMINAR, ANULAR, etc)
            tabla: Tabla afectada
            registro_id: ID del registro afectado
            datos_anteriores: Estado anterior (para modificaciones)
            datos_nuevos: Estado nuevo
            
        Returns:
            bool: True si se registró correctamente
        """
        try:
            # Obtener IP (en un sistema real, obtener de la conexión)
            ip = '127.0.0.1'
            
            resultado = self.repositorio.insertar(
                usuario=usuario,
                accion=accion,
                tabla=tabla,
                registro_id=registro_id,
                datos_anteriores=str(datos_anteriores) if datos_anteriores else None,
                datos_nuevos=str(datos_nuevos) if datos_nuevos else None,
                ip_address=ip
            )
            
            if resultado:
                logger.info(f"📝 Auditoría: {usuario} - {accion} en {tabla} ID:{registro_id}")
            else:
                logger.error(f"❌ Error registrando auditoría: {usuario} - {accion}")
            
            return resultado
            
        except Exception as e:
            logger.error(f"Error en servicio de auditoría: {e}")
            return False
    
    def consultar_por_fecha(self, fecha_inicio, fecha_fin):
        """
        Consulta registros de auditoría por rango de fechas
        
        Args:
            fecha_inicio: Fecha inicial
            fecha_fin: Fecha final
            
        Returns:
            list: Lista de registros
        """
        return self.repositorio.consultar_por_fecha(fecha_inicio, fecha_fin)
    
    def consultar_por_usuario(self, usuario):
        """
        Consulta registros de un usuario específico
        
        Args:
            usuario: Nombre del usuario
            
        Returns:
            list: Lista de registros
        """
        return self.repositorio.consultar_por_usuario(usuario)
    
    def consultar_por_tabla(self, tabla, registro_id):
        """
        Consulta historial de cambios en un registro específico
        
        Args:
            tabla: Nombre de la tabla
            registro_id: ID del registro
            
        Returns:
            list: Lista de registros
        """
        return self.repositorio.consultar_por_tabla(tabla, registro_id)
----- capa_negocio/moneda_service.py -----
"""
Servicio para gestión de multimoneda y tasas de cambio
"""
from datetime import datetime
from loguru import logger
import requests

class MonedaService:
    """Servicio para manejar operaciones con múltiples monedas"""
    
    MONEDAS = {
        'VES': {'nombre': 'Bolívar', 'simbolo': 'Bs.', 'decimales': 2},
        'USD': {'nombre': 'Dólar', 'simbolo': '$', 'decimales': 2},
        'EUR': {'nombre': 'Euro', 'simbolo': '€', 'decimales': 2}
    }
    
    def __init__(self, conn):
        self.conn = conn
        logger.info("✅ MonedaService inicializado")
    
    def obtener_tasa_actual(self):
        """
        Obtiene la tasa de cambio actual (USD/VES)
        Prioridad: 1. BCV, 2. Última registrada, 3. Manual
        """
        try:
            # Intentar obtener tasa del BCV
            tasa_bcv = self._obtener_tasa_bcv()
            if tasa_bcv:
                self._guardar_tasa(tasa_bcv, 'BCV')
                return tasa_bcv
            
            # Si no, obtener última tasa registrada
            cursor = self.conn.cursor()
            query = """
            SELECT TOP 1 tasa 
            FROM tasa_cambio 
            WHERE activa = 1 
            ORDER BY fecha DESC
            """
            cursor.execute(query)
            row = cursor.fetchone()
            
            if row:
                return row[0]
            
            return 1.0  # Tasa por defecto
            
        except Exception as e:
            logger.error(f"Error obteniendo tasa: {e}")
            return 1.0
    
    def _obtener_tasa_bcv(self):
        """
        Consulta la tasa del BCV (simulado por ahora)
        En producción, conectar con API real del BCV
        """
        try:
            # Simulación - en producción conectar con API real
            # response = requests.get('https://api.bcv.org.ve/tasas', timeout=5)
            # return response.json()['usd']
            
            # Por ahora, retornar tasa simulada
            return 60.0  # Simular 60 Bs/USD
        except:
            return None
    
    def _guardar_tasa(self, tasa, fuente='MANUAL'):
        """Guarda una tasa en la base de datos"""
        try:
            cursor = self.conn.cursor()
            
            # Desactivar tasas anteriores
            cursor.execute("UPDATE tasa_cambio SET activa = 0 WHERE activa = 1")
            
            # Insertar nueva tasa
            query = """
            INSERT INTO tasa_cambio (fecha, tasa, fuente, activa)
            VALUES (GETDATE(), ?, ?, 1)
            """
            cursor.execute(query, (tasa, fuente))
            self.conn.commit()
            
            logger.info(f"✅ Tasa guardada: 1 USD = {tasa} VES ({fuente})")
            
        except Exception as e:
            logger.error(f"Error guardando tasa: {e}")
    
    def actualizar_tasa_manual(self, tasa):
        """Actualiza la tasa manualmente"""
        return self._guardar_tasa(tasa, 'MANUAL')
    
    def convertir(self, monto, moneda_origen, moneda_destino, tasa=None):
        """
        Convierte entre monedas
        
        Args:
            monto: Cantidad a convertir
            moneda_origen: VES, USD, EUR
            moneda_destino: VES, USD, EUR
            tasa: Tasa de cambio (si es None, usa la actual)
        
        Returns:
            float: Monto convertido
        """
        if moneda_origen == moneda_destino:
            return monto
        
        if tasa is None:
            tasa = self.obtener_tasa_actual()
        
        if moneda_origen == 'USD' and moneda_destino == 'VES':
            return monto * tasa
        elif moneda_origen == 'VES' and moneda_destino == 'USD':
            return monto / tasa
        else:
            logger.error(f"Conversión no soportada: {moneda_origen} → {moneda_destino}")
            return monto
    
    def formatear_monto(self, monto, moneda='VES'):
        """Formatea un monto según la moneda"""
        info = self.MONEDAS.get(moneda, self.MONEDAS['VES'])
        formato = f"{info['simbolo']} {monto:,.{info['decimales']}f}"
        return formato.replace(',', ' ').replace('.', ',')

class IGTFService:
    """Servicio para calcular el IGTF (Impuesto a Grandes Transacciones Financieras)"""
    
    TASA_IGTF = 0.03  # 3% para pagos en divisas
    
    @staticmethod
    def calcular_igtf(monto, moneda_pago, moneda_transaccion='VES'):
        """
        Calcula el IGTF según la moneda de pago
        
        Args:
            monto: Monto de la transacción
            moneda_pago: Moneda en que se paga (USD, VES, etc)
            moneda_transaccion: Moneda de la factura
            
        Returns:
            float: Monto del IGTF
        """
        if moneda_pago in ['USD', 'EUR']:
            return monto * IGTFService.TASA_IGTF
        return 0.0
----- capa_negocio/cliente_service.py -----
"""
Servicio para la gestión de clientes
"""
from loguru import logger
import re
from capa_negocio.base_service import BaseService
from capa_negocio.validacion_venezuela import ValidacionVenezuela

class ClienteService(BaseService):
    """Servicio que implementa la lógica de negocio para clientes"""
    
    def __init__(self, repositorio):
        """
        Inicializa el servicio con un repositorio de clientes
        
        Args:
            repositorio: Instancia de ClienteRepositorio
        """
        # CORRECCIÓN: Llamar correctamente al constructor de BaseService
        # BaseService no requiere argumentos en __init__
        super().__init__()
        self.repositorio = repositorio
    
    def listar(self):
        """
        Lista todos los clientes
        
        Returns:
            list: Lista de clientes o lista vacía si hay error
        """
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"Error al listar clientes: {e}")
            return []
    
    def obtener_por_id(self, idcliente):
        """
        Obtiene un cliente por su ID
        
        Args:
            idcliente (int): ID del cliente
            
        Returns:
            dict: Datos del cliente o None si no existe
        """
        try:
            return self.repositorio.obtener_por_id(idcliente)
        except Exception as e:
            logger.error(f"Error al obtener cliente {idcliente}: {e}")
            return None
    
    def buscar_por_documento(self, documento):
        """
        Busca un cliente por su número de documento
        
        Args:
            documento (str): Documento completo (ej: V12345678)
            
        Returns:
            dict: Datos del cliente o None si no existe
        """
        try:
            # Separar tipo y número
            if documento and documento[0] in ['V', 'E', 'J', 'G', 'C']:
                tipo = documento[0]
                numero = documento[1:]
                return self.repositorio.buscar_por_documento(tipo, numero)
            return None
        except Exception as e:
            logger.error(f"Error al buscar cliente por documento {documento}: {e}")
            return None
    
    def crear(self, nombre, apellidos, fecha_nacimiento, tipo_documento, 
              num_documento, sexo=None, direccion=None, telefono=None, email=None):
        """
        Crea un nuevo cliente (fecha_nacimiento puede ser None)
        
        Args:
            nombre (str): Nombre del cliente
            apellidos (str): Apellidos del cliente
            fecha_nacimiento (str or None): Fecha de nacimiento (YYYY-MM-DD o None)
            tipo_documento (str): Tipo de documento (V, E, J, G, C, PASAPORTE)
            num_documento (str): Número de documento
            sexo (str, optional): Sexo (M, F, O)
            direccion (str, optional): Dirección
            telefono (str, optional): Teléfono
            email (str, optional): Email
            
        Returns:
            bool: True si se creó correctamente, False en caso contrario
        """
        try:
            # Validar campos obligatorios
            if not nombre or not nombre.strip():
                logger.error("El nombre es obligatorio")
                return False
            
            if not apellidos or not apellidos.strip():
                logger.error("Los apellidos son obligatorios")
                return False
            
            if not tipo_documento:
                logger.error("El tipo de documento es obligatorio")
                return False
            
            if not num_documento or not num_documento.strip():
                logger.error("El número de documento es obligatorio")
                return False
            
            # Validar formato del documento según el tipo
            if tipo_documento in ['V', 'E', 'J', 'G', 'C']:
                # Debe ser solo números y tener 8 dígitos
                if not num_documento.isdigit():
                    logger.error(f"El número de documento para tipo {tipo_documento} debe contener solo dígitos")
                    return False
                if len(num_documento) != 8:
                    logger.error(f"El número de documento para tipo {tipo_documento} debe tener 8 dígitos")
                    return False
            elif tipo_documento == 'PASAPORTE':
                # Pasaporte: entre 6 y 12 caracteres alfanuméricos
                if len(num_documento) < 6 or len(num_documento) > 12:
                    logger.error("El pasaporte debe tener entre 6 y 12 caracteres")
                    return False
                # Puede contener letras y números
                if not num_documento.isalnum():
                    logger.error("El pasaporte solo puede contener letras y números")
                    return False
            else:
                logger.error(f"Tipo de documento no válido: {tipo_documento}")
                return False
            
            # Validar email si se proporciona
            if email:
                if not self.validar_email(email):
                    logger.error("Formato de email inválido")
                    return False
            
            # Validar teléfono si se proporciona
            if telefono:
                if not self.validar_telefono(telefono):
                    logger.error("Formato de teléfono inválido")
                    return False
            
            # Validar fecha si se proporciona (formato YYYY-MM-DD)
            if fecha_nacimiento:
                # Verificar formato básico
                if not re.match(r'^\d{4}-\d{2}-\d{2}$', fecha_nacimiento):
                    logger.error("Formato de fecha inválido. Use YYYY-MM-DD")
                    return False
            
            # Crear cliente
            resultado = self.repositorio.crear(
                nombre.strip(), 
                apellidos.strip(), 
                fecha_nacimiento,  # Puede ser None
                tipo_documento, 
                num_documento.strip(),
                sexo.strip().upper() if sexo else None, 
                direccion.strip() if direccion else None, 
                telefono.strip() if telefono else None, 
                email.strip().lower() if email else None
            )
            
            if resultado:
                logger.info(f"Cliente creado: {nombre} {apellidos}")
                return True
            else:
                logger.error("No se pudo crear el cliente")
                return False
                
        except Exception as e:
            logger.error(f"Error al crear cliente: {e}")
            return False
    
    def actualizar(self, idcliente, nombre, apellidos, fecha_nacimiento, tipo_documento,
                   num_documento, sexo=None, direccion=None, telefono=None, email=None):
        """
        Actualiza un cliente existente
        
        Args:
            idcliente (int): ID del cliente a actualizar
            nombre (str): Nombre del cliente
            apellidos (str): Apellidos del cliente
            fecha_nacimiento (str or None): Fecha de nacimiento (YYYY-MM-DD o None)
            tipo_documento (str): Tipo de documento
            num_documento (str): Número de documento
            sexo (str, optional): Sexo
            direccion (str, optional): Dirección
            telefono (str, optional): Teléfono
            email (str, optional): Email
            
        Returns:
            bool: True si se actualizó correctamente, False en caso contrario
        """
        try:
            # Validar que el cliente existe
            cliente = self.obtener_por_id(idcliente)
            if not cliente:
                logger.error(f"Cliente {idcliente} no encontrado")
                return False
            
            # Validar campos obligatorios
            if not nombre or not nombre.strip():
                logger.error("El nombre es obligatorio")
                return False
            
            if not apellidos or not apellidos.strip():
                logger.error("Los apellidos son obligatorios")
                return False
            
            if not tipo_documento:
                logger.error("El tipo de documento es obligatorio")
                return False
            
            if not num_documento or not num_documento.strip():
                logger.error("El número de documento es obligatorio")
                return False
            
            # Validar formato del documento según el tipo
            if tipo_documento in ['V', 'E', 'J', 'G', 'C']:
                if not num_documento.isdigit():
                    logger.error(f"El número de documento para tipo {tipo_documento} debe contener solo dígitos")
                    return False
                if len(num_documento) != 8:
                    logger.error(f"El número de documento para tipo {tipo_documento} debe tener 8 dígitos")
                    return False
            elif tipo_documento == 'PASAPORTE':
                if len(num_documento) < 6 or len(num_documento) > 12:
                    logger.error("El pasaporte debe tener entre 6 y 12 caracteres")
                    return False
                if not num_documento.isalnum():
                    logger.error("El pasaporte solo puede contener letras y números")
                    return False
            else:
                logger.error(f"Tipo de documento no válido: {tipo_documento}")
                return False
            
            # Validar email si se proporciona
            if email:
                if not self.validar_email(email):
                    logger.error("Formato de email inválido")
                    return False
            
            # Validar teléfono si se proporciona
            if telefono:
                if not self.validar_telefono(telefono):
                    logger.error("Formato de teléfono inválido")
                    return False
            
            # Actualizar cliente
            resultado = self.repositorio.actualizar(
                idcliente,
                nombre.strip(), 
                apellidos.strip(), 
                fecha_nacimiento,  # Puede ser None
                tipo_documento, 
                num_documento.strip(),
                sexo.strip().upper() if sexo else None, 
                direccion.strip() if direccion else None, 
                telefono.strip() if telefono else None, 
                email.strip().lower() if email else None
            )
            
            if resultado:
                logger.info(f"Cliente {idcliente} actualizado correctamente")
                return True
            else:
                logger.error(f"No se pudo actualizar el cliente {idcliente}")
                return False
                
        except Exception as e:
            logger.error(f"Error al actualizar cliente {idcliente}: {e}")
            return False
    
    def eliminar(self, idcliente):
        """
        Elimina un cliente (lógicamente)
        
        Args:
            idcliente (int): ID del cliente a eliminar
            
        Returns:
            bool: True si se eliminó correctamente, False en caso contrario
        """
        try:
            # Validar que el cliente existe
            cliente = self.obtener_por_id(idcliente)
            if not cliente:
                logger.error(f"Cliente {idcliente} no encontrado")
                return False
            
            # Verificar si tiene ventas asociadas (esto lo haría el repositorio)
            resultado = self.repositorio.eliminar(idcliente)
            
            if resultado:
                logger.info(f"Cliente {idcliente} eliminado correctamente")
                return True
            else:
                logger.error(f"No se pudo eliminar el cliente {idcliente}")
                return False
                
        except Exception as e:
            logger.error(f"Error al eliminar cliente {idcliente}: {e}")
            return False
    
    def validar_email(self, email):
        """
        Valida el formato de un email
        
        Args:
            email (str): Email a validar
            
        Returns:
            bool: True si es válido, False en caso contrario
        """
        if not email:
            return True  # Email opcional
        
        patron = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(patron, email) is not None
    
    def validar_telefono(self, telefono):
        """
        Valida el formato de un teléfono venezolano
        
        Args:
            telefono (str): Teléfono a validar
            
        Returns:
            bool: True si es válido, False en caso contrario
        """
        if not telefono:
            return True  # Teléfono opcional
        
        # Limpiar el teléfono (quitar +, -, espacios)
        telefono_limpio = re.sub(r'[\+\-\s]', '', telefono)
        
        # Verificar que sea solo números y tenga entre 10 y 12 dígitos
        if not telefono_limpio.isdigit():
            return False
        
        if len(telefono_limpio) < 10 or len(telefono_limpio) > 12:
            return False
        
        return True
----- capa_negocio/email_service.py -----
import smtplib
import random
import string
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
from email.utils import formataddr
from loguru import logger

class EmailService:
    """Servicio para envío de correos electrónicos"""
    
    def __init__(self, smtp_server="smtp.gmail.com", smtp_port=587, 
                 email_remitente="tu_correo@gmail.com", password="tu_contraseña"):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.email_remitente = email_remitente
        self.password = password
        self.codigos_recuperacion = {}  # Para compatibilidad
    
    def generar_codigo(self, longitud=6):
        """Genera un código aleatorio de recuperación (para compatibilidad)"""
        return ''.join(random.choices(string.digits, k=longitud))
    
    def enviar_enlace_magico(self, email_destino, token, nombre_usuario):
        """Envía un enlace mágico para recuperación de contraseña"""
        try:
            # Crear mensaje con codificación UTF-8
            mensaje = MIMEMultipart('alternative')
            mensaje['From'] = formataddr((str(Header('Sistema Ventas', 'utf-8')), self.email_remitente))
            mensaje['To'] = email_destino
            mensaje['Subject'] = Header('🔐 Recuperación de contraseña - Sistema de Ventas', 'utf-8')
            
            # Versión texto plano (para clientes que no soportan HTML)
            texto_plano = f"""
Recuperación de Contraseña - Sistema de Ventas

Hola {nombre_usuario},

Has solicitado restablecer tu contraseña.

Tu token de recuperación es: {token}

Este token expirará en 30 minutos.

Instrucciones:
1. Vuelve al programa
2. Selecciona opción "Recuperar contraseña"
3. Elige "Ingresar token manual"
4. Copia y pega este token
5. Establece tu nueva contraseña

Si no solicitaste esto, ignora este mensaje.

Sistema de Ventas
"""
            
            # Versión HTML
            html = f"""
            <html>
                <head>
                    <meta charset="UTF-8">
                </head>
                <body style="font-family: Arial, sans-serif; padding: 20px; max-width: 600px;">
                    <h2 style="color: #4CAF50;">Recuperación de Contraseña</h2>
                    <p>Hola <strong>{nombre_usuario}</strong>,</p>
                    <p>Recibimos una solicitud para restablecer tu contraseña.</p>
                    
                    <div style="background-color: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center;">
                        <p style="font-size: 16px; margin-bottom: 20px;">Tu token de recuperación es:</p>
                        <div style="background-color: #333; color: #fff; padding: 15px; font-family: monospace; font-size: 18px; letter-spacing: 2px; border-radius: 5px;">
                            {token}
                        </div>
                        <p style="margin-top: 20px; font-size: 14px; color: #666;">
                            ⏰ Este token expirará en <strong>30 minutos</strong>.
                        </p>
                    </div>
                    
                    <div style="background-color: #fff3cd; border: 1px solid #ffeeba; padding: 15px; border-radius: 5px; margin: 20px 0;">
                        <p style="margin: 0; color: #856404;">
                            <strong>📝 Instrucciones:</strong><br>
                            1. Vuelve al programa<br>
                            2. Selecciona opción "Recuperar contraseña"<br>
                            3. Elige "Ingresar token manual"<br>
                            4. Copia y pega el token de arriba<br>
                            5. Establece tu nueva contraseña
                        </p>
                    </div>
                    
                    <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;">
                        <p style="margin: 0; font-size: 13px;">
                            <strong>¿No solicitaste esto?</strong><br>
                            Si no solicitaste restablecer tu contraseña, ignora este correo. 
                            Tu cuenta permanece segura.
                        </p>
                    </div>
                    
                    <hr style="border: none; border-top: 1px solid #eee;">
                    <p style="color: #999; font-size: 12px;">
                        Sistema de Ventas - 3 Capas<br>
                        Si tienes problemas, contacta al administrador.
                    </p>
                </body>
            </html>
            """
            
            # Adjuntar versiones con UTF-8 explícito
            mensaje.attach(MIMEText(texto_plano, 'plain', 'utf-8'))
            mensaje.attach(MIMEText(html, 'html', 'utf-8'))
            
            # Enviar correo
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.email_remitente, self.password)
            server.send_message(mensaje)
            server.quit()
            
            logger.success(f"📧 Enlace mágico enviado a {email_destino}")
            return True
            
        except Exception as e:
            logger.error(f"❌ Error al enviar enlace: {e}")
            return False
    
    def enviar_codigo_recuperacion(self, email_destino, codigo):
        """Versión antigua para compatibilidad"""
        return self.enviar_enlace_magico(email_destino, codigo, "Usuario")
----- capa_negocio/inventario_service.py -----
"""
Servicio para la gestión de inventario y stock - VERSIÓN CORREGIDA
"""
from loguru import logger
from capa_negocio.base_service import BaseService

class InventarioService(BaseService):
    """Servicio que implementa la lógica de negocio para inventario"""
    
    COLOR_ROJO = '\033[91m'
    COLOR_AMARILLO = '\033[93m'
    COLOR_VERDE = '\033[92m'
    COLOR_RESET = '\033[0m'
    
    def __init__(self, articulo_service):
        """
        Inicializa el servicio de inventario
        
        Args:
            articulo_service: Servicio de artículos para obtener información de productos
        """
        super().__init__()
        self.articulo_service = articulo_service
        logger.info("✅ InventarioService inicializado")
    
    def obtener_stock_articulo(self, idarticulo):
        """
        Obtiene el stock actual de un artículo desde la tabla kardex
        """
        try:
            if not self.validar_entero_positivo(idarticulo, "ID del artículo"):
                return 0
            
            # Obtener conexión
            conn = self.articulo_service.repositorio.conn
            cursor = conn.cursor()
            
            # Consultar el último stock registrado en kardex
            query = """
            SELECT TOP 1 stock_nuevo 
            FROM kardex 
            WHERE idarticulo = ? 
            ORDER BY fecha_movimiento DESC
            """
            cursor.execute(query, (idarticulo,))
            row = cursor.fetchone()
            
            if row and row[0] is not None:
                stock = row[0]
                logger.info(f"Stock del artículo {idarticulo} desde kardex: {stock} unidades")
                return stock
            else:
                # Si no hay movimientos, stock inicial = 0
                logger.warning(f"No hay registros en kardex para artículo {idarticulo}")
                return 0
            
        except Exception as e:
            logger.error(f"Error al obtener stock del artículo {idarticulo}: {e}")
            return 0
    
    def _insertar_stock_inicial(self, idarticulo):
        """
        Inserta un registro de stock inicial para un artículo
        Usa 'INGRESO' como tipo_movimiento para cumplir con la restricción CHECK
        """
        try:
            conn = self.articulo_service.repositorio.conn
            cursor = conn.cursor()
            
            # CORREGIDO: Usar 'INGRESO' en lugar de 'INICIAL' para cumplir con la restricción
            query = """
            INSERT INTO kardex 
            (idarticulo, tipo_movimiento, documento_referencia, cantidad, 
             precio_unitario, valor_total, stock_anterior, stock_nuevo, fecha_movimiento)
            VALUES (?, 'INGRESO', 'INVENTARIO INICIAL', 0, 0, 0, 0, 0, GETDATE())
            """
            cursor.execute(query, (idarticulo,))
            conn.commit()
            logger.info(f"📝 Stock inicial creado para artículo {idarticulo} (tipo: INGRESO)")
        except Exception as e:
            logger.error(f"Error al insertar stock inicial: {e}")
    
    def descontar_stock(self, idarticulo, cantidad, idventa=None, precio_unitario=None):
        """
        Descuenta stock de un artículo por una venta (ACTUALIZA KARDEX)
        
        Args:
            idarticulo (int): ID del artículo
            cantidad (int): Cantidad a descontar
            idventa (int, optional): ID de la venta asociada
            precio_unitario (float, optional): Precio de venta unitario
            
        Returns:
            bool: True si se descontó correctamente, False en caso contrario
        """
        try:
            # Validaciones
            if not self.validar_entero_positivo(idarticulo, "ID del artículo"):
                return False
            
            if not self.validar_entero_positivo(cantidad, "Cantidad a descontar"):
                return False
            
            # Obtener stock actual
            stock_actual = self.obtener_stock_articulo(idarticulo)
            
            if stock_actual < cantidad:
                logger.error(f"Stock insuficiente. Disponible: {stock_actual}, Solicitado: {cantidad}")
                return False
            
            # Calcular nuevo stock
            stock_nuevo = stock_actual - cantidad
            
            # Calcular valor total
            valor_total = cantidad * precio_unitario if precio_unitario else 0
            
            # Insertar en kardex
            conn = self.articulo_service.repositorio.conn
            cursor = conn.cursor()
            
            documento = f"VENTA-{idventa}" if idventa else "VENTA-DIRECTA"
            
            query = """
            INSERT INTO kardex 
            (idarticulo, tipo_movimiento, documento_referencia, cantidad, 
             precio_unitario, valor_total, stock_anterior, stock_nuevo, fecha_movimiento)
            VALUES (?, 'VENTA', ?, ?, ?, ?, ?, ?, GETDATE())
            """
            
            cursor.execute(query, (idarticulo, documento, cantidad, precio_unitario, valor_total, stock_actual, stock_nuevo))
            conn.commit()
            
            logger.info(f"✅ Descontando {cantidad} unidades del artículo {idarticulo}")
            logger.info(f"   Stock: {stock_actual} → {stock_nuevo}")
            if precio_unitario:
                logger.info(f"   Precio unitario: Bs. {precio_unitario:.2f}")
                logger.info(f"   Valor total: Bs. {valor_total:.2f}")
            if idventa:
                logger.info(f"   Venta asociada: #{idventa}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error al descontar stock del artículo {idarticulo}: {e}")
            return False
    
    def reponer_stock(self, idarticulo, cantidad, idingreso=None, precio_compra=None):
        """
        Repone stock de un artículo por un ingreso (ACTUALIZA KARDEX)
        
        Args:
            idarticulo (int): ID del artículo
            cantidad (int): Cantidad a reponer
            idingreso (int, optional): ID del ingreso asociado
            precio_compra (float, optional): Precio de compra unitario
            
        Returns:
            bool: True si se repuso correctamente, False en caso contrario
        """
        try:
            # Validaciones
            if not self.validar_entero_positivo(idarticulo, "ID del artículo"):
                return False
            
            if not self.validar_entero_positivo(cantidad, "Cantidad a reponer"):
                return False
            
            # Obtener stock actual
            stock_actual = self.obtener_stock_articulo(idarticulo)
            stock_nuevo = stock_actual + cantidad
            
            # Calcular valor total
            valor_total = cantidad * precio_compra if precio_compra else 0
            
            # Insertar en kardex
            conn = self.articulo_service.repositorio.conn
            cursor = conn.cursor()
            
            documento = f"INGRESO-{idingreso}" if idingreso else "INGRESO-MANUAL"
            
            query = """
            INSERT INTO kardex 
            (idarticulo, tipo_movimiento, documento_referencia, cantidad, 
             precio_unitario, valor_total, stock_anterior, stock_nuevo, fecha_movimiento)
            VALUES (?, 'INGRESO', ?, ?, ?, ?, ?, ?, GETDATE())
            """
            
            cursor.execute(query, (idarticulo, documento, cantidad, precio_compra, valor_total, stock_actual, stock_nuevo))
            conn.commit()
            
            logger.info(f"✅ Reponiendo {cantidad} unidades del artículo {idarticulo}")
            logger.info(f"   Stock: {stock_actual} → {stock_nuevo}")
            if precio_compra:
                logger.info(f"   Precio compra: Bs. {precio_compra:.2f}")
                logger.info(f"   Valor total: Bs. {valor_total:.2f}")
            if idingreso:
                logger.info(f"   Ingreso asociado: #{idingreso}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error al reponer stock del artículo {idarticulo}: {e}")
            return False
    
    def obtener_nivel_stock(self, stock_actual):
        """
        Determina el nivel de stock (CRÍTICO, BAJO, NORMAL)
        
        Args:
            stock_actual (int): Stock actual del artículo
            
        Returns:
            dict: Nivel de stock con color y mensaje
        """
        if stock_actual < 3:
            return {
                'nivel': 'CRÍTICO',
                'color': self.COLOR_ROJO,
                'emoji': '🔴',
                'mensaje': '¡URGENTE! Reponer stock inmediatamente'
            }
        elif stock_actual < 6:
            return {
                'nivel': 'BAJO',
                'color': self.COLOR_AMARILLO,
                'emoji': '🟡',
                'mensaje': 'Stock bajo, considerar reposición'
            }
        else:
            return {
                'nivel': 'NORMAL',
                'color': self.COLOR_VERDE,
                'emoji': '🟢',
                'mensaje': 'Stock normal'
            }
    
    def listar_con_stock(self):
        """
        Lista todos los artículos con su stock actual y nivel
        """
        try:
            articulos = self.articulo_service.listar()
            resultado = []
            
            for art in articulos:
                stock = self.obtener_stock_articulo(art['idarticulo'])
                nivel = self.obtener_nivel_stock(stock)
                
                resultado.append({
                    'idarticulo': art['idarticulo'],
                    'codigo': art['codigo'],
                    'nombre': art['nombre'],
                    'categoria': art.get('categoria', 'Sin categoría'),
                    'precio_venta': art.get('precio_venta', 0),
                    'stock_actual': stock,
                    'nivel_stock': nivel['nivel'],
                    'color': nivel['color'],
                    'emoji': nivel['emoji'],
                    'mensaje': nivel['mensaje']
                })
            
            return resultado
            
        except Exception as e:
            logger.error(f"Error al listar artículos con stock: {e}")
            return []
    
    def mostrar_tabla_stock(self):
        """
        Genera una tabla formateada del stock actual
        
        Returns:
            str: Tabla formateada para mostrar en consola
        """
        articulos = self.listar_con_stock()
        
        if not articulos:
            return "📭 No hay artículos registrados"
        
        lineas = []
        lineas.append(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'STOCK':<10} {'ESTADO':<15}")
        lineas.append("-" * 75)
        
        for art in articulos:
            linea = f"{art['idarticulo']:<5} {art['codigo']:<15} {art['nombre']:<30} {art['stock_actual']:<10} {art['emoji']} {art['nivel_stock']}"
            lineas.append(f"{art['color']}{linea}{self.COLOR_RESET}")
        
        return "\n".join(lineas)
    
    def mostrar_resumen_stock(self):
        """
        Muestra un resumen del inventario
        
        Returns:
            str: Resumen formateado
        """
        articulos = self.listar_con_stock()
        
        if not articulos:
            return "📭 No hay artículos registrados"
        
        total_articulos = len(articulos)
        criticos = sum(1 for a in articulos if a['nivel_stock'] == 'CRÍTICO')
        bajos = sum(1 for a in articulos if a['nivel_stock'] == 'BAJO')
        normales = sum(1 for a in articulos if a['nivel_stock'] == 'NORMAL')
        stock_total = sum(a['stock_actual'] for a in articulos)
        
        resumen = []
        resumen.append("📊 RESUMEN DE INVENTARIO")
        resumen.append("=" * 40)
        resumen.append(f"Total artículos: {total_articulos}")
        resumen.append(f"Stock total: {stock_total} unidades")
        resumen.append("")
        resumen.append(f"{self.COLOR_ROJO}🔴 Críticos: {criticos}{self.COLOR_RESET}")
        resumen.append(f"{self.COLOR_AMARILLO}🟡 Bajos: {bajos}{self.COLOR_RESET}")
        resumen.append(f"{self.COLOR_VERDE}🟢 Normales: {normales}{self.COLOR_RESET}")
        
        if criticos > 0:
            resumen.append("")
            resumen.append(f"{self.COLOR_ROJO}⚠️ Artículos críticos:{self.COLOR_RESET}")
            for art in articulos:
                if art['nivel_stock'] == 'CRÍTICO':
                    resumen.append(f"   - {art['nombre']} (Stock: {art['stock_actual']})")
        
        return "\n".join(resumen)
    
    def obtener_alertas_stock(self):
        """
        Obtiene alertas de stock bajo y crítico
        
        Returns:
            list: Lista de alertas formateadas
        """
        articulos = self.listar_con_stock()
        alertas = []
        
        for art in articulos:
            if art['nivel_stock'] == 'CRÍTICO':
                alertas.append(f"{self.COLOR_ROJO}🔴 {art['nombre']} - Stock CRÍTICO ({art['stock_actual']} und){self.COLOR_RESET}")
            elif art['nivel_stock'] == 'BAJO':
                alertas.append(f"{self.COLOR_AMARILLO}🟡 {art['nombre']} - Stock BAJO ({art['stock_actual']} und){self.COLOR_RESET}")
        
        return alertas
    
    def verificar_stock_para_venta(self, items):
        """
        Verifica si hay stock suficiente para una venta
        
        Args:
            items (list): Lista de items con idarticulo y cantidad
            
        Returns:
            tuple: (bool, list) - (aprobado, lista de errores)
        """
        errores = []
        for item in items:
            stock = self.obtener_stock_articulo(item['idarticulo'])
            if item['cantidad'] > stock:
                errores.append(f"Artículo {item['idarticulo']}: requiere {item['cantidad']}, disponible {stock}")
        
        return len(errores) == 0, errores
----- capa_negocio/proveedor_service.py -----
from typing import List, Dict, Optional
from loguru import logger
from capa_negocio.base_service import BaseService
from capa_negocio.validacion_venezuela import ValidacionVenezuela

class ProveedorService(BaseService):
    """Servicio para gestión de proveedores con validación venezolana"""
    
    def __init__(self, repositorio):
        self.repositorio = repositorio
    
    def listar(self) -> List[Dict]:
        """Lista todos los proveedores"""
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"❌ Error al listar proveedores: {e}")
            return []
    
    def obtener_por_id(self, idproveedor: int) -> Optional[Dict]:
        """Obtiene un proveedor por ID"""
        if not self.validar_entero_positivo(idproveedor, "ID de proveedor"):
            return None
        return self.repositorio.obtener_por_id(idproveedor)
    
    def _validar_documento_venezolano(self, tipo_doc: str, num_doc: str) -> bool:
        """
        Valida documentos venezolanos para proveedores
        - Personas naturales: V (venezolano), E (extranjero) → cédula
        - Personas jurídicas: J (empresa), G (gobierno), C (consejo comunal) → RIF
        - Pasaporte: PASAPORTE
        """
        tipo_doc = tipo_doc.upper()
        
        # Validar según el tipo de documento
        if tipo_doc in ['V', 'E']:
            # Cédula venezolana o extranjera
            if not ValidacionVenezuela.validar_cedula(num_doc):
                logger.warning(f"⚠️ Cédula '{num_doc}' inválida para tipo {tipo_doc}")
                return False
        
        elif tipo_doc in ['J', 'G', 'C']:
            # RIF de empresa, gobierno o consejo comunal
            rif_completo = f"{tipo_doc}-{num_doc}"
            if not ValidacionVenezuela.validar_rif(rif_completo):
                logger.warning(f"⚠️ RIF '{rif_completo}' inválido")
                return False
        
        elif tipo_doc == 'PASAPORTE':
            # Pasaporte (validación básica)
            if len(num_doc) < 6 or len(num_doc) > 12:
                logger.warning("⚠️ Pasaporte debe tener entre 6 y 12 caracteres")
                return False
        
        else:
            logger.warning(f"⚠️ Tipo de documento '{tipo_doc}' no válido")
            return False
        
        return True
    
    def crear(self, razon_social: str, sector_comercial: str,
              tipo_documento: str, num_documento: str,
              direccion: str = None, telefono: str = None,
              email: str = None, url: str = None) -> bool:
        """Crea un nuevo proveedor con validaciones"""
        
        # Validaciones básicas
        if not self.validar_requerido(razon_social, "razón social"):
            return False
        if not self.validar_requerido(sector_comercial, "sector comercial"):
            return False
        if not self.validar_requerido(tipo_documento, "tipo de documento"):
            return False
        if not self.validar_requerido(num_documento, "número de documento"):
            return False
        
        # Validación de longitud
        if not self.validar_longitud(razon_social, "razón social", max_len=150):
            return False
        
        # Validación de email si se proporciona
        if email and not self.validar_email(email):
            return False
        
        # Validación de teléfono si se proporciona
        if telefono and not self.validar_telefono(telefono):
            return False
        
        # Validación de documento venezolano
        if not self._validar_documento_venezolano(tipo_documento, num_documento):
            return False
        
        try:
            return self.repositorio.insertar(
                razon_social.strip(), sector_comercial.strip(),
                tipo_documento, num_documento.strip(),
                direccion, telefono, email, url
            )
        except Exception as e:
            logger.error(f"❌ Error al crear proveedor: {e}")
            return False
    
    def actualizar(self, idproveedor: int, razon_social: str, sector_comercial: str,
                   tipo_documento: str, num_documento: str,
                   direccion: str = None, telefono: str = None,
                   email: str = None, url: str = None) -> bool:
        """Actualiza un proveedor existente"""
        
        if not self.validar_entero_positivo(idproveedor, "ID de proveedor"):
            return False
        
        # Validaciones básicas
        if not self.validar_requerido(razon_social, "razón social"):
            return False
        if not self.validar_requerido(sector_comercial, "sector comercial"):
            return False
        if not self.validar_requerido(tipo_documento, "tipo de documento"):
            return False
        if not self.validar_requerido(num_documento, "número de documento"):
            return False
        
        # Validación de documento venezolano
        if not self._validar_documento_venezolano(tipo_documento, num_documento):
            return False
        
        if email and not self.validar_email(email):
            return False
        
        if telefono and not self.validar_telefono(telefono):
            return False
        
        try:
            return self.repositorio.actualizar(
                idproveedor, razon_social.strip(), sector_comercial.strip(),
                tipo_documento, num_documento.strip(),
                direccion, telefono, email, url
            )
        except Exception as e:
            logger.error(f"❌ Error al actualizar proveedor: {e}")
            return False
    
    def eliminar(self, idproveedor: int) -> bool:
        """Elimina un proveedor"""
        if not self.validar_entero_positivo(idproveedor, "ID de proveedor"):
            return False
        return self.repositorio.eliminar(idproveedor)
----- capa_negocio/ingreso_service.py -----
from typing import List, Dict, Optional
from datetime import datetime
from loguru import logger
from capa_negocio.base_service import BaseService

class IngresoService(BaseService):
    """Servicio para gestión de ingresos de mercancía"""
    
    def __init__(self, repositorio, articulo_service=None, proveedor_service=None, trabajador_service=None):
        self.repositorio = repositorio
        self.articulo_service = articulo_service
        self.proveedor_service = proveedor_service
        self.trabajador_service = trabajador_service
    
    def listar_ingresos(self) -> List[Dict]:
        """Lista todos los ingresos"""
        try:
            return self.repositorio.listar()
        except Exception as e:
            logger.error(f"❌ Error al listar ingresos: {e}")
            return []
    
    def obtener_ingreso(self, idingreso: int) -> Optional[Dict]:
        """Obtiene un ingreso por ID con su detalle"""
        if not self.validar_entero_positivo(idingreso, "ID de ingreso"):
            return None
        try:
            return self.repositorio.obtener_por_id(idingreso)
        except Exception as e:
            logger.error(f"❌ Error al obtener ingreso {idingreso}: {e}")
            return None
    
    def registrar_ingreso(self, idtrabajador: int, idproveedor: int,
                          tipo_comprobante: str, serie: str, numero_comprobante: str,
                          igv: float, detalle: List[Dict] = None,
                          fecha: datetime = None) -> Optional[int]:
        """
        Registra un nuevo ingreso con su detalle
        detalle: lista de dict con idarticulo, cantidad, precio_compra
        """
        
        # Validaciones básicas
        if not self.validar_entero_positivo(idtrabajador, "trabajador"):
            logger.warning("⚠️ ID de trabajador inválido")
            return None
        if not self.validar_entero_positivo(idproveedor, "proveedor"):
            logger.warning("⚠️ ID de proveedor inválido")
            return None
        if not self.validar_requerido(tipo_comprobante, "tipo de comprobante"):
            logger.warning("⚠️ Tipo de comprobante requerido")
            return None
        if not self.validar_requerido(serie, "serie"):
            logger.warning("⚠️ Serie requerida")
            return None
        if not self.validar_requerido(numero_comprobante, "número de comprobante"):
            logger.warning("⚠️ Número de comprobante requerido")
            return None
        if not self.validar_decimal_positivo(igv, "IGV", permitir_cero=True):
            logger.warning("⚠️ IGV inválido")
            return None
        
        # Validar que existan proveedor y trabajador
        if self.proveedor_service:
            proveedor = self.proveedor_service.obtener_por_id(idproveedor)
            if not proveedor:
                logger.warning(f"⚠️ El proveedor {idproveedor} no existe")
                return None
        
        if self.trabajador_service:
            trabajador = self.trabajador_service.obtener_por_id(idtrabajador)
            if not trabajador:
                logger.warning(f"⚠️ El trabajador {idtrabajador} no existe")
                return None
        
        # Validar detalle
        if not detalle or len(detalle) == 0:
            logger.warning("⚠️ El ingreso debe tener al menos un artículo")
            return None
        
        total = 0
        for item in detalle:
            # Validar artículo
            if not self.validar_entero_positivo(item.get('idarticulo'), "ID de artículo"):
                logger.warning(f"⚠️ ID de artículo inválido: {item.get('idarticulo')}")
                return None
            if not self.validar_entero_positivo(item.get('cantidad'), "cantidad"):
                logger.warning(f"⚠️ Cantidad inválida: {item.get('cantidad')}")
                return None
            if not self.validar_decimal_positivo(item.get('precio_compra'), "precio de compra"):
                logger.warning(f"⚠️ Precio de compra inválido: {item.get('precio_compra')}")
                return None
            
            # Verificar que el artículo existe
            if self.articulo_service:
                articulo = self.articulo_service.obtener_por_id(item['idarticulo'])
                if not articulo:
                    logger.warning(f"⚠️ El artículo {item['idarticulo']} no existe")
                    return None
            
            # Calcular subtotal
            subtotal = item['cantidad'] * item['precio_compra']
            total += subtotal
            logger.info(f"   - Artículo ID {item['idarticulo']}: {item['cantidad']} und @ Bs.{item['precio_compra']:.2f} = Bs.{subtotal:.2f}")
        
        logger.info(f"💰 Total del ingreso: Bs.{total:.2f}")
        
        try:
            # Registrar el ingreso
            if not fecha:
                fecha = datetime.now()
            
            idingreso = self.repositorio.insertar(
                idtrabajador, idproveedor, tipo_comprobante,
                serie, numero_comprobante, igv,
                fecha=fecha, detalle=detalle
            )
            
            if idingreso:
                logger.success(f"✅ Ingreso #{idingreso} registrado con {len(detalle)} productos")
                logger.info(f"📦 Stock actualizado automáticamente")
                return idingreso
            else:
                logger.error("❌ No se pudo insertar el ingreso en la base de datos")
                return None
                
        except Exception as e:
            logger.error(f"❌ Error al registrar ingreso: {e}")
            return None
    
    def anular_ingreso(self, idingreso: int) -> bool:
        """Anula un ingreso"""
        if not self.validar_entero_positivo(idingreso, "ID de ingreso"):
            return False
        try:
            return self.repositorio.anular(idingreso)
        except Exception as e:
            logger.error(f"❌ Error al anular ingreso {idingreso}: {e}")
            return False
----- capa_presentacion/menu_principal.py -----
#!/usr/bin/env python3
"""
Menú principal del sistema de ventas (Interfaz de consola)
"""
import os
import sys
import readchar
from datetime import datetime

# Añadir el directorio padre al path para importar módulos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from capa_datos.conexion import ConexionDB
from capa_datos.categoria_repo import CategoriaRepositorio
from capa_datos.cliente_repo import ClienteRepositorio
from capa_datos.articulo_repo import ArticuloRepositorio
from capa_datos.proveedor_repo import ProveedorRepositorio
from capa_datos.trabajador_repo import TrabajadorRepositorio
from capa_datos.venta_repo import VentaRepositorio
from capa_datos.ingreso_repo import IngresoRepositorio
from capa_datos.lote_repo import LoteRepositorio
from capa_datos.rol_repo import RolRepositorio
from capa_datos.usuario_admin_repo import UsuarioAdminRepositorio
from capa_datos.proveedor_archivo_repo import ProveedorArchivoRepositorio

from capa_negocio.categoria_service import CategoriaService
from capa_negocio.cliente_service import ClienteService
from capa_negocio.articulo_service import ArticuloService
from capa_negocio.trabajador_service import TrabajadorService
from capa_negocio.venta_service import VentaService
from capa_negocio.rol_service import RolService, PermisoDenegadoError
from capa_negocio.base_service import BaseService
from capa_negocio.email_service import EmailService
from capa_negocio.usuario_admin_service import UsuarioAdminService
from capa_negocio.token_service import TokenService
from capa_negocio.proveedor_service import ProveedorService
from capa_negocio.validacion_venezuela import ValidacionVenezuela
from capa_negocio.inventario_service import InventarioService
from capa_negocio.ingreso_service import IngresoService
from capa_negocio.proveedor_archivo_service import ProveedorArchivoService
from capa_negocio.reporte_contable_service import ReporteContableService

# Importaciones para SENIAT y auditoría
from capa_datos.auditoria_repo import AuditoriaRepositorio
from capa_datos.tasa_repo import TasaRepositorio
from capa_negocio.auditoria_service import AuditoriaService
from config.seniat_config import SENIAT_CONFIG, TECLAS_ATAJO, MENSAJES_LEGALES

from capa_presentacion.decoradores import requiere_permiso
from capa_presentacion.input_con_mascara import leer_con_mascara

from loguru import logger

# Configurar logger
logger.remove()
logger.add(sys.stderr, format="<level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>")

class SistemaVentas:
    """Clase principal del sistema"""
    
    # Colores para la terminal
    COLOR_ROJO = '\033[91m'
    COLOR_VERDE = '\033[92m'
    COLOR_AMARILLO = '\033[93m'
    COLOR_AZUL = '\033[94m'
    COLOR_MAGENTA = '\033[95m'
    COLOR_CYAN = '\033[96m'
    COLOR_NARANJA = '\033[38;5;208m'
    COLOR_RESET = '\033[0m'
    COLOR_NEGRITA = '\033[1m'
    
    def __init__(self):
        self.db = ConexionDB()
        self.conn = None
        self.trabajador_service = None
        self.categoria_service = None
        self.cliente_service = None
        self.articulo_service = None
        self.proveedor_service = None
        self.proveedor_archivo_service = None
        self.venta_service = None
        self.rol_service = None
        self.email_service = None
        self.usuario_admin_service = None
        self.token_service = None
        self.inventario_service = None
        self.ingreso_service = None
        self.auditoria_service = None
    
    def conectar_db(self):
        """Establece conexión con la base de datos"""
        self.conn = self.db.conectar()
        if not self.conn:
            print("❌ No se pudo conectar a la base de datos")
            return False
        
        # Inicializar repositorios
        trabajador_repo = TrabajadorRepositorio(self.conn)
        categoria_repo = CategoriaRepositorio(self.conn)
        cliente_repo = ClienteRepositorio(self.conn)
        articulo_repo = ArticuloRepositorio(self.conn)
        proveedor_repo = ProveedorRepositorio(self.conn)
        venta_repo = VentaRepositorio(self.conn)
        ingreso_repo = IngresoRepositorio(self.conn)
        rol_repo = RolRepositorio(self.conn)
        usuario_admin_repo = UsuarioAdminRepositorio(self.conn)
        proveedor_archivo_repo = ProveedorArchivoRepositorio(self.conn)
        
        # Inicializar repositorio de tasas
        from capa_datos.tasa_repo import TasaRepositorio
        tasa_repo = TasaRepositorio(self.conn)
        
        # Inicializar servicios base
        self.trabajador_service = TrabajadorService(trabajador_repo)
        self.categoria_service = CategoriaService(categoria_repo)
        self.cliente_service = ClienteService(cliente_repo)
        self.articulo_service = ArticuloService(articulo_repo, self.categoria_service)
        self.proveedor_service = ProveedorService(proveedor_repo)
        self.proveedor_archivo_service = ProveedorArchivoService(proveedor_archivo_repo, self.proveedor_service)
        
        # Inicializar inventario
        self.inventario_service = InventarioService(self.articulo_service)
        logger.info("✅ InventarioService inicializado")
        
        # Inicializar venta con soporte de tasas
        self.venta_service = VentaService(
            venta_repo, 
            self.cliente_service, 
            self.trabajador_service, 
            self.inventario_service,
            tasa_repo=tasa_repo
        )
        logger.info("✅ VentaService inicializado con soporte de tasas")
        
        self.ingreso_service = IngresoService(
            ingreso_repo, 
            self.articulo_service, 
            self.proveedor_service,
            self.trabajador_service
        )
        self.rol_service = RolService(rol_repo)
        self.usuario_admin_service = UsuarioAdminService(usuario_admin_repo, self.rol_service)
        self.token_service = TokenService(self.conn)
        
        self.trabajador_service.rol_service = self.rol_service
        
        self.email_service = EmailService(
            smtp_server="smtp.gmail.com",
            smtp_port=587,
            email_remitente="carlosberenguel554@gmail.com",
            password="fhnh tiax mfus fmok"
        )
        
        # Inicializar servicio de auditoría
        from capa_datos.auditoria_repo import AuditoriaRepositorio
        from capa_negocio.auditoria_service import AuditoriaService
        auditoria_repo = AuditoriaRepositorio(self.conn)
        self.auditoria_service = AuditoriaService(auditoria_repo)
        logger.info("✅ Servicio de auditoría inicializado")
        
        # Inicializar servicio de reportes contables
        from capa_negocio.reporte_contable_service import ReporteContableService
        self.reporte_service = ReporteContableService(
            self.venta_service,
            self.inventario_service
        )
        logger.info("✅ ReporteContableService inicializado")
        
        return True
    
    def limpiar_pantalla(self):
        """Limpia la pantalla de la consola"""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def pausa(self):
        """Pausa la ejecución hasta que el usuario presione Enter"""
        input(f"\n{self.COLOR_AMARILLO}🔹 Presione Enter para continuar...{self.COLOR_RESET}")
    
    def obtener_tasas_actuales(self):
        """
        Obtiene las tasas de cambio actuales del sistema
        Returns:
            dict: Diccionario con tasas de USD y EUR
        """
        tasas = {'USD': None, 'EUR': None}
        
        try:
            # Intentar obtener tasas desde el servicio de ventas
            if hasattr(self, 'venta_service') and self.venta_service and hasattr(self.venta_service, 'tasa_service'):
                if self.venta_service.tasa_service:
                    tasas['USD'] = self.venta_service.tasa_service.obtener_tasa_del_dia('USD')
                    tasas['EUR'] = self.venta_service.tasa_service.obtener_tasa_del_dia('EUR')
            else:
                # Fallback: consulta directa a BD
                if hasattr(self, 'conn') and self.conn:
                    tasa_repo = TasaRepositorio(self.conn)
                    tasas['USD'] = tasa_repo.obtener_ultima_tasa('USD')
                    tasas['EUR'] = tasa_repo.obtener_ultima_tasa('EUR')
        except Exception as e:
            logger.error(f"Error obteniendo tasas para menú: {e}")
        
        return tasas

    def obtener_fecha_hora_actual(self):
        """
        Retorna la fecha y hora actual formateada
        Returns:
            tuple: (dia_semana, fecha, hora)
        """
        ahora = datetime.now()
        dias_semana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"]
        dia_semana = dias_semana[ahora.weekday()]
        fecha = ahora.strftime("%d/%m/%Y")
        hora = ahora.strftime("%I:%M:%S %p")
        return dia_semana, fecha, hora

    def registrar_auditoria(self, accion, tabla, registro_id, datos_anteriores=None, datos_nuevos=None):
        """
        Registra una acción en el log de auditoría
        """
        try:
            usuario_actual = self.trabajador_service.get_usuario_actual()
            if usuario_actual:
                usuario_nombre = f"{usuario_actual['nombre']} {usuario_actual['apellidos']}"
            else:
                usuario_nombre = "SISTEMA"
            
            if self.auditoria_service:
                self.auditoria_service.registrar(
                    usuario=usuario_nombre,
                    accion=accion,
                    tabla=tabla,
                    registro_id=registro_id,
                    datos_anteriores=datos_anteriores,
                    datos_nuevos=datos_nuevos
                )
        except Exception as e:
            logger.error(f"Error registrando auditoría: {e}")
    
    def mostrar_cabecera(self, titulo):
        """Muestra una cabecera formateada con color"""
        self.limpiar_pantalla()
        print(f"{self.COLOR_AZUL}{'=' * 60}{self.COLOR_RESET}")
        print(f"{self.COLOR_NEGRITA}{titulo:^60}{self.COLOR_RESET}")
        print(f"{self.COLOR_AZUL}{'=' * 60}{self.COLOR_RESET}")
        print()
    
    def mostrar_menu_principal(self):
        """Muestra el menú principal con fecha, hora, tasas de cambio y colores"""
        self.limpiar_pantalla()
        
        dia_semana, fecha, hora = self.obtener_fecha_hora_actual()
        
        # Obtener tasas de cambio
        tasas = self.obtener_tasas_actuales()
        
        # Línea superior
        print(f"{self.COLOR_AZUL}╔" + "═" * 78 + f"╗{self.COLOR_RESET}")
        
        # Título centrado
        titulo = "SISTEMA DE VENTAS - 3 CAPAS"
        espacios_izq = (78 - len(titulo)) // 2
        espacios_der = 78 - len(titulo) - espacios_izq
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{' ' * espacios_izq}{self.COLOR_NEGRITA}{titulo}{self.COLOR_RESET}{' ' * espacios_der}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea separadora
        print(f"{self.COLOR_AZUL}╠" + "═" * 78 + f"╣{self.COLOR_RESET}")
        
        # Fecha y hora
        fecha_hora_str = f"   {self.COLOR_VERDE}📅 {dia_semana}, {fecha}{self.COLOR_RESET}  {self.COLOR_AMARILLO}⏰ {hora}{self.COLOR_RESET}  {self.COLOR_NARANJA}🇻🇪 Hora Local{self.COLOR_RESET}"
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{fecha_hora_str:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea separadora
        print(f"{self.COLOR_AZUL}╠" + "═" * 78 + f"╣{self.COLOR_RESET}")
        
        # Tasas de cambio
        linea_tasas = f"   {self.COLOR_AMARILLO}💱 TASAS DEL DÍA:{self.COLOR_RESET}"
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{linea_tasas:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        if tasas['USD']:
            linea_usd = f"      {self.COLOR_VERDE}💵 USD:{self.COLOR_RESET} 1 = {self.COLOR_AMARILLO}Bs. {tasas['USD']:.2f}{self.COLOR_RESET}"
        else:
            linea_usd = f"      {self.COLOR_VERDE}💵 USD:{self.COLOR_RESET} {self.COLOR_ROJO}No registrada{self.COLOR_RESET}"
        
        if tasas['EUR']:
            linea_eur = f"      {self.COLOR_VERDE}💶 EUR:{self.COLOR_RESET} 1 = {self.COLOR_AMARILLO}Bs. {tasas['EUR']:.2f}{self.COLOR_RESET}"
        else:
            linea_eur = f"      {self.COLOR_VERDE}💶 EUR:{self.COLOR_RESET} {self.COLOR_ROJO}No registrada{self.COLOR_RESET}"
        
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{linea_usd:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{linea_eur:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # NUEVA OPCIÓN PARA MODIFICAR TASAS
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}      {self.COLOR_AMARILLO}[X]{self.COLOR_RESET} Modificar tasas de cambio{' ' * 54}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea separadora
        print(f"{self.COLOR_AZUL}╠" + "═" * 78 + f"╣{self.COLOR_RESET}")
        
        # Información de usuario
        usuario = self.trabajador_service.get_usuario_actual()
        if usuario:
            rol_nombre = "Sin rol"
            if usuario.get('idrol'):
                rol = self.rol_service.repositorio.obtener_rol(usuario['idrol'])
                if rol:
                    rol_nombre = rol['nombre']
            
            usuario_str = f"   👤 Usuario: {self.COLOR_VERDE}{usuario['nombre']} {usuario['apellidos']} [{rol_nombre}]{self.COLOR_RESET}"
            permisos_str = f"   🔑 Permisos: {self.COLOR_AMARILLO}{len(self.rol_service.get_permisos_usuario())} activos{self.COLOR_RESET}"
            
            print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{usuario_str:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
            print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{permisos_str:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        else:
            usuario_str = f"   👤 Usuario: {self.COLOR_AMARILLO}No autenticado{self.COLOR_RESET}"
            print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{usuario_str:<78}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea separadora
        print(f"{self.COLOR_AZUL}╠" + "═" * 78 + f"╣{self.COLOR_RESET}")
        
        # Título del menú
        menu_titulo = "MENÚ PRINCIPAL"
        espacios_izq_menu = (78 - len(menu_titulo)) // 2
        espacios_der_menu = 78 - len(menu_titulo) - espacios_izq_menu
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{' ' * espacios_izq_menu}{self.COLOR_NEGRITA}{menu_titulo}{self.COLOR_RESET}{' ' * espacios_der_menu}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea separadora
        print(f"{self.COLOR_AZUL}╠" + "═" * 78 + f"╣{self.COLOR_RESET}")
        
        # Opciones del menú
        opciones = []
        
        if not usuario or self.rol_service.tiene_permiso('clientes_ver'):
            opciones.append(("1", "Gestión de Clientes", "👥"))
        if not usuario or self.rol_service.tiene_permiso('articulos_ver'):
            opciones.append(("2", "Gestión de Artículos", "📦"))
        if not usuario or self.rol_service.tiene_permiso('proveedores_ver'):
            opciones.append(("3", "Gestión de Proveedores", "🏢"))
        if not usuario or self.rol_service.tiene_permiso('ventas_ver'):
            opciones.append(("4", "Gestión de Ventas", "💰"))
        if not usuario or self.rol_service.tiene_permiso('inventario_ver'):
            opciones.append(("5", "Gestión de Inventario", "📊"))
        if not usuario or self.rol_service.tiene_permiso('reportes_ventas'):
            opciones.append(("6", "Reportes Contables", "📈"))
        if usuario and self.rol_service.tiene_permiso('usuarios_ver'):
            opciones.append(("7", "Administración de Usuarios", "👤"))
        
        for num, desc, icono in opciones:
            linea_opcion = f"   {icono} {num}. {desc}"
            espacios = 78 - len(linea_opcion)
            print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{linea_opcion}{' ' * espacios}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea separadora
        print(f"{self.COLOR_AZUL}╠" + "═" * 78 + f"╣{self.COLOR_RESET}")
        
        # Opción de sesión
        if usuario:
            linea_sesion = f"   🔑 8. Cerrar Sesión"
        else:
            linea_sesion = f"   🔑 8. Iniciar Sesión"
        espacios_sesion = 78 - len(linea_sesion)
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{linea_sesion}{' ' * espacios_sesion}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Opción de salir
        linea_salir = f"   ❌ 0. Salir"
        espacios_salir = 78 - len(linea_salir)
        print(f"{self.COLOR_AZUL}║{self.COLOR_RESET}{linea_salir}{' ' * espacios_salir}{self.COLOR_AZUL}║{self.COLOR_RESET}")
        
        # Línea inferior
        print(f"{self.COLOR_AZUL}╚" + "═" * 78 + f"╝{self.COLOR_RESET}")
        print()
        
        return input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
        
        return input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()

    def menu_login(self):
        """Menú de inicio de sesión con opción de recuperación"""
        while True:
            self.mostrar_cabecera("INICIAR SESIÓN")
            
            print("1. Iniciar sesión")
            print("2. ¿Olvidaste tu contraseña?")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._login_normal()
                break
            elif opcion == '2':
                self._recuperar_contraseña()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    def _login_normal(self):
        """Login normal con email y contraseña"""
        self.mostrar_cabecera("INICIAR SESIÓN POR EMAIL")
        
        print("🔐 Ingrese sus credenciales")
        print()
        email = input("Email: ")
        password = input("Contraseña: ")
        
        if self.trabajador_service.login_por_email(email, password):
            print(f"{self.COLOR_VERDE}✅ Sesión iniciada correctamente{self.COLOR_RESET}")
            self.registrar_auditoria(
                accion="LOGIN",
                tabla="trabajador",
                registro_id=self.trabajador_service.get_usuario_actual()['idtrabajador'],
                datos_nuevos=f"Login exitoso - Email: {email}"
            )
        else:
            print(f"{self.COLOR_ROJO}❌ Email o contraseña incorrectos{self.COLOR_RESET}")
        
        self.pausa()
    
    def _recuperar_contraseña(self):
        """Proceso de recuperación con enlace mágico"""
        while True:
            self.mostrar_cabecera("RECUPERAR CONTRASEÑA")
            
            print("1. Solicitar enlace mágico por email")
            print("2. Ya tengo un token, ingresar manualmente")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._solicitar_enlace_magico()
            elif opcion == '2':
                self._ingresar_token_manual()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    def _solicitar_enlace_magico(self):
        """Solicita un enlace mágico por email"""
        self.mostrar_cabecera("SOLICITAR ENLACE MÁGICO")
        
        email = input("Ingrese su email registrado: ")
        
        usuario = self.trabajador_service.buscar_por_email(email)
        
        if not usuario:
            print("❌ No existe un usuario con ese email")
            self.pausa()
            return
        
        print(f"\n👤 Usuario encontrado: {usuario['nombre']} {usuario['apellidos']}")
        print(f"📧 Email: {usuario['email']}")
        print()
        
        token = self.token_service.crear_token(usuario['idtrabajador'])
        
        if token:
            if self.email_service.enviar_enlace_magico(
                email, token, usuario['nombre']
            ):
                print(f"✅ Se ha enviado un enlace mágico a:")
                print(f"   {email}")
                print(f"\n📧 Revisa tu bandeja de entrada (y carpeta SPAM)")
                print(f"⏰ El enlace expirará en 30 minutos")
                print(f"\n📝 Si no recibes el correo, usa la opción 2 para ingresar manualmente:")
                print(f"   Token: {token}")
                
                self.registrar_auditoria(
                    accion="RECUPERAR_CONTRASEÑA",
                    tabla="trabajador",
                    registro_id=usuario['idtrabajador'],
                    datos_nuevos=f"Token enviado a: {email}"
                )
            else:
                print("❌ Error al enviar el correo")
                print(f"\n📝 Para pruebas, usa este token manualmente:")
                print(f"   {token}")
        else:
            print("❌ Error al generar el token")
        
        self.pausa()
    
    def _ingresar_token_manual(self):
        """Permite ingresar un token manualmente para restablecer contraseña"""
        self.mostrar_cabecera("INGRESAR TOKEN MANUAL")
        
        token = input("Ingrese el token recibido: ").strip()
        
        idtrabajador = self.token_service.verificar_token(token)
        
        if idtrabajador:
            usuario = self.trabajador_service.obtener_por_id(idtrabajador)
            print(f"\n✅ Token válido para: {usuario['nombre']} {usuario['apellidos']}")
            
            print("\n" + "="*50)
            print("🔑 CAMBIO DE CONTRASEÑA")
            print("="*50)
            print()
            
            logger.remove()
            logger.add(lambda msg: None)
            
            try:
                nueva_pass = input("➤ Ingrese NUEVA contraseña (mínimo 6 caracteres): ")
                confirmar = input("➤ Confirme la NUEVA contraseña: ")
            finally:
                logger.remove()
                logger.add(sys.stderr, format="<level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>")
            
            if nueva_pass == confirmar and len(nueva_pass) >= 6:
                if self.trabajador_service.actualizar_password(usuario['email'], nueva_pass):
                    self.token_service.marcar_token_usado(token)
                    print("\n✅ Contraseña actualizada correctamente")
                    print("🔐 Ya puede iniciar sesión con su nueva contraseña")
                    
                    self.registrar_auditoria(
                        accion="CAMBIAR_CONTRASEÑA",
                        tabla="trabajador",
                        registro_id=idtrabajador,
                        datos_nuevos="Contraseña actualizada mediante recuperación"
                    )
                else:
                    print("\n❌ Error al actualizar la contraseña")
            else:
                print("\n❌ Las contraseñas no coinciden o son muy cortas")
        else:
            print("\n❌ Token inválido o expirado")
        
        self.pausa()
    
    @requiere_permiso('usuarios_ver')
    def menu_administracion_usuarios(self):
        """Menú de administración de usuarios"""
        while True:
            self.mostrar_cabecera("ADMINISTRACIÓN DE USUARIOS")
            print("1. Listar usuarios")
            print("2. Crear nuevo usuario")
            print("3. Ver detalle de usuario")
            print("4. Editar usuario")
            print("5. Eliminar usuario")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._listar_usuarios()
            elif opcion == '2':
                self._crear_usuario()
            elif opcion == '3':
                self._ver_usuario()
            elif opcion == '4':
                self._editar_usuario()
            elif opcion == '5':
                self._eliminar_usuario()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    def _listar_usuarios(self):
        """Lista todos los usuarios"""
        self.mostrar_cabecera("LISTADO DE USUARIOS")
        
        usuarios = self.usuario_admin_service.listar_usuarios()
        
        if not usuarios:
            print("📭 No hay usuarios registrados")
        else:
            print(f"{'ID':<5} {'USUARIO':<15} {'NOMBRE':<25} {'EMAIL':<30} {'ROL':<15}")
            print("-" * 90)
            for u in usuarios:
                rol = u.get('rol_nombre') or f"Rol {u['idrol']}"
                email_val = u.get('email', '') or ''
                print(f"{u['idtrabajador']:<5} {u['usuario']:<15} {u['nombre'] + ' ' + u['apellidos']:<25} {email_val:<30} {rol:<15}")
        
        self.pausa()
    
    def _crear_usuario(self):
        """Crea un nuevo usuario del sistema"""
        self.mostrar_cabecera("CREAR NUEVO USUARIO")
        
        print("📝 Complete los datos del nuevo usuario:")
        print()
        
        nombre = input("Nombre: ")
        apellidos = input("Apellidos: ")
        sexo = input("Sexo (M/F/O): ").upper()
        
        print("\n📅 Fecha de nacimiento (OPCIONAL - presione Enter para omitir)")
        print("   Formato: DD/MM/YYYY (ej: 15/05/1990)")
        
        while True:
            fecha_nac_str = input("Fecha de nacimiento: ").strip()
            
            if fecha_nac_str == "":
                fecha_nac = None
                break
            
            valida, fecha_obj, mensaje = ValidacionVenezuela.validar_fecha(fecha_nac_str)
            
            if valida:
                fecha_nac = fecha_obj
                break
            else:
                print(mensaje)
                print("   Intente nuevamente o presione Enter para omitir:")
        
        print("\n" + "="*60)
        print("🔍 TIPO DE DOCUMENTO DEL USUARIO")
        print("="*60)
        print("1. 🇻🇪 Venezolano (V) → V12345678")
        print("2. 🌎 Extranjero (E) → E87654321")
        print("3. 🛂 Pasaporte → número de pasaporte")
        print("="*60)
        
        tipo_persona = input("Seleccione tipo de documento (1-3): ").strip()
        
        if tipo_persona == '1':
            tipo_doc = 'V'
            print("\n✅ Seleccionó: Venezolano (V)")
            print("📝 Formato requerido: V + 8 dígitos")
            print("   Ejemplo: V12345678")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('V'):
                print("❌ El documento debe comenzar con 'V'")
                self.pausa()
                return
            documento_completo = num_doc
            
        elif tipo_persona == '2':
            tipo_doc = 'E'
            print("\n✅ Seleccionó: Extranjero (E)")
            print("📝 Formato requerido: E + 8 dígitos")
            print("   Ejemplo: E87654321")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('E'):
                print("❌ El documento debe comenzar con 'E'")
                self.pausa()
                return
            documento_completo = num_doc
            
        elif tipo_persona == '3':
            tipo_doc = 'PASAPORTE'
            print("\n✅ Seleccionó: Pasaporte")
            print("📝 Ingrese número de pasaporte (6-12 caracteres)")
            print("   Ejemplo: ABC123456")
            documento_completo = input("Pasaporte: ").upper()
            
        else:
            print("❌ Opción no válida")
            self.pausa()
            return
        
        usuario = input("Nombre de usuario: ")
        password = input("Contraseña (mínimo 6 caracteres): ")
        email = input("Email: ")
        telefono = input("Teléfono (opcional): ") or None
        direccion = input("Dirección (opcional): ") or None
        
        print("\nRoles disponibles:")
        roles = self.rol_service.listar_roles()
        for r in roles:
            print(f"  {r['idrol']}. {r['nombre']}")
        
        try:
            idrol = int(input("\nID del rol: "))
        except:
            print("❌ Rol inválido")
            self.pausa()
            return
        
        fecha_nac_bd = ValidacionVenezuela.formatear_fecha_para_bd(fecha_nac) if fecha_nac else None
        
        if self.usuario_admin_service.crear_usuario(
            nombre, apellidos, sexo, fecha_nac_bd, documento_completo,
            usuario, password, email, idrol, direccion, telefono
        ):
            print("\n✅ Usuario creado exitosamente")
            if not fecha_nac:
                print("   ℹ️ Fecha de nacimiento no registrada")
            
            self.registrar_auditoria(
                accion="CREAR",
                tabla="trabajador",
                registro_id=self.trabajador_service.buscar_por_email(email)['idtrabajador'],
                datos_nuevos=f"Usuario: {usuario}, Email: {email}"
            )
        else:
            print("\n❌ Error al crear el usuario")
        
        self.pausa()
    
    def _ver_usuario(self):
        """Muestra detalle de un usuario"""
        self.mostrar_cabecera("DETALLE DE USUARIO")
        
        try:
            iduser = int(input("ID del usuario: "))
            usuario = self.usuario_admin_service.obtener_usuario(iduser)
            
            if usuario:
                print(f"\n📌 ID: {usuario['idtrabajador']}")
                print(f"📌 Nombre: {usuario['nombre']} {usuario['apellidos']}")
                print(f"📌 Sexo: {usuario['sexo']}")
                print(f"📌 Fecha Nac.: {usuario['fecha_nacimiento'] or 'No registrada'}")
                print(f"📌 Documento: {usuario['num_documento']}")
                print(f"📌 Usuario: {usuario['usuario']}")
                print(f"📌 Email: {usuario['email']}")
                print(f"📌 Teléfono: {usuario.get('telefono', 'No registrado')}")
                print(f"📌 Dirección: {usuario.get('direccion', 'No registrada')}")
                print(f"📌 Rol: {usuario.get('rol_nombre')} (ID: {usuario['idrol']})")
                
                print("\n📋 ÚLTIMAS ACCIONES DE AUDITORÍA:")
                logs = self.auditoria_service.consultar_por_tabla("trabajador", iduser)
                for log in logs[:5]:
                    print(f"   - {log['fecha_hora']}: {log['accion']}")
            else:
                print(f"❌ No existe usuario con ID {iduser}")
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    def _editar_usuario(self):
        """Edita un usuario existente"""
        self.mostrar_cabecera("EDITAR USUARIO")
        
        try:
            iduser = int(input("ID del usuario a editar: "))
            usuario = self.usuario_admin_service.obtener_usuario(iduser)
            
            if not usuario:
                print(f"❌ No existe usuario con ID {iduser}")
                self.pausa()
                return
            
            datos_anteriores = f"Usuario: {usuario['usuario']}, Email: {usuario['email']}, Rol: {usuario['idrol']}"
            
            print(f"\nEditando a: {usuario['nombre']} {usuario['apellidos']}")
            print("(Deje en blanco para mantener el valor actual)")
            print()
            
            nombre = input(f"Nombre [{usuario['nombre']}]: ") or usuario['nombre']
            apellidos = input(f"Apellidos [{usuario['apellidos']}]: ") or usuario['apellidos']
            sexo = input(f"Sexo [{usuario['sexo']}]: ").upper() or usuario['sexo']
            
            fecha_actual = usuario['fecha_nacimiento']
            fecha_actual_str = fecha_actual.strftime('%d/%m/%Y') if fecha_actual else "No registrada"
            
            print(f"\n📅 Fecha de nacimiento actual: {fecha_actual_str}")
            print("   (Enter para mantener, 'NUEVA' para cambiar, 'BORRAR' para eliminar)")
            
            while True:
                opcion_fecha = input("Opción: ").strip().upper()
                
                if opcion_fecha == "":
                    fecha_nac = fecha_actual
                    break
                elif opcion_fecha == "BORRAR":
                    fecha_nac = None
                    print("✅ Fecha de nacimiento eliminada")
                    break
                elif opcion_fecha == "NUEVA":
                    print("Ingrese nueva fecha (DD/MM/YYYY) o Enter para cancelar:")
                    nueva_fecha = input("Nueva fecha: ").strip()
                    
                    if nueva_fecha == "":
                        fecha_nac = fecha_actual
                        break
                    
                    valida, fecha_obj, mensaje = ValidacionVenezuela.validar_fecha(nueva_fecha)
                    if valida:
                        fecha_nac = fecha_obj
                        break
                    else:
                        print(mensaje)
                else:
                    print("Opción no válida. Use Enter, NUEVA o BORRAR")
            
            documento = input(f"Documento [{usuario['num_documento']}]: ") or usuario['num_documento']
            username = input(f"Usuario [{usuario['usuario']}]: ") or usuario['usuario']
            email = input(f"Email [{usuario['email']}]: ") or usuario['email']
            telefono = input(f"Teléfono [{usuario.get('telefono', '')}]: ") or usuario.get('telefono')
            direccion = input(f"Dirección [{usuario.get('direccion', '')}]: ") or usuario.get('direccion')
            
            cambiar_pass = input("¿Cambiar contraseña? (s/N): ").lower()
            nueva_pass = None
            if cambiar_pass == 's':
                nueva_pass = input("Nueva contraseña: ")
                confirmar = input("Confirmar contraseña: ")
                if nueva_pass != confirmar:
                    print("❌ Las contraseñas no coinciden")
                    self.pausa()
                    return
            
            print("\nRoles disponibles:")
            roles = self.rol_service.listar_roles()
            for r in roles:
                print(f"  {r['idrol']}. {r['nombre']}")
            
            try:
                idrol = int(input(f"\nID del rol [{usuario['idrol']}]: ") or usuario['idrol'])
            except:
                idrol = usuario['idrol']
            
            fecha_nac_bd = ValidacionVenezuela.formatear_fecha_para_bd(fecha_nac) if fecha_nac else None
            
            if self.usuario_admin_service.actualizar_usuario(
                iduser, nombre, apellidos, sexo, fecha_nac_bd, documento,
                username, email, idrol, direccion, telefono, nueva_pass
            ):
                print("✅ Usuario actualizado correctamente")
                
                datos_nuevos = f"Usuario: {username}, Email: {email}, Rol: {idrol}"
                self.registrar_auditoria(
                    accion="MODIFICAR",
                    tabla="trabajador",
                    registro_id=iduser,
                    datos_anteriores=datos_anteriores,
                    datos_nuevos=datos_nuevos
                )
            else:
                print("❌ Error al actualizar el usuario")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    def _eliminar_usuario(self):
        """Elimina un usuario"""
        self.mostrar_cabecera("ELIMINAR USUARIO")
        
        try:
            iduser = int(input("ID del usuario a eliminar: "))
            
            usuario_actual = self.trabajador_service.get_usuario_actual()
            if usuario_actual and usuario_actual['idtrabajador'] == iduser:
                print("❌ No puede eliminarse a sí mismo")
                self.pausa()
                return
            
            usuario = self.usuario_admin_service.obtener_usuario(iduser)
            if not usuario:
                print(f"❌ No existe usuario con ID {iduser}")
                self.pausa()
                return
            
            datos_usuario = f"Usuario: {usuario['usuario']}, Email: {usuario['email']}"
            
            print(f"\n¿Está seguro de eliminar a {usuario['nombre']} {usuario['apellidos']}?")
            confirmacion = input("Esta acción no se puede deshacer (escriba 'ELIMINAR' para confirmar): ")
            
            if confirmacion == 'ELIMINAR':
                if self.usuario_admin_service.eliminar_usuario(iduser):
                    print("✅ Usuario eliminado correctamente")
                    
                    self.registrar_auditoria(
                        accion="ELIMINAR",
                        tabla="trabajador",
                        registro_id=iduser,
                        datos_anteriores=datos_usuario
                    )
                else:
                    print("❌ Error al eliminar el usuario")
            else:
                print("Operación cancelada")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    def menu_categorias(self):
        """Menú de gestión de categorías"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE CATEGORÍAS")
            print("1. Listar categorías")
            print("2. Buscar categoría por ID")
            print("3. Crear categoría")
            print("4. Actualizar categoría")
            print("5. Eliminar categoría")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self.listar_categorias()
            elif opcion == '2':
                self.buscar_categoria()
            elif opcion == '3':
                self.crear_categoria()
            elif opcion == '4':
                self.actualizar_categoria()
            elif opcion == '5':
                self.eliminar_categoria()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    def listar_categorias(self):
        """Lista todas las categorías"""
        self.mostrar_cabecera("LISTADO DE CATEGORÍAS")
        
        categorias = self.categoria_service.listar()
        
        if not categorias:
            print("📭 No hay categorías registradas")
        else:
            print(f"{'ID':<5} {'NOMBRE':<30} {'DESCRIPCIÓN':<40}")
            print("-" * 75)
            for cat in categorias:
                desc = cat['descripcion'][:37] + "..." if cat['descripcion'] and len(cat['descripcion']) > 40 else cat['descripcion'] or ""
                print(f"{cat['idcategoria']:<5} {cat['nombre']:<30} {desc:<40}")
        
        self.pausa()
    
    def buscar_categoria(self):
        """Busca una categoría por ID"""
        self.mostrar_cabecera("BUSCAR CATEGORÍA")
        
        try:
            idcategoria = int(input("Ingrese ID de categoría: "))
            categoria = self.categoria_service.obtener_por_id(idcategoria)
            
            if categoria:
                print(f"\n📌 ID: {categoria['idcategoria']}")
                print(f"📌 Nombre: {categoria['nombre']}")
                print(f"📌 Descripción: {categoria['descripcion'] or 'Sin descripción'}")
            else:
                print(f"❌ No existe categoría con ID {idcategoria}")
        except ValueError:
            print("❌ Debe ingresar un número válido")
        
        self.pausa()
    
    def crear_categoria(self):
        """Crea una nueva categoría"""
        self.mostrar_cabecera("CREAR CATEGORÍA")
        
        nombre = input("Ingrese nombre de categoría: ")
        descripcion = input("Ingrese descripción (opcional): ") or None
        
        if self.categoria_service.crear(nombre, descripcion):
            print("✅ Categoría creada exitosamente")
            
            categorias = self.categoria_service.listar()
            if categorias:
                idcategoria = categorias[0]['idcategoria']
                self.registrar_auditoria(
                    accion="CREAR",
                    tabla="categoria",
                    registro_id=idcategoria,
                    datos_nuevos=f"Categoría: {nombre}"
                )
        else:
            print("❌ No se pudo crear la categoría")
        
        self.pausa()
    
    def actualizar_categoria(self):
        """Actualiza una categoría"""
        self.mostrar_cabecera("ACTUALIZAR CATEGORÍA")
        
        try:
            idcategoria = int(input("Ingrese ID de categoría a actualizar: "))
            categoria = self.categoria_service.obtener_por_id(idcategoria)
            
            if not categoria:
                print(f"❌ No existe categoría con ID {idcategoria}")
                self.pausa()
                return
            
            datos_anteriores = f"Categoría: {categoria['nombre']}"
            
            print(f"\n📌 Datos actuales:")
            print(f"   Nombre: {categoria['nombre']}")
            print(f"   Descripción: {categoria['descripcion'] or 'Sin descripción'}")
            print()
            
            nombre = input("Nuevo nombre (Enter para mantener): ") or categoria['nombre']
            descripcion = input("Nueva descripción (Enter para mantener): ") or categoria['descripcion']
            
            if self.categoria_service.actualizar(idcategoria, nombre, descripcion):
                print("✅ Categoría actualizada exitosamente")
                
                self.registrar_auditoria(
                    accion="MODIFICAR",
                    tabla="categoria",
                    registro_id=idcategoria,
                    datos_anteriores=datos_anteriores,
                    datos_nuevos=f"Categoría: {nombre}"
                )
            else:
                print("❌ No se pudo actualizar la categoría")
        except ValueError:
            print("❌ Debe ingresar un número válido")
        
        self.pausa()
    
    def eliminar_categoria(self):
        """Elimina una categoría"""
        self.mostrar_cabecera("ELIMINAR CATEGORÍA")
        
        try:
            idcategoria = int(input("Ingrese ID de categoría a eliminar: "))
            categoria = self.categoria_service.obtener_por_id(idcategoria)
            
            if not categoria:
                print(f"❌ No existe categoría con ID {idcategoria}")
                self.pausa()
                return
            
            datos_categoria = f"Categoría: {categoria['nombre']}"
            
            confirmacion = input(f"¿Está seguro de eliminar la categoría {idcategoria}? (s/N): ")
            if confirmacion.lower() == 's':
                if self.categoria_service.eliminar(idcategoria):
                    print("✅ Categoría eliminada exitosamente")
                    
                    self.registrar_auditoria(
                        accion="ELIMINAR",
                        tabla="categoria",
                        registro_id=idcategoria,
                        datos_anteriores=datos_categoria
                    )
                else:
                    print("❌ No se pudo eliminar la categoría (puede tener artículos asociados)")
            else:
                print("Operación cancelada")
        except ValueError:
            print("❌ Debe ingresar un número válido")
        
        self.pausa()
    
    def menu_clientes(self):
        """Menú de gestión de clientes"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE CLIENTES")
            print("1. Listar clientes")
            print("2. Buscar cliente")
            print("3. Crear cliente")
            print("4. Editar cliente")
            print("5. Eliminar cliente")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._listar_clientes()
            elif opcion == '2':
                self._buscar_cliente()
            elif opcion == '3':
                self._crear_cliente()
            elif opcion == '4':
                self._editar_cliente()
            elif opcion == '5':
                self._eliminar_cliente()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    @requiere_permiso('clientes_ver')
    def _listar_clientes(self):
        """Lista todos los clientes"""
        self.mostrar_cabecera("LISTADO DE CLIENTES")
        
        clientes = self.cliente_service.listar()
        
        if not clientes:
            print("📭 No hay clientes registrados")
        else:
            print(f"{'ID':<5} {'NOMBRE':<25} {'DOCUMENTO':<20} {'TELÉFONO':<12} {'EMAIL':<25}")
            print("-" * 87)
            for c in clientes:
                nombre_completo = f"{c['nombre']} {c['apellidos']}"
                documento = f"{c['tipo_documento']}-{c['num_documento']}"
                telefono_val = c.get('telefono', '') or ''
                email_val = c.get('email', '') or ''
                print(f"{c['idcliente']:<5} {nombre_completo:<25} {documento:<20} {telefono_val:<12} {email_val:<25}")
        
        self.pausa()
    
    @requiere_permiso('clientes_crear')
    def _crear_cliente(self):
        """Crea un nuevo cliente con validación venezolana y fecha opcional"""
        self.mostrar_cabecera("CREAR CLIENTE")
        
        print("📝 Complete los datos del cliente (los campos con * son obligatorios):")
        print()
        
        nombre = input("* Nombre: ")
        apellidos = input("* Apellidos: ")
        sexo = input("* Sexo (M/F/O): ").upper()
        
        print("\n📅 Fecha de nacimiento (OPCIONAL - presione Enter para omitir)")
        print("   Formato: DD/MM/YYYY (ej: 15/05/1990)")
        
        while True:
            fecha_nac_str = input("Fecha de nacimiento: ").strip()
            
            if fecha_nac_str == "":
                fecha_nac = None
                break
            
            valida, fecha_obj, mensaje = ValidacionVenezuela.validar_fecha(fecha_nac_str)
            
            if valida:
                fecha_nac = fecha_obj
                break
            else:
                print(mensaje)
                print("   Intente nuevamente o presione Enter para omitir:")
        
        print("\n" + "="*60)
        print("🔍 TIPO DE PERSONA - FORMATO DEL DOCUMENTO")
        print("="*60)
        print("1. 🇻🇪 Persona Natural Venezolana  →  V12345678")
        print("2. 🌎 Persona Natural Extranjera   →  E87654321")
        print("3. 🏢 Persona Jurídica (Empresa)   →  J12345678")
        print("4. 🏛️ Gobierno / Institución        →  G12345678")
        print("5. 👥 Consejo Comunal               →  C12345678")
        print("6. 🛂 Pasaporte                      →  Número de pasaporte")
        print("="*60)
        
        tipo_persona = input("Seleccione tipo de persona (1-6): ").strip()
        
        if tipo_persona == '1':
            tipo_doc = 'V'
            print("\n✅ Seleccionó: Persona Natural Venezolana (V)")
            print("📝 Formato requerido: V + 8 dígitos")
            print("   Ejemplo: V12345678")
            num_doc_completo = input("Documento completo: ").upper()
            
            if not num_doc_completo.startswith('V'):
                print("❌ El documento debe comenzar con 'V'")
                self.pausa()
                return
            num_doc = num_doc_completo[1:]
            
        elif tipo_persona == '2':
            tipo_doc = 'E'
            print("\n✅ Seleccionó: Persona Natural Extranjera (E)")
            print("📝 Formato requerido: E + 8 dígitos")
            print("   Ejemplo: E87654321")
            num_doc_completo = input("Documento completo: ").upper()
            
            if not num_doc_completo.startswith('E'):
                print("❌ El documento debe comenzar con 'E'")
                self.pausa()
                return
            num_doc = num_doc_completo[1:]
            
        elif tipo_persona == '3':
            tipo_doc = 'J'
            print("\n✅ Seleccionó: Empresa (J)")
            print("📝 Formato requerido: J + 8 dígitos")
            print("   Ejemplo: J12345678")
            num_doc_completo = input("Documento completo: ").upper()
            
            if not num_doc_completo.startswith('J'):
                print("❌ El documento debe comenzar con 'J'")
                self.pausa()
                return
            num_doc = num_doc_completo[1:]
            
        elif tipo_persona == '4':
            tipo_doc = 'G'
            print("\n✅ Seleccionó: Gobierno / Institución (G)")
            print("📝 Formato requerido: G + 8 dígitos")
            print("   Ejemplo: G12345678")
            num_doc_completo = input("Documento completo: ").upper()
            
            if not num_doc_completo.startswith('G'):
                print("❌ El documento debe comenzar con 'G'")
                self.pausa()
                return
            num_doc = num_doc_completo[1:]
            
        elif tipo_persona == '5':
            tipo_doc = 'C'
            print("\n✅ Seleccionó: Consejo Comunal (C)")
            print("📝 Formato requerido: C + 8 dígitos")
            print("   Ejemplo: C12345678")
            num_doc_completo = input("Documento completo: ").upper()
            
            if not num_doc_completo.startswith('C'):
                print("❌ El documento debe comenzar con 'C'")
                self.pausa()
                return
            num_doc = num_doc_completo[1:]
            
        elif tipo_persona == '6':
            tipo_doc = 'PASAPORTE'
            print("\n✅ Seleccionó: Pasaporte")
            print("📝 Ingrese número de pasaporte (6-12 caracteres)")
            print("   Ejemplo: ABC123456")
            num_doc = input("Pasaporte: ").upper()
            
        else:
            print("❌ Opción no válida")
            self.pausa()
            return
        
        print("\n📧 Email (opcional para clientes):")
        email = input("Email: ").strip()
        if email and ('@' not in email or '.' not in email):
            print("❌ El email no tiene un formato válido")
            self.pausa()
            return
        if not email:
            email = None
        
        direccion = input("Dirección (opcional): ") or None
        telefono = input("Teléfono (opcional): ") or None
        
        fecha_nac_bd = ValidacionVenezuela.formatear_fecha_para_bd(fecha_nac) if fecha_nac else None
        
        if self.cliente_service.crear(
            nombre, apellidos, fecha_nac_bd, tipo_doc, num_doc,
            sexo, direccion, telefono, email
        ):
            print("\n✅ Cliente creado exitosamente")
            if not fecha_nac:
                print("   ℹ️ Fecha de nacimiento no registrada")
            
            cliente_nuevo = self.cliente_service.buscar_por_documento(tipo_doc + num_doc)
            if cliente_nuevo:
                idcliente = cliente_nuevo['idcliente']
                self.registrar_auditoria(
                    accion="CREAR",
                    tabla="cliente",
                    registro_id=idcliente,
                    datos_nuevos=f"Cliente: {nombre} {apellidos}, Doc: {tipo_doc}-{num_doc}"
                )
        else:
            print("\n❌ Error al crear el cliente")
        
        self.pausa()
    
    @requiere_permiso('clientes_ver')
    def _buscar_cliente(self):
        """Busca un cliente por ID o documento"""
        self.mostrar_cabecera("BUSCAR CLIENTE")
        
        print("1. Buscar por ID")
        print("2. Buscar por documento")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            try:
                idcliente = int(input("ID del cliente: "))
                cliente = self.cliente_service.obtener_por_id(idcliente)
                if cliente:
                    self._mostrar_detalle_cliente(cliente)
                else:
                    print(f"❌ No existe cliente con ID {idcliente}")
            except:
                print("❌ ID inválido")
        
        elif opcion == '2':
            doc = input("Número de documento (ej: V12345678): ").upper()
            if doc and doc[0] in ['V', 'E', 'J', 'G', 'C']:
                tipo = doc[0]
                numero = doc[1:]
                clientes = self.cliente_service.listar()
                encontrado = None
                for c in clientes:
                    if c['tipo_documento'] == tipo and c['num_documento'] == numero:
                        encontrado = c
                        break
                if encontrado:
                    self._mostrar_detalle_cliente(encontrado)
                    
                    self.registrar_auditoria(
                        accion="CONSULTAR",
                        tabla="cliente",
                        registro_id=encontrado['idcliente'],
                        datos_nuevos=f"Búsqueda por documento: {doc}"
                    )
                else:
                    print(f"❌ No existe cliente con documento {doc}")
            else:
                print("❌ Formato de documento inválido")
        
        self.pausa()
    
    def _mostrar_detalle_cliente(self, c):
        """Muestra detalles completos de un cliente"""
        print(f"\n📌 ID: {c['idcliente']}")
        print(f"📌 Nombre: {c['nombre']} {c['apellidos']}")
        print(f"📌 Sexo: {c.get('sexo', 'No especificado')}")
        print(f"📌 Fecha Nac.: {c['fecha_nacimiento'] or 'No registrada'}")
        print(f"📌 Documento: {c['tipo_documento']}-{c['num_documento']}")
        print(f"📌 Dirección: {c.get('direccion', 'No registrada')}")
        print(f"📌 Teléfono: {c.get('telefono', 'No registrado')}")
        print(f"📌 Email: {c.get('email', 'No registrado')}")
    
    @requiere_permiso('clientes_editar')
    def _editar_cliente(self):
        """Edita un cliente existente con fecha opcional"""
        self.mostrar_cabecera("EDITAR CLIENTE")
        
        print("¿Cómo desea buscar el cliente?")
        print("1. Buscar por ID")
        print("2. Buscar por documento")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        cliente = None
        
        if opcion == '1':
            try:
                idcliente = int(input("ID del cliente: "))
                cliente = self.cliente_service.obtener_por_id(idcliente)
                if not cliente:
                    print(f"❌ No existe cliente con ID {idcliente}")
                    self.pausa()
                    return
            except ValueError:
                print("❌ ID inválido")
                self.pausa()
                return
                
        elif opcion == '2':
            doc = input("Número de documento (ej: V12345678): ").upper()
            doc_limpio = doc.replace('-', '').replace(' ', '')
            
            cliente_simple = None
            cliente_simple = self.cliente_service.buscar_por_documento(doc)
            if not cliente_simple:
                cliente_simple = self.cliente_service.buscar_por_documento(doc_limpio)
            if not cliente_simple and len(doc_limpio) >= 9:
                doc_con_guion = doc_limpio[0] + '-' + doc_limpio[1:]
                cliente_simple = self.cliente_service.buscar_por_documento(doc_con_guion)
            
            if not cliente_simple:
                print(f"❌ No existe cliente con documento {doc}")
                self.pausa()
                return
            cliente = self.cliente_service.obtener_por_id(cliente_simple['idcliente'])
            
        else:
            print("❌ Opción no válida")
            self.pausa()
            return
        
        tipo_actual = cliente['tipo_documento']
        tipo_texto = {
            'V': "🇻🇪 Persona Natural Venezolana",
            'E': "🌎 Persona Natural Extranjera",
            'J': "🏢 Empresa",
            'G': "🏛️ Gobierno / Institución",
            'C': "👥 Consejo Comunal",
            'PASAPORTE': "🛂 Pasaporte"
        }.get(tipo_actual, tipo_actual)
        
        print(f"\nEditando a: {cliente['nombre']} {cliente['apellidos']}")
        print(f"📌 Tipo actual: {tipo_texto}")
        print("(Deje en blanco para mantener el valor actual)")
        print()
        
        datos_anteriores = f"Cliente: {cliente['nombre']} {cliente['apellidos']}, Doc: {cliente['tipo_documento']}-{cliente['num_documento']}"
        
        nombre = input(f"Nombre [{cliente['nombre']}]: ") or cliente['nombre']
        apellidos = input(f"Apellidos [{cliente['apellidos']}]: ") or cliente['apellidos']
        sexo = input(f"Sexo [{cliente['sexo']}]: ").upper() or cliente['sexo']
        
        fecha_actual = cliente['fecha_nacimiento']
        fecha_actual_str = fecha_actual.strftime('%d/%m/%Y') if fecha_actual else "No registrada"
        
        print(f"\n📅 Fecha de nacimiento actual: {fecha_actual_str}")
        print("   (Enter para mantener, 'NUEVA' para cambiar, 'BORRAR' para eliminar)")
        
        while True:
            opcion_fecha = input("Opción: ").strip().upper()
            
            if opcion_fecha == "":
                fecha_nac = fecha_actual
                break
            elif opcion_fecha == "BORRAR":
                fecha_nac = None
                print("✅ Fecha de nacimiento eliminada")
                break
            elif opcion_fecha == "NUEVA":
                print("Ingrese nueva fecha (DD/MM/YYYY) o Enter para cancelar:")
                nueva_fecha = input("Nueva fecha: ").strip()
                
                if nueva_fecha == "":
                    fecha_nac = fecha_actual
                    break
                
                valida, fecha_obj, mensaje = ValidacionVenezuela.validar_fecha(nueva_fecha)
                if valida:
                    fecha_nac = fecha_obj
                    break
                else:
                    print(mensaje)
            else:
                print("Opción no válida. Use Enter, NUEVA o BORRAR")
        
        print("\n¿Cambiar tipo de documento? (s/N): ", end="")
        cambiar_tipo = input().lower()
        
        if cambiar_tipo == 's':
            print("\n" + "="*60)
            print("🔍 NUEVO TIPO DE DOCUMENTO")
            print("="*60)
            print("1. 🇻🇪 Venezolano (V) → V12345678")
            print("2. 🌎 Extranjero (E) → E87654321")
            print("3. 🏢 Empresa (J) → J12345678")
            print("4. 🏛️ Gobierno (G) → G12345678")
            print("5. 👥 Consejo Comunal (C) → C12345678")
            print("6. 🛂 Pasaporte → texto libre")
            print("="*60)
            
            tipo_op = input("Seleccione nuevo tipo (1-6): ").strip()
            
            if tipo_op == '1':
                tipo_doc = 'V'
                print("Ingrese documento completo (ej: V12345678):")
                doc_completo = input("Documento: ").upper()
                if doc_completo.startswith('V'):
                    num_doc = doc_completo[1:]
                else:
                    print("❌ Debe comenzar con V")
                    self.pausa()
                    return
            elif tipo_op == '2':
                tipo_doc = 'E'
                print("Ingrese documento completo (ej: E87654321):")
                doc_completo = input("Documento: ").upper()
                if doc_completo.startswith('E'):
                    num_doc = doc_completo[1:]
                else:
                    print("❌ Debe comenzar con E")
                    self.pausa()
                    return
            elif tipo_op == '3':
                tipo_doc = 'J'
                print("Ingrese documento completo (ej: J12345678):")
                doc_completo = input("Documento: ").upper()
                if doc_completo.startswith('J'):
                    num_doc = doc_completo[1:]
                else:
                    print("❌ Debe comenzar con J")
                    self.pausa()
                    return
            elif tipo_op == '4':
                tipo_doc = 'G'
                print("Ingrese documento completo (ej: G12345678):")
                doc_completo = input("Documento: ").upper()
                if doc_completo.startswith('G'):
                    num_doc = doc_completo[1:]
                else:
                    print("❌ Debe comenzar con G")
                    self.pausa()
                    return
            elif tipo_op == '5':
                tipo_doc = 'C'
                print("Ingrese documento completo (ej: C12345678):")
                doc_completo = input("Documento: ").upper()
                if doc_completo.startswith('C'):
                    num_doc = doc_completo[1:]
                else:
                    print("❌ Debe comenzar con C")
                    self.pausa()
                    return
            elif tipo_op == '6':
                tipo_doc = 'PASAPORTE'
                num_doc = input("Número de pasaporte: ").upper()
            else:
                print("❌ Opción no válida")
                self.pausa()
                return
        else:
            tipo_doc = cliente['tipo_documento']
            num_doc = cliente['num_documento']
        
        direccion = input(f"Dirección [{cliente.get('direccion', '')}]: ") or cliente.get('direccion')
        telefono = input(f"Teléfono [{cliente.get('telefono', '')}]: ") or cliente.get('telefono')
        email = input(f"Email [{cliente.get('email', '')}]: ") or cliente.get('email')
        
        fecha_nac_bd = ValidacionVenezuela.formatear_fecha_para_bd(fecha_nac) if fecha_nac else None
        
        if self.cliente_service.actualizar(
            cliente['idcliente'], nombre, apellidos, fecha_nac_bd, tipo_doc, num_doc,
            sexo, direccion, telefono, email
        ):
            print("\n✅ Cliente actualizado correctamente")
            
            datos_nuevos = f"Cliente: {nombre} {apellidos}, Doc: {tipo_doc}-{num_doc}"
            self.registrar_auditoria(
                accion="MODIFICAR",
                tabla="cliente",
                registro_id=cliente['idcliente'],
                datos_anteriores=datos_anteriores,
                datos_nuevos=datos_nuevos
            )
        else:
            print("\n❌ Error al actualizar el cliente")
        
        self.pausa()
    
    @requiere_permiso('clientes_eliminar')
    def _eliminar_cliente(self):
        """Elimina un cliente"""
        self.mostrar_cabecera("ELIMINAR CLIENTE")
        
        try:
            idcliente = int(input("ID del cliente a eliminar: "))
            
            cliente = self.cliente_service.obtener_por_id(idcliente)
            if not cliente:
                print(f"❌ No existe cliente con ID {idcliente}")
                self.pausa()
                return
            
            datos_cliente = f"Cliente: {cliente['nombre']} {cliente['apellidos']}, Doc: {cliente['tipo_documento']}-{cliente['num_documento']}"
            
            print(f"\n¿Está seguro de eliminar a {cliente['nombre']} {cliente['apellidos']}?")
            confirmacion = input("Esta acción no se puede deshacer (escriba 'ELIMINAR' para confirmar): ")
            
            if confirmacion == 'ELIMINAR':
                if self.cliente_service.eliminar(idcliente):
                    print("✅ Cliente eliminado correctamente")
                    
                    self.registrar_auditoria(
                        accion="ELIMINAR",
                        tabla="cliente",
                        registro_id=idcliente,
                        datos_anteriores=datos_cliente
                    )
                else:
                    print("❌ Error al eliminar el cliente (puede tener ventas asociadas)")
            else:
                print("Operación cancelada")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('articulos_ver')
    def menu_articulos(self):
        """Menú de gestión de artículos"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE ARTÍCULOS")
            print("1. Listar artículos")
            print("2. Buscar artículo (por código/nombre)")
            print("3. Crear artículo")
            print("4. Editar artículo")
            print("5. Eliminar artículo")
            print("6. Ver stock por lote")
            print("7. 🔍 Búsqueda avanzada (código barras/PLU)")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._listar_articulos()
            elif opcion == '2':
                self._buscar_articulo()
            elif opcion == '3':
                self._crear_articulo()
            elif opcion == '4':
                self._editar_articulo()
            elif opcion == '5':
                self._eliminar_articulo()
            elif opcion == '6':
                self._ver_stock_lotes()
            elif opcion == '7':
                self._buscar_articulo_gestion()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    @requiere_permiso('articulos_ver')
    def _listar_articulos(self):
        """Lista todos los artículos con opciones de edición"""
        while True:
            self.mostrar_cabecera("LISTADO DE ARTÍCULOS")
            
            articulos_con_stock = self.inventario_service.listar_con_stock()
            
            if not articulos_con_stock:
                print("📭 No hay artículos registrados")
                self.pausa()
                return
            
            # Ordenar artículos por ID
            articulos_con_stock.sort(key=lambda x: x['idarticulo'])
            
            # Cabecera con columnas
            print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'CATEGORÍA':<20} {'PRECIO $':<12} {'STOCK':<10} {'ESTADO':<10}")
            print("-" * 107)
            
            for a in articulos_con_stock:
                precio = a.get('precio_venta', 0)
                stock_str = f"{a['stock_actual']} und"
                
                # Formatear precio en dólares (enteros sin decimales, decimales con 2 dígitos)
                if precio == int(precio):  # Si es entero (ej: 150.0 → 150)
                    precio_str = f"${int(precio)}"
                else:  # Si tiene decimales (ej: 0.60, 2.5, 4.50)
                    # Mostrar con 2 decimales pero sin ceros innecesarios
                    precio_str = f"${precio:.2f}".rstrip('0').rstrip('.') if precio % 1 != 0 else f"${int(precio)}"
                
                estado = f"{a['emoji']}"
                
                linea = f"{a['idarticulo']:<5} {a['codigo']:<15} {a['nombre']:<30} {a['categoria']:<20} {precio_str:<12} {stock_str:<10} {estado:<10}"
                print(f"{a['color']}{linea}{self.inventario_service.COLOR_RESET}")
            
            print("-" * 107)
            print("Opciones de edición:")
            print("  [E] Editar TODO (categoría, nombre, stock) - Ingrese ID")
            print("  [M] Editar solo PRECIO en dólares $ - Ingrese ID")
            print("  [V] Volver al menú")
            print("-" * 40)
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip().upper()
            
            if opcion == 'V':
                break
            
            elif opcion == 'E':
                try:
                    id_input = input("ID del artículo a editar (todo excepto precio): ").strip()
                    if id_input.isdigit():
                        id_editar = int(id_input)
                        articulo = self.articulo_service.obtener_por_id(id_editar)
                        if articulo:
                            self._editar_articulo_completo(id_editar)
                        else:
                            print(f"{self.COLOR_ROJO}❌ No existe artículo con ID {id_editar}{self.COLOR_RESET}")
                            self.pausa()
                    else:
                        print(f"{self.COLOR_ROJO}❌ ID inválido{self.COLOR_RESET}")
                        self.pausa()
                except Exception as e:
                    print(f"{self.COLOR_ROJO}❌ Error: {e}{self.COLOR_RESET}")
                    self.pausa()
            
            elif opcion == 'M':
                try:
                    id_input = input("ID del artículo a editar (solo precio $): ").strip()
                    if id_input.isdigit():
                        id_editar = int(id_input)
                        articulo = self.articulo_service.obtener_por_id(id_editar)
                        if articulo:
                            self._editar_precio_articulo(id_editar)
                        else:
                            print(f"{self.COLOR_ROJO}❌ No existe artículo con ID {id_editar}{self.COLOR_RESET}")
                            self.pausa()
                    else:
                        print(f"{self.COLOR_ROJO}❌ ID inválido{self.COLOR_RESET}")
                        self.pausa()
                except Exception as e:
                    print(f"{self.COLOR_ROJO}❌ Error: {e}{self.COLOR_RESET}")
                    self.pausa()
            
            elif opcion.isdigit():
                # Si el usuario ingresa directamente un número, por defecto va a edición completa
                id_editar = int(opcion)
                articulo = self.articulo_service.obtener_por_id(id_editar)
                if articulo:
                    self._editar_articulo_completo(id_editar)
                else:
                    print(f"{self.COLOR_ROJO}❌ No existe artículo con ID {id_editar}{self.COLOR_RESET}")
                    self.pausa()
            
            else:
                print(f"{self.COLOR_ROJO}❌ Opción no válida{self.COLOR_RESET}")
                self.pausa()

    def _editar_precio_articulo(self, idarticulo):
        """
        Edita SOLO el precio de un artículo (rápido)
        """
        self.mostrar_cabecera(f"EDITAR PRECIO - ID: {idarticulo}")
        
        art = self.articulo_service.obtener_por_id(idarticulo)
        
        if not art:
            print(f"{self.COLOR_ROJO}❌ No existe artículo con ID {idarticulo}{self.COLOR_RESET}")
            self.pausa()
            return
        
        # Mostrar información actual
        print(f"\n{self.COLOR_VERDE}📌 Artículo:{self.COLOR_RESET} {art['nombre']}")
        print(f"   Código: {art['codigo']}")
        print(f"   Precio actual: ${art.get('precio_venta', 0):.2f}".rstrip('0').rstrip('.') if art.get('precio_venta', 0) % 1 != 0 else f"   Precio actual: ${int(art.get('precio_venta', 0))}")
        
        print(f"\n{self.COLOR_AMARILLO}💰 Ingrese el nuevo precio en DÓLARES (puede usar decimales: 0.60, 2.5, 4.50):{self.COLOR_RESET}")
        
        try:
            precio_input = input(f"Nuevo precio $: ").strip()
            if precio_input:
                nuevo_precio = float(precio_input.replace(',', '.'))
                if nuevo_precio >= 0:
                    
                    # Actualizar solo el precio en BD
                    if self.articulo_service.actualizar(
                        idarticulo=idarticulo,
                        codigo=art['codigo'],
                        nombre=art['nombre'],
                        idcategoria=art['idcategoria'],
                        idpresentacion=art['idpresentacion'],
                        descripcion=art.get('descripcion'),
                        precio_venta=nuevo_precio,
                        precio_referencia=art.get('precio_referencia')
                    ):
                        # Mostrar formato apropiado
                        if nuevo_precio == int(nuevo_precio):
                            print(f"\n{self.COLOR_VERDE}✅ Precio actualizado a ${int(nuevo_precio)}{self.COLOR_RESET}")
                        else:
                            print(f"\n{self.COLOR_VERDE}✅ Precio actualizado a ${nuevo_precio:.2f}".rstrip('0').rstrip('.') + f"{self.COLOR_RESET}")
                    else:
                        print(f"\n{self.COLOR_ROJO}❌ Error al actualizar precio{self.COLOR_RESET}")
                else:
                    print("❌ El precio no puede ser negativo")
            else:
                print("Precio no modificado")
                
        except ValueError:
            print(f"{self.COLOR_ROJO}❌ Error: Ingrese un número válido (ej: 150, 0.60, 2.5){self.COLOR_RESET}")
        except Exception as e:
            print(f"{self.COLOR_ROJO}❌ Error: {e}{self.COLOR_RESET}")
        
        self.pausa()

    def _editar_articulo_completo(self, idarticulo):
        """
        Edita un artículo completo (todo excepto precio)
        """
        self.mostrar_cabecera(f"EDITAR ARTÍCULO COMPLETO - ID: {idarticulo}")
        
        art = self.articulo_service.obtener_por_id(idarticulo)
        
        if not art:
            print(f"{self.COLOR_ROJO}❌ No existe artículo con ID {idarticulo}{self.COLOR_RESET}")
            self.pausa()
            return
        
        # Mostrar información actual
        print(f"\n{self.COLOR_VERDE}📌 Datos actuales:{self.COLOR_RESET}")
        print(f"   Código: {art['codigo']}")
        print(f"   Nombre: {art['nombre']}")
        
        # Obtener precio actual (FORZAR A FLOAT)
        precio_actual = art.get('precio_venta', 0)
        try:
            precio_actual = float(precio_actual)
        except:
            precio_actual = 0.0
        
        print(f"   Precio actual: ${precio_actual:,.2f}")
        
        # Obtener stock actual
        stock_actual = self.inventario_service.obtener_stock_articulo(idarticulo)
        print(f"   Stock actual: {stock_actual} unidades")
        
        print(f"\n{self.COLOR_AMARILLO}📝 Ingrese los nuevos datos (Enter para mantener):{self.COLOR_RESET}")
        print()
        
        # Código
        nuevo_codigo = input(f"Código [{art['codigo']}]: ").strip() or art['codigo']
        
        # Nombre
        nuevo_nombre = input(f"Nombre [{art['nombre']}]: ").strip() or art['nombre']
        
        # Categoría
        categorias = self.categoria_service.listar()
        print("\nCategorías disponibles:")
        for c in categorias:
            print(f"  {c['idcategoria']}. {c['nombre']}")
        try:
            cat_input = input(f"ID categoría [{art['idcategoria']}]: ").strip()
            nueva_categoria = int(cat_input) if cat_input else art['idcategoria']
        except:
            nueva_categoria = art['idcategoria']
        
        # Stock (opcional)
        print("\n" + "="*40)
        print("¿Desea ajustar el stock?")
        print("1. Sí, agregar stock")
        print("2. Sí, quitar stock")
        print("3. No, mantener stock")
        opcion_stock = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion_stock == '1':
            try:
                cantidad = int(input("Cantidad a AGREGAR: "))
                if cantidad > 0:
                    self.inventario_service.reponer_stock(
                        idarticulo=idarticulo,
                        cantidad=cantidad,
                        idingreso=None,
                        precio_compra=art.get('precio_referencia', 0)
                    )
                    print(f"{self.COLOR_VERDE}✅ Stock aumentado: +{cantidad} unidades{self.COLOR_RESET}")
            except:
                print("❌ Cantidad inválida")
        
        elif opcion_stock == '2':
            try:
                cantidad = int(input("Cantidad a QUITAR: "))
                if cantidad > 0 and cantidad <= stock_actual:
                    self.inventario_service.descontar_stock(
                        idarticulo=idarticulo,
                        cantidad=cantidad,
                        idventa=None,
                        precio_unitario=precio_actual
                    )
                    print(f"{self.COLOR_VERDE}✅ Stock disminuido: -{cantidad} unidades{self.COLOR_RESET}")
                else:
                    print(f"❌ Cantidad inválida o superior al stock actual ({stock_actual})")
            except:
                print("❌ Cantidad inválida")
        
        # Actualizar en BD (MANTENIENDO EL PRECIO ACTUAL)
        print(f"\n🔍 Manteniendo precio: ${precio_actual:,.2f}")
        
        if self.articulo_service.actualizar(
            idarticulo=idarticulo,
            codigo=nuevo_codigo,
            nombre=nuevo_nombre,
            idcategoria=nueva_categoria,
            idpresentacion=art['idpresentacion'],
            descripcion=art.get('descripcion'),
            precio_venta=precio_actual,  # Pasamos el precio actual como float
            precio_referencia=art.get('precio_referencia')
        ):
            print(f"\n{self.COLOR_VERDE}✅ Artículo actualizado correctamente (precio mantenido en ${precio_actual:,.2f}){self.COLOR_RESET}")
        else:
            print(f"\n{self.COLOR_ROJO}❌ Error al actualizar{self.COLOR_RESET}")
        
        self.pausa()
    
    @requiere_permiso('articulos_crear')
    def _crear_articulo(self):
        """Crea un nuevo artículo con precio de venta"""
        self.mostrar_cabecera("CREAR ARTÍCULO")
        
        # Mostrar categorías disponibles
        categorias = self.categoria_service.listar()
        if not categorias:
            print("❌ No hay categorías. Cree una primero.")
            self.pausa()
            return
        
        print("Categorías disponibles:")
        for c in categorias:
            print(f"  {c['idcategoria']}. {c['nombre']}")
        
        try:
            idcat = int(input("\nID de categoría: "))
        except:
            print("❌ Categoría inválida")
            self.pausa()
            return
        
        # Mostrar presentaciones
        print("\nPresentaciones:")
        print("  1. Unidad")
        print("  2. Caja")
        print("  3. Kilogramo")
        
        try:
            idpres = int(input("ID de presentación: "))
        except:
            print("❌ Presentación inválida")
            self.pausa()
            return
        
        print()
        codigo = input("Código del artículo: ")
        nombre = input("Nombre del artículo: ")
        descripcion = input("Descripción (opcional): ") or None
        
        # Solicitar precio de venta
        print("\n💰 PRECIO DE VENTA")
        print("="*40)
        try:
            precio_venta = float(input("Precio de venta (Bs.): "))
            if precio_venta < 0:
                print("❌ El precio no puede ser negativo")
                precio_venta = 0
        except:
            print("❌ Precio inválido. Se asignará 0 por defecto.")
            precio_venta = 0
        
        # Solicitar precio de referencia (opcional)
        print("\n📦 PRECIO DE REFERENCIA (costo)")
        print("="*40)
        print("(Opcional - Enter para omitir)")
        try:
            precio_ref_input = input("Precio de referencia (costo): ").strip()
            if precio_ref_input:
                precio_referencia = float(precio_ref_input)
                if precio_referencia < 0:
                    precio_referencia = 0
            else:
                precio_referencia = None
        except:
            precio_referencia = None
        
        # Solicitar stock inicial
        print("\n📦 STOCK INICIAL")
        print("="*40)
        try:
            stock_inicial = int(input("Cantidad inicial: "))
            if stock_inicial < 0:
                print("❌ La cantidad no puede ser negativa")
                stock_inicial = 0
        except:
            print("❌ Cantidad inválida. Se asignará 0 por defecto.")
            stock_inicial = 0
        
        if self.articulo_service.crear(
            codigo, nombre, idcat, idpres, descripcion, 
            precio_venta, precio_referencia
        ):
            print(f"\n{self.COLOR_VERDE}✅ Artículo creado exitosamente{self.COLOR_RESET}")
            
            # Buscar el ID del artículo recién creado
            articulo_nuevo = self.articulo_service.buscar_por_codigo(codigo)
            if articulo_nuevo:
                idarticulo = articulo_nuevo['idarticulo']
                
                # Registrar stock inicial en kardex
                if stock_inicial > 0:
                    self.inventario_service.reponer_stock(
                        idarticulo=idarticulo,
                        cantidad=stock_inicial,
                        idingreso=None,
                        precio_compra=precio_referencia or 0
                    )
                    print(f"   📦 Stock inicial: {stock_inicial} unidades")
                    print(f"   💰 Precio venta: Bs. {precio_venta:.2f}")
                    if precio_referencia:
                        print(f"   💰 Precio referencia: Bs. {precio_referencia:.2f}")
                
                self.registrar_auditoria(
                    accion="CREAR",
                    tabla="articulo",
                    registro_id=idarticulo,
                    datos_nuevos=f"Artículo: {nombre}, Código: {codigo}, Precio: {precio_venta}"
                )
        else:
            print(f"\n{self.COLOR_ROJO}❌ Error al crear el artículo{self.COLOR_RESET}")
        
        self.pausa()
    
    @requiere_permiso('articulos_ver')
    def _buscar_articulo(self):
        """Busca un artículo por ID o código"""
        self.mostrar_cabecera("BUSCAR ARTÍCULO")
        
        print("1. Buscar por ID")
        print("2. Buscar por código")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            try:
                idart = int(input("ID del artículo: "))
                art = self.articulo_service.obtener_por_id(idart)
                if art:
                    self._mostrar_detalle_articulo(art)
                    
                    self.registrar_auditoria(
                        accion="CONSULTAR",
                        tabla="articulo",
                        registro_id=idart,
                        datos_nuevos=f"Artículo: {art['nombre']}"
                    )
                else:
                    print(f"❌ No existe artículo con ID {idart}")
            except:
                print("❌ ID inválido")
        
        elif opcion == '2':
            codigo = input("Código del artículo: ")
            art = self.articulo_service.buscar_por_codigo(codigo)
            if art:
                art = self.articulo_service.obtener_por_id(art['idarticulo'])
                self._mostrar_detalle_articulo(art)
                
                self.registrar_auditoria(
                    accion="CONSULTAR",
                    tabla="articulo",
                    registro_id=art['idarticulo'],
                    datos_nuevos=f"Artículo: {art['nombre']}, Código: {codigo}"
                )
            else:
                print(f"❌ No existe artículo con código {codigo}")
        
        self.pausa()
    
    def _mostrar_detalle_articulo(self, a):
        """Muestra detalles completos de un artículo"""
        print(f"\n📌 ID: {a['idarticulo']}")
        print(f"📌 Código: {a['codigo']}")
        print(f"📌 Nombre: {a['nombre']}")
        print(f"📌 Categoría: {a.get('categoria', 'N/A')}")
        print(f"📌 Presentación: {a.get('presentacion', 'N/A')}")
        print(f"📌 Descripción: {a.get('descripcion', 'Sin descripción')}")
    
    @requiere_permiso('articulos_editar')
    def _editar_articulo(self):
        """Edita un artículo existente mostrando stock actual"""
        self.mostrar_cabecera("EDITAR ARTÍCULO")
        
        try:
            idart = int(input("ID del artículo a editar: "))
            art = self.articulo_service.obtener_por_id(idart)
            
            if not art:
                print(f"❌ No existe artículo con ID {idart}")
                self.pausa()
                return
            
            # Obtener stock actual
            stock_actual = self.inventario_service.obtener_stock_articulo(idart)
            nivel = self.inventario_service.obtener_nivel_stock(stock_actual)
            
            # Guardar datos anteriores para auditoría
            datos_anteriores = f"Artículo: {art['nombre']}, Código: {art['codigo']}, Stock: {stock_actual}"
            
            print(f"\n📌 Editando: {art['nombre']}")
            print(f"{nivel['color']}📦 Stock actual: {stock_actual} unidades {nivel['emoji']} {nivel['nivel']}{self.COLOR_RESET}")
            print("(Deje en blanco para mantener el valor actual)")
            print()
            
            codigo = input(f"Código [{art['codigo']}]: ") or art['codigo']
            nombre = input(f"Nombre [{art['nombre']}]: ") or art['nombre']
            descripcion = input(f"Descripción [{art.get('descripcion', '')}]: ") or art.get('descripcion')
            
            # Opción de ajustar stock
            print(f"\n📦 AJUSTE DE STOCK")
            print("="*40)
            print(f"Stock actual: {stock_actual} unidades")
            print("¿Desea ajustar el stock?")
            print("1. Sí, agregar stock")
            print("2. Sí, quitar stock")
            print("3. No, mantener stock actual")
            opcion_stock = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
            
            if opcion_stock == '1':
                try:
                    cantidad = int(input("Cantidad a AGREGAR: "))
                    if cantidad > 0:
                        self.inventario_service.reponer_stock(
                            idarticulo=idart,
                            cantidad=cantidad,
                            idingreso=None,
                            precio_compra=0
                        )
                        print(f"{self.COLOR_VERDE}✅ Stock aumentado: +{cantidad} unidades{self.COLOR_RESET}")
                        stock_actual += cantidad
                except:
                    print("❌ Cantidad inválida")
            
            elif opcion_stock == '2':
                try:
                    cantidad = int(input("Cantidad a QUITAR: "))
                    if cantidad > 0 and cantidad <= stock_actual:
                        self.inventario_service.descontar_stock(
                            idarticulo=idart,
                            cantidad=cantidad,
                            idventa=None,
                            precio_unitario=0
                        )
                        print(f"{self.COLOR_VERDE}✅ Stock disminuido: -{cantidad} unidades{self.COLOR_RESET}")
                        stock_actual -= cantidad
                    else:
                        print(f"❌ Cantidad inválida o superior al stock actual ({stock_actual})")
                except:
                    print("❌ Cantidad inválida")
            
            # Mostrar categorías
            print("\nCategorías disponibles:")
            categorias = self.categoria_service.listar()
            for c in categorias:
                print(f"  {c['idcategoria']}. {c['nombre']}")
            
            try:
                idcat = int(input(f"ID categoría [{art['idcategoria']}]: ") or art['idcategoria'])
            except:
                idcat = art['idcategoria']
            
            # Presentaciones
            print("\nPresentaciones:")
            print("  1. Unidad")
            print("  2. Caja")
            print("  3. Kilogramo")
            
            try:
                idpres = int(input(f"ID presentación [{art['idpresentacion']}]: ") or art['idpresentacion'])
            except:
                idpres = art['idpresentacion']
            
            if self.articulo_service.actualizar(idart, codigo, nombre, idcat, idpres, descripcion):
                print(f"\n{self.COLOR_VERDE}✅ Artículo actualizado correctamente{self.COLOR_RESET}")
                print(f"   📦 Stock final: {stock_actual} unidades")
                
                datos_nuevos = f"Artículo: {nombre}, Código: {codigo}, Stock: {stock_actual}"
                self.registrar_auditoria(
                    accion="MODIFICAR",
                    tabla="articulo",
                    registro_id=idart,
                    datos_anteriores=datos_anteriores,
                    datos_nuevos=datos_nuevos
                )
            else:
                print(f"\n{self.COLOR_ROJO}❌ Error al actualizar el artículo{self.COLOR_RESET}")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('articulos_eliminar')
    def _eliminar_articulo(self):
        """Elimina un artículo"""
        self.mostrar_cabecera("ELIMINAR ARTÍCULO")
        
        try:
            idart = int(input("ID del artículo a eliminar: "))
            
            art = self.articulo_service.obtener_por_id(idart)
            if not art:
                print(f"❌ No existe artículo con ID {idart}")
                self.pausa()
                return
            
            datos_articulo = f"Artículo: {art['nombre']}, Código: {art['codigo']}"
            
            print(f"\n¿Está seguro de eliminar {art['nombre']}?")
            confirmacion = input("Esta acción no se puede deshacer (escriba 'ELIMINAR' para confirmar): ")
            
            if confirmacion == 'ELIMINAR':
                if self.articulo_service.eliminar(idart):
                    print("✅ Artículo eliminado correctamente")
                    
                    self.registrar_auditoria(
                        accion="ELIMINAR",
                        tabla="articulo",
                        registro_id=idart,
                        datos_anteriores=datos_articulo
                    )
                else:
                    print("❌ Error al eliminar el artículo (puede tener movimientos asociados)")
            else:
                print("Operación cancelada")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('inventario_ver')
    def _ver_stock_lotes(self):
        """Ver stock por lotes de un artículo"""
        self.mostrar_cabecera("STOCK POR LOTES")
        
        try:
            idart = int(input("ID del artículo: "))
            art = self.articulo_service.obtener_por_id(idart)
            
            if not art:
                print(f"❌ No existe artículo con ID {idart}")
                self.pausa()
                return
            
            print(f"\nArtículo: {art['nombre']}")
            stock = self.inventario_service.obtener_stock_articulo(idart)
            nivel = self.inventario_service.obtener_nivel_stock(stock)
            
            print(f"Stock total: {stock} unidades")
            print(f"Estado: {nivel['color']}{nivel['emoji']} {nivel['nivel']}{self.inventario_service.COLOR_RESET}")
            print("🔧 Módulo de lotes en desarrollo")
            
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('ventas_ver')
    def menu_ventas(self):
        """Menú de gestión de ventas (con 3 opciones de identificación)"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE VENTAS")
            print("1. Listar ventas")
            print("2. Registrar venta")
            print("3. Ver detalle de venta")
            print("4. Anular venta")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._listar_ventas()
            elif opcion == '2':
                self._registrar_venta()
            elif opcion == '3':
                self._ver_venta()
            elif opcion == '4':
                self._anular_venta()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()

    @requiere_permiso('ventas_crear')
    def _registrar_venta(self):
        """Registra una nueva venta"""
        self.mostrar_cabecera("REGISTRAR VENTA - MULTIMONEDA")
        
        usuario = self.trabajador_service.get_usuario_actual()
        if not usuario:
            print(f"{self.COLOR_ROJO}❌ Debe iniciar sesión{self.COLOR_RESET}")
            self.pausa()
            return
        
        tasas = self.obtener_tasas_actuales()
        tasa_usd = tasas.get('USD', 0)
        
        if tasa_usd <= 0:
            print(f"{self.COLOR_AMARILLO}⚠️ Configure tasa con [X]{self.COLOR_RESET}")
            self.pausa()
            return
        
        # ===== SELECCIÓN DE CLIENTE =====
        print("\n📋 IDENTIFICACIÓN DEL CLIENTE")
        print("="*60)
        print("1. 🇻🇪 RIF")
        print("2. 🆔 Cédula")
        print("3. 🛒 CONSUMIDOR FINAL")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        idcliente = None
        cliente = None
        
        if opcion == '1' or opcion == '2':
            print("Buscar cliente... (simulado)")
            idcliente = 1
        # else: consumidor final (None)
        
        # ===== MONEDA DE PAGO =====
        print("\n💳 MONEDA DE PAGO")
        print("="*60)
        print("1. USD  2. VES  3. EUR")
        pago = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        moneda_pago = {'1': 'USD', '2': 'VES', '3': 'EUR'}.get(pago, 'USD')
        
        # ===== COMPROBANTE =====
        print("\n📄 COMPROBANTE")
        print("="*60)
        print("1. Boleta  2. Ticket")
        tipo = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        tipo_comp = 'BOLETA' if tipo == '1' else 'TICKET'
        serie = input("Serie: ").strip() or "F001"
        numero = input("Número: ").strip() or "001"
        
        # ===== PRODUCTOS (INTERFAZ LIMPIA) =====
        detalle = []
        print("\n" + "="*60)
        print("🛒 PRODUCTOS")
        print("="*60)
        print(f"💰 Tasa: Bs. {tasa_usd:.2f}")
        print("📌 Opciones:")
        print("   [1] Buscar por nombre")
        print("   [2] Ingresar código")
        print("   [3] Ver lista")
        print("   [4] Finalizar")
        print("="*60)
        
        while True:
            opt = input(f"{self.COLOR_AMARILLO}🔹 Opción: {self.COLOR_RESET}").strip()
            
            if opt == '4':
                break
                
            if opt == '3':
                self._mostrar_lista_articulos()
                cod = input("Código: ").strip()
                art = self.articulo_service.buscar_por_codigo(cod) or self.articulo_service.buscar_por_codigo_barras(cod)
                if not art:
                    print("❌ No encontrado")
                    continue
            elif opt == '2':
                cod = input("Código: ").strip()
                art = self.articulo_service.buscar_por_codigo(cod) or self.articulo_service.buscar_por_codigo_barras(cod)
                if not art:
                    print("❌ No encontrado")
                    continue
            elif opt == '1':
                nom = input("Nombre: ").strip()
                res = self.articulo_service.buscar_por_nombre(nom)
                if not res:
                    print("❌ No encontrado")
                    continue
                if len(res) == 1:
                    art = res[0]
                else:
                    for i, a in enumerate(res, 1):
                        print(f"  {i}. {a['nombre']}")
                    try:
                        s = int(input("Seleccione: ")) - 1
                        art = res[s] if 0 <= s < len(res) else None
                    except:
                        continue
                    if not art:
                        continue
            else:
                print("❌ Opción inválida")
                continue
            
            # Procesar artículo
            try:
                precio = float(art.get('precio_venta', 0))
            except:
                precio = 0.0
                
            stock = self.inventario_service.obtener_stock_articulo(art['idarticulo'])
            print(f"\n📌 {art['nombre']} - ${precio:.2f} - Stock: {stock}")
            
            try:
                cant = int(input("Cantidad: "))
                if cant <= 0 or cant > stock:
                    print("❌ Cantidad inválida")
                    continue
            except:
                print("❌ Cantidad inválida")
                continue
            
            subtotal = cant * precio
            print(f"   Subtotal: ${subtotal:.2f} = Bs. {subtotal * tasa_usd:.2f}")
            
            detalle.append({
                'idarticulo': art['idarticulo'],
                'cantidad': cant,
                'precio_venta': precio,
                'nombre': art['nombre']
            })
            print("✅ Agregado")
        
        if not detalle:
            print("❌ Sin productos")
            self.pausa()
            return
        
        # ===== RESUMEN =====
        total = sum(d['cantidad'] * d['precio_venta'] for d in detalle)
        iva = total * 0.16
        total_iva = total + iva
        total_bs = total_iva * tasa_usd
        
        print("\n" + "="*60)
        print("📋 RESUMEN")
        print("="*60)
        for d in detalle:
            print(f"  {d['nombre']:<30} x{d['cantidad']}  ${d['precio_venta']:.2f}")
        print("-"*60)
        print(f"SUBTOTAL: ${total:.2f}")
        print(f"IVA 16%:  ${iva:.2f}")
        print(f"TOTAL:    ${total_iva:.2f} = Bs. {total_bs:.2f}")
        print("="*60)
        
        if input("¿Confirmar? (s/N): ").lower() != 's':
            print("Cancelado")
            self.pausa()
            return
        
        # ===== REGISTRAR =====
        idv = self.venta_service.registrar(
            usuario['idtrabajador'], idcliente, tipo_comp,
            serie, numero, 16.0, detalle,
            moneda='USD', moneda_pago=moneda_pago, tasa_cambio=tasa_usd
        )
        
        if idv:
            print(f"\n✅ Venta #{idv} registrada")
        else:
            print("❌ Error")
        
        self.pausa()

    def _continuar_flujo_venta(self, usuario, idcliente, cliente, opcion_ident):
        """Continuación del flujo de venta después de seleccionar cliente"""
        
        # Obtener tasas actuales
        tasas_actuales = self.obtener_tasas_actuales()
        tasa_usd = tasas_actuales.get('USD', 0)
        
        # ===== MONEDA DE PAGO =====
        print("\n" + "="*60)
        print("💳 MONEDA DE PAGO")
        print("="*60)
        print("1. Dólares (USD)")
        print("2. Bolívares (VES)")
        print("3. Euros (EUR)")
        opcion_pago = input(f"{self.COLOR_AMARILLO}🔹 Seleccione moneda de pago: {self.COLOR_RESET}").strip()
        
        moneda_pago_map = {'1': 'USD', '2': 'VES', '3': 'EUR'}
        moneda_pago = moneda_pago_map.get(opcion_pago, 'USD')
        
        # ===== DATOS DEL COMPROBANTE =====
        print("\n" + "="*60)
        print("📄 DATOS DEL COMPROBANTE")
        print("="*60)
        
        if opcion_ident == '1':
            print("Tipo de comprobante:")
            print("  1. Factura (con RIF)")
            tipo_op = '1'
            tipo_comprobante = 'FACTURA'
        elif opcion_ident == '2':
            print("Tipo de comprobante:")
            print("  1. Factura (con Cédula)")
            print("  2. Boleta (consumo)")
            tipo_op = input(f"{self.COLOR_AMARILLO}Seleccione: {self.COLOR_RESET}").strip()
            tipo_comprobante = 'FACTURA' if tipo_op == '1' else 'BOLETA'
        else:
            print("Tipo de comprobante:")
            print("  1. Boleta (consumo final)")
            print("  2. Ticket (consumo final)")
            tipo_map = {'1': 'BOLETA', '2': 'TICKET'}
            tipo_op = input(f"{self.COLOR_AMARILLO}Seleccione: {self.COLOR_RESET}").strip()
            tipo_comprobante = tipo_map.get(tipo_op, 'BOLETA')
        
        serie = input("Serie (ej. F001): ")
        numero = input("Número: ")
        
        # ===== AGREGAR PRODUCTOS =====
        detalle = []
        print("\n" + "="*50)
        print("🛒 AGREGAR PRODUCTOS")
        print("="*50)
        print(f"{self.COLOR_VERDE}💡 Use '?' para ver lista, '*' para búsqueda avanzada{self.COLOR_RESET}")
        print(f"{self.COLOR_AMARILLO}💰 Tasa USD actual: Bs. {tasa_usd:.2f}{self.COLOR_RESET}")
        
        while True:
            print("\n--- Agregar producto ---")
            entrada = input("Código/PLU (0=terminar, ?=lista, *=búsqueda): ").lower()
            
            if entrada == '0':
                break
            elif entrada == '?':
                self._mostrar_lista_articulos()
                continue
            elif entrada == '*':
                art = self._buscar_articulo_para_venta()
                if not art:
                    continue
            else:
                art = self.articulo_service.buscar_por_codigo(entrada)
                if not art:
                    art = self.articulo_service.buscar_por_codigo_barras(entrada)
            
            if not art:
                print(f"{self.COLOR_ROJO}❌ Artículo no encontrado. Use '*' para búsqueda avanzada{self.COLOR_RESET}")
                continue
            
            precio_usd = art.get('precio_venta', 0)
            stock = self.inventario_service.obtener_stock_articulo(art['idarticulo'])
            
            print(f"📌 Artículo: {art['nombre']}")
            print(f"   Precio: ${precio_usd:.2f} USD")
            print(f"   Stock: {stock} und")
            
            try:
                if art.get('tipo_medida') == 'PESO':
                    cantidad = float(input("Cantidad (kg): "))
                else:
                    cantidad = int(input("Cantidad (unidades): "))
                
                if cantidad > stock and art.get('tipo_medida') != 'PESO':
                    print(f"❌ Stock insuficiente")
                    continue
            except:
                print("❌ Cantidad inválida")
                continue
            
            detalle.append({
                'idarticulo': art['idarticulo'],
                'cantidad': cantidad,
                'precio_venta': precio_usd,
                'nombre': art['nombre']
            })
            print(f"✅ {art['nombre']} agregado")
        
        if not detalle:
            print("❌ Debe agregar al menos un producto")
            self.pausa()
            return
        
        # ===== RESUMEN =====
        total_usd = sum(item['cantidad'] * item['precio_venta'] for item in detalle)
        iva_usd = total_usd * 0.16
        total_con_iva_usd = total_usd + iva_usd
        total_bs = total_con_iva_usd * tasa_usd
        
        print("\n" + "="*50)
        print("📋 RESUMEN DE VENTA")
        print("="*50)
        for item in detalle:
            print(f"  - {item['nombre']}: {item['cantidad']} x ${item['precio_venta']:.2f} = ${item['cantidad'] * item['precio_venta']:.2f}")
        print(f"\n💰 TOTAL USD: ${total_con_iva_usd:.2f}")
        print(f"💰 TOTAL Bs.: Bs. {total_bs:.2f} (tasa {tasa_usd:.2f})")
        print("="*50)
        
        confirmar = input(f"{self.COLOR_AMARILLO}¿Confirmar venta? (s/N): {self.COLOR_RESET}").lower()
        if confirmar != 's':
            print("Operación cancelada")
            self.pausa()
            return
        
        # ===== REGISTRAR =====
        idventa = self.venta_service.registrar(
            usuario['idtrabajador'], 
            idcliente,
            tipo_comprobante,
            serie, 
            numero, 
            16.0,
            detalle,
            moneda='USD',
            moneda_pago=moneda_pago,
            tasa_cambio=tasa_usd
        )
        
        if idventa:
            print(f"\n{self.COLOR_VERDE}✅ Venta #{idventa} registrada correctamente{self.COLOR_RESET}")
            self.registrar_auditoria(
                accion="CREAR",
                tabla="venta",
                registro_id=idventa,
                datos_nuevos=f"Venta #{idventa} - Total: ${total_con_iva_usd:.2f} (Bs. {total_bs:.2f})"
            )
        else:
            print(f"\n{self.COLOR_ROJO}❌ Error al registrar la venta{self.COLOR_RESET}")
        
        self.pausa()

    def _imprimir_factura_rapido(self, usuario):
        """Atajo para imprimir la última factura o buscar por ID"""
        import platform
        sistema = platform.system()
        atajo = "F11" if sistema == "Windows" else "4"
        
        print(f"\n{self.COLOR_VERDE}🖨️ IMPRIMIR FACTURA (Atajo {atajo}){self.COLOR_RESET}")
        print("="*60)
        print("1. Imprimir última factura")
        print("2. Buscar factura por ID")
        print("3. Volver")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            # Obtener la última venta
            ventas = self.venta_service.listar()
            if ventas:
                ultima_venta = ventas[0]
                self._imprimir_factura(ultima_venta['idventa'])
            else:
                print(f"{self.COLOR_ROJO}❌ No hay ventas registradas{self.COLOR_RESET}")
                self.pausa()
        
        elif opcion == '2':
            try:
                idventa = int(input("ID de la factura a imprimir: "))
                self._imprimir_factura(idventa)
            except:
                print(f"{self.COLOR_ROJO}❌ ID inválido{self.COLOR_RESET}")
                self.pausa()
        
        return self._registrar_venta()

    def _imprimir_factura(self, idventa):
        """Imprime una factura en formato texto"""
        venta = self.venta_service.obtener_por_id(idventa)
        
        if not venta:
            print(f"{self.COLOR_ROJO}❌ Factura {idventa} no encontrada{self.COLOR_RESET}")
            return
        
        print("\n" + "="*50)
        print("🖨️ IMPRIMIENDO FACTURA")
        print("="*50)
        print(f"FACTURA #{venta['idventa']}")
        print(f"Fecha: {venta['fecha']}")
        print(f"Cliente: {venta.get('cliente', 'CONSUMIDOR FINAL')}")
        print(f"Comprobante: {venta['tipo_comprobante']} {venta['serie']}-{venta['numero_comprobante']}")
        print("-"*50)
        print("PRODUCTOS:")
        total = 0
        for d in venta.get('detalle', []):
            subtotal = d['cantidad'] * d['precio_venta']
            total += subtotal
            print(f"  {d['articulo']} x{d['cantidad']} @ {d['precio_venta']:.2f} = {subtotal:.2f}")
        print("-"*50)
        print(f"TOTAL: {total:.2f}")
        print("="*50)
        print("¡Gracias por su compra!")
        print("="*50)
        
        # Aquí iría la lógica para enviar a impresora física
        print(f"\n{self.COLOR_VERDE}✅ Factura enviada a imprimir{self.COLOR_RESET}")
        self.pausa()

    def _buscar_por_cedula_rapido(self, usuario):
        """Búsqueda rápida por cédula (compatible Windows/Linux)"""
        import platform
        sistema = platform.system()
        atajo = "F9" if sistema == "Windows" else "2"
        print(f"\n{self.COLOR_VERDE}🔍 BÚSQUEDA RÁPIDA POR CÉDULA (Atajo {atajo}){self.COLOR_RESET}")
        print("="*60)
        
        cedula = input("Ingrese cédula (ej: V12345678): ").upper()
        
        if not (cedula.startswith('V') or cedula.startswith('E')):
            print(f"{self.COLOR_ROJO}❌ Formato inválido{self.COLOR_RESET}")
            self.pausa()
            return self._registrar_venta()
        
        cliente_simple = self.cliente_service.buscar_por_documento(cedula)
        
        if cliente_simple:
            idcliente = cliente_simple['idcliente']
            cliente = self.cliente_service.obtener_por_id(idcliente)
            print(f"{self.COLOR_VERDE}✅ Cliente encontrado: {cliente['nombre']} {cliente['apellidos']}{self.COLOR_RESET}")
            
            if cliente['tipo_documento'] in ['V', 'E']:
                opcion_ident = '2'
            else:
                opcion_ident = '1'
            
            return self._continuar_flujo_venta(usuario, idcliente, cliente, opcion_ident)
        else:
            print(f"{self.COLOR_AMARILLO}⚠️ Cliente no encontrado{self.COLOR_RESET}")
            print("1. Registrar nuevo cliente")
            print("2. Continuar como consumidor final")
            print("3. Volver")
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._crear_cliente()
                return self._registrar_venta()
            elif opcion == '2':
                return self._continuar_venta_consumidor_final(usuario)
            else:
                return self._registrar_venta()

    def _buscar_por_rif_rapido(self, usuario):
        """Búsqueda rápida por RIF (compatible Windows/Linux)"""
        import platform
        sistema = platform.system()
        atajo = "F10" if sistema == "Windows" else "3"
        print(f"\n{self.COLOR_VERDE}🔍 BÚSQUEDA RÁPIDA POR RIF (Atajo {atajo}){self.COLOR_RESET}")
        print("="*60)
        
        rif = input("Ingrese RIF (ej: J123456789): ").upper()
        
        if not rif:
            print(f"{self.COLOR_ROJO}❌ RIF no ingresado{self.COLOR_RESET}")
            self.pausa()
            return self._registrar_venta()
        
        cliente_simple = self.cliente_service.buscar_por_documento(rif)
        
        if cliente_simple:
            idcliente = cliente_simple['idcliente']
            cliente = self.cliente_service.obtener_por_id(idcliente)
            print(f"{self.COLOR_VERDE}✅ Cliente encontrado: {cliente['nombre']} {cliente['apellidos']}{self.COLOR_RESET}")
            
            if cliente['tipo_documento'] in ['J', 'G', 'C']:
                opcion_ident = '1'
            else:
                opcion_ident = '2'
            
            return self._continuar_flujo_venta(usuario, idcliente, cliente, opcion_ident)
        else:
            print(f"{self.COLOR_AMARILLO}⚠️ Cliente con RIF {rif} no encontrado{self.COLOR_RESET}")
            print("1. Registrar nuevo cliente")
            print("2. Volver")
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._crear_cliente()
                return self._registrar_venta()
            else:
                return self._registrar_venta()

    def _continuar_venta_consumidor_final(self, usuario):
        """Continúa con venta a consumidor final"""
        print(f"\n{self.COLOR_VERDE}🛒 Venta a CONSUMIDOR FINAL{self.COLOR_RESET}")
        idcliente = None
        cliente = None
        opcion_ident = '3'
        
        return self._continuar_flujo_venta(usuario, idcliente, cliente, opcion_ident)
    
    def _continuar_venta_con_cliente(self, idcliente, cliente):
        """Continúa el flujo de venta con un cliente ya seleccionado"""
        # Aquí iría la continuación de la venta
        # Por ahora, redirigimos al método principal con los datos
        print(f"\nContinuando venta con cliente: {cliente['nombre']} {cliente['apellidos']}")
        # Este método debería continuar con el flujo normal
        # Por ahora, volvemos al menú principal de ventas
        self.pausa()
        self.menu_ventas()
    
    def _mostrar_lista_articulos(self):
        """Muestra lista de artículos disponibles con precios"""
        articulos = self.articulo_service.listar()
        print("\n" + "="*107)
        print("📋 LISTADO DE ARTÍCULOS DISPONIBLES")
        print("="*107)
        print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'CATEGORÍA':<20} {'PRECIO $':<12} {'STOCK':<10}")
        print("-" * 107)
        for a in articulos:
            stock = self.inventario_service.obtener_stock_articulo(a['idarticulo'])
            precio = float(a.get('precio_venta', 0))
            
            # Formatear precio
            if precio == int(precio):
                precio_str = f"${int(precio)}"
            else:
                precio_str = f"${precio:.2f}".rstrip('0').rstrip('.')
            
            print(f"{a['idarticulo']:<5} {a['codigo']:<15} {a['nombre']:<30} {a.get('categoria', 'N/A'):<20} {precio_str:<12} {stock} und")
        print("-" * 107)

    # ======================================================
    # NUEVOS MÉTODOS DE BÚSQUEDA PARA VENTAS
    # ======================================================
    
    def _buscar_articulo_para_venta(self):
        """
        Menú de búsqueda de artículos durante la venta
        """
        self.mostrar_cabecera("🔍 BUSCAR ARTÍCULO")
        
        print("Opciones de búsqueda:")
        print("1. 🔎 Escanear código de barras")
        print("2. ⌨️ Ingresar código manualmente")
        print("3. 📝 Buscar por nombre")
        print("4. ↩️ Volver")
        
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            codigo = input("Ingrese código de barras: ").strip()
            return self._buscar_articulo_por_codigo(codigo)
        
        elif opcion == '2':
            codigo = input("Ingrese código manual: ").strip()
            art = self.articulo_service.buscar_por_codigo(codigo)
            if not art:
                art = self.articulo_service.buscar_por_codigo_barras(codigo)
            if art:
                return art
            print(f"{self.COLOR_ROJO}❌ Artículo no encontrado{self.COLOR_RESET}")
            return None
        
        elif opcion == '3':
            termino = input("Ingrese nombre: ").strip()
            # CORREGIDO: usar _buscar_articulo_por_nombre en lugar de _buscar_por_nombre
            return self._buscar_articulo_por_nombre(termino)
        
        else:
            return None
    
    def _buscar_articulo_por_codigo(self, codigo):
        """
        NUEVO: Busca artículo por código de barras (con soporte para balanza)
        """
        # Intentar buscar por código de barras exacto
        articulo = self.articulo_service.buscar_por_codigo_barras(codigo)
        
        if articulo:
            return articulo
        
        # Si no encuentra, verificar si es código de balanza (prefijo 21)
        if codigo.startswith('21') and len(codigo) == 13:
            return self._procesar_codigo_balanza(codigo)
        
        print(f"{self.COLOR_ROJO}❌ Artículo no encontrado{self.COLOR_RESET}")
        return None
    
    def _procesar_codigo_balanza(self, codigo):
        """
        Procesa códigos de balanza (prefijo 21)
        """
        try:
            # Extraer PLU (posiciones 3-7)
            plu = codigo[2:7].lstrip('0') or '0'
            
            # Extraer peso (posiciones 8-12) convertido a kg
            peso_gramos = int(codigo[7:12])
            peso_kg = peso_gramos / 1000
            
            # Buscar artículo por PLU
            articulo = self.articulo_service.buscar_por_plu(plu)
            
            if articulo:
                # Crear una copia del artículo con datos calculados
                resultado = articulo.copy()
                
                if articulo.get('es_pesado'):
                    precio_por_kilo = float(articulo.get('precio_por_kilo', 0))
                    precio_calculado = precio_por_kilo * peso_kg
                    resultado['precio_calculado'] = precio_calculado
                    resultado['cantidad'] = peso_kg
                    resultado['unidad'] = 'kg'
                    print(f"✅ {articulo['nombre']} - {peso_kg:.3f} kg")
                
                return resultado
            
        except Exception as e:
            logger.error(f"Error procesando código de balanza: {e}")
        
        return None
    
    def _buscar_articulo_por_nombre(self, termino):
        """
        NUEVO: Busca artículos por nombre y muestra lista para seleccionar
        """
        resultados = self.articulo_service.buscar_por_nombre(termino)
        
        if not resultados:
            print(f"{self.COLOR_ROJO}❌ No se encontraron artículos{self.COLOR_RESET}")
            return None
        
        print(f"\n{self.COLOR_VERDE}📋 RESULTADOS ({len(resultados)}):{self.COLOR_RESET}")
        print(f"{'#':<3} {'CÓDIGO':<15} {'NOMBRE':<50} {'PRECIO':<10}")
        print("-" * 78)
        
        for i, art in enumerate(resultados, 1):
            precio = art.get('precio_venta', 0)
            print(f"{i:<3} {art['codigo']:<15} {art['nombre']:<50} {precio:>10.2f}")
        
        try:
            seleccion = input(f"\n{self.COLOR_AMARILLO}Seleccione número (Enter para cancelar): {self.COLOR_RESET}").strip()
            if seleccion:
                idx = int(seleccion) - 1
                if 0 <= idx < len(resultados):
                    return resultados[idx]
        except:
            pass
        
        return None

    # ======================================================
    # NUEVOS MÉTODOS DE BÚSQUEDA PARA GESTIÓN DE ARTÍCULOS
    # ======================================================
    
    def _buscar_articulo_gestion(self):
        """
        NUEVO: Busca artículos en gestión (por código o nombre)
        """
        self.mostrar_cabecera("🔍 BUSCAR ARTÍCULO")
        
        print("Buscar por:")
        print("1. 📦 Código de barras")
        print("2. 📝 Nombre")
        print("3. 🔢 Código interno (PLU)")
        print("4. ↩️ Volver")
        
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            codigo = input("Ingrese código de barras: ").strip()
            self._mostrar_resultado_busqueda(codigo, 'codigo')
        
        elif opcion == '2':
            termino = input("Ingrese nombre: ").strip()
            self._mostrar_resultado_busqueda(termino, 'nombre')
        
        elif opcion == '3':
            plu = input("Ingrese PLU: ").strip()
            self._mostrar_resultado_busqueda(plu, 'plu')
        
        self.pausa()
    
    def _mostrar_resultado_busqueda(self, valor, tipo):
        """
        Muestra resultados de búsqueda según el tipo
        """
        if tipo == 'codigo':
            articulo = self.articulo_service.buscar_por_codigo_barras(valor)
            if articulo:
                self._mostrar_detalle_articulo(articulo)
            else:
                print(f"{self.COLOR_ROJO}❌ Artículo no encontrado{self.COLOR_RESET}")
        
        elif tipo == 'plu':
            articulo = self.articulo_service.buscar_por_plu(valor)
            if articulo:
                self._mostrar_detalle_articulo(articulo)
            else:
                print(f"{self.COLOR_ROJO}❌ Artículo con PLU {valor} no encontrado{self.COLOR_RESET}")
        
        elif tipo == 'nombre':
            resultados = self.articulo_service.buscar_por_nombre(valor)
            if resultados:
                print(f"\n{self.COLOR_VERDE}📋 RESULTADOS ({len(resultados)}):{self.COLOR_RESET}")
                print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<40} {'PRECIO':<12}")
                print("-" * 72)
                for art in resultados:
                    precio = art.get('precio_venta', 0)
                    print(f"{art['idarticulo']:<5} {art['codigo']:<15} {art['nombre']:<40} Bs.{precio:>10,.2f}")
                
                # Opción de editar desde resultados
                print("\n" + "-" * 30)
                editar = input(f"{self.COLOR_AMARILLO}¿Editar algún artículo? (ID o Enter para continuar): {self.COLOR_RESET}").strip()
                if editar.isdigit():
                    self._editar_articulo_por_id(int(editar))
            else:
                print(f"{self.COLOR_ROJO}❌ No se encontraron artículos{self.COLOR_RESET}")
    
    @requiere_permiso('ventas_ver')
    def _listar_ventas(self):
        """Lista todas las ventas con fecha, hora y montos"""
        self.mostrar_cabecera("LISTADO DE VENTAS")
        
        ventas = self.venta_service.listar()
        
        if not ventas:
            print("📭 No hay ventas registradas")
        else:
            # Cabecera con columna de MONTO
            print(f"{'ID':<5} {'FECHA Y HORA':<19} {'COMPROBANTE':<20} {'CLIENTE':<20} {'MONTO':<15} {'ESTADO':<10}")
            print("-" * 89)
            
            for v in ventas:
                comp = f"{v['tipo_comprobante']} {v['serie']}-{v['numero_comprobante']}"
                
                # Manejar cliente
                cliente_nombre = v.get('cliente')
                if cliente_nombre is None:
                    cliente_nombre = 'CONSUMIDOR FINAL'
                
                # Truncar cliente si es muy largo
                if len(cliente_nombre) > 20:
                    cliente_nombre = cliente_nombre[:17] + "..."
                
                # Determinar monto y moneda
                moneda = v.get('moneda', 'VES')
                
                if moneda == 'USD':
                    monto = v.get('monto_divisa', 0)
                    if monto:
                        monto_str = f"${monto:,.2f}"
                    else:
                        monto_str = "$0.00"
                elif moneda == 'EUR':
                    monto = v.get('monto_divisa', 0)
                    if monto:
                        monto_str = f"€{monto:,.2f}"
                    else:
                        monto_str = "€0.00"
                else:  # VES
                    monto = v.get('monto_bs', v.get('total', 0))
                    if monto:
                        monto_str = f"Bs. {monto:,.2f}".replace(',', ' ')
                    else:
                        monto_str = "Bs. 0.00"
                
                # Truncar monto si es muy largo
                if len(monto_str) > 15:
                    monto_str = monto_str[:12] + "..."
                
                print(f"{v['idventa']:<5} {v['fecha']:<19} {comp:<20} {cliente_nombre:<20} {monto_str:<15} {v['estado']:<10}")
        
        self.pausa()

    def _ver_venta(self):
        """Muestra detalle de una venta con hora exacta"""
        self.mostrar_cabecera("DETALLE DE VENTA")
        
        try:
            idventa = int(input("ID de la venta: "))
            venta = self.venta_service.obtener_por_id(idventa)
            
            if not venta:
                print(f"❌ No existe venta con ID {idventa}")
                self.pausa()
                return
            
            print(f"\n📌 Venta N°: {venta['idventa']}")
            print(f"📌 Fecha y Hora: {venta['fecha']}")
            
            # CORREGIDO: Manejar cliente cuando es None
            cliente_nombre = venta.get('cliente')
            if cliente_nombre is None:
                cliente_nombre = 'CONSUMIDOR FINAL'
                
            print(f"📌 Cliente: {cliente_nombre}")
            print(f"📌 Comprobante: {venta['tipo_comprobante']} {venta['serie']}-{venta['numero_comprobante']}")
            print(f"📌 IGV: {venta['igv']}%")
            print(f"📌 Estado: {venta['estado']}")
            print(f"📌 Trabajador: {venta['trabajador']}")
            
            if venta.get('detalle'):
                print("\n📋 DETALLE:")
                total = 0
                for d in venta['detalle']:
                    subtotal = d['cantidad'] * d['precio_venta']
                    total += subtotal
                    print(f"   - {d['articulo']} x{d['cantidad']} @ {d['precio_venta']:.2f} = {subtotal:.2f}")
                print(f"\n💰 TOTAL: {total:.2f}")
                
            print("\n📋 REGISTROS DE AUDITORÍA:")
            logs = self.auditoria_service.consultar_por_tabla("venta", idventa)
            for log in logs:
                fecha_log = log['fecha_hora'].strftime('%d/%m/%Y %H:%M') if hasattr(log['fecha_hora'], 'strftime') else log['fecha_hora']
                print(f"   - {fecha_log}: {log['accion']}")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    def _anular_venta(self):
        """Anula una venta"""
        self.mostrar_cabecera("ANULAR VENTA")
        
        try:
            idventa = int(input("ID de la venta a anular: "))
            venta = self.venta_service.obtener_por_id(idventa)
            
            if not venta:
                print(f"❌ No existe venta con ID {idventa}")
                self.pausa()
                return
            
            if venta['estado'] == 'ANULADO':
                print("⚠️ Esta venta ya está anulada")
                self.pausa()
                return
            
            cliente_nombre = venta.get('cliente', 'CONSUMIDOR FINAL')
            print(f"\nVenta: {venta['idventa']} - {venta['fecha']}")
            print(f"Cliente: {cliente_nombre}")
            total = sum(d['cantidad'] * d['precio_venta'] for d in venta.get('detalle', []))
            print(f"Total: {total:.2f}")
            
            confirmacion = input(f"{self.COLOR_AMARILLO}\n¿Está seguro de anular esta venta? (s/N): {self.COLOR_RESET}").lower()
            if confirmacion == 's':
                if self.venta_service.anular(idventa):
                    print(f"{self.COLOR_VERDE}✅ Venta anulada correctamente{self.COLOR_RESET}")
                    
                    self.registrar_auditoria(
                        accion="ANULAR",
                        tabla="venta",
                        registro_id=idventa,
                        datos_nuevos=f"Venta #{idventa} anulada - Total: Bs.{total:.2f}"
                    )
                else:
                    print(f"{self.COLOR_ROJO}❌ Error al anular la venta{self.COLOR_RESET}")
            else:
                print("Operación cancelada")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('proveedores_ver')
    def menu_proveedores(self):
        """Menú de gestión de proveedores"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE PROVEEDORES")
            print("1. Listar proveedores")
            print("2. Buscar proveedor")
            print("3. Crear proveedor")
            print("4. Editar proveedor")
            print("5. Eliminar proveedor")
            print("6. 📁 Ver todos los archivos de proveedores")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._listar_proveedores()
            elif opcion == '2':
                self._buscar_proveedor()
            elif opcion == '3':
                self._crear_proveedor()
            elif opcion == '4':
                self._editar_proveedor()
            elif opcion == '5':
                self._eliminar_proveedor()
            elif opcion == '6':
                self._listar_todos_archivos()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    @requiere_permiso('proveedores_crear')
    def _crear_proveedor(self):
        """Crea un nuevo proveedor"""
        self.mostrar_cabecera("CREAR PROVEEDOR")
        
        print("📝 Complete los datos del proveedor:")
        print()
        
        razon_social = input("Razón Social / Nombre: ")
        sector = input("Sector Comercial: ")
        
        print("\n" + "="*60)
        print("🔍 TIPO DE PERSONA - FORMATO DEL DOCUMENTO")
        print("="*60)
        print("1. 🇻🇪 Persona Natural Venezolana  →  V12345678")
        print("2. 🌎 Persona Natural Extranjera   →  E87654321")
        print("3. 🏢 Persona Jurídica (Empresa)   →  J12345678")
        print("4. 🏛️ Gobierno / Institución        →  G12345678")
        print("5. 👥 Consejo Comunal               →  C12345678")
        print("6. 🛂 Pasaporte                      →  Número de pasaporte")
        print("="*60)
        
        tipo_persona = input("Seleccione tipo de persona (1-6): ").strip()
        
        if tipo_persona == '1':
            tipo_doc = 'V'
            print("\n✅ Seleccionó: Persona Natural Venezolana (V)")
            print("📝 Formato requerido: V + 8 dígitos")
            print("   Ejemplo: V12345678")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('V'):
                print("❌ El documento debe comenzar con 'V'")
                self.pausa()
                return
            num_doc = num_doc[1:]
            
        elif tipo_persona == '2':
            tipo_doc = 'E'
            print("\n✅ Seleccionó: Persona Natural Extranjera (E)")
            print("📝 Formato requerido: E + 8 dígitos")
            print("   Ejemplo: E87654321")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('E'):
                print("❌ El documento debe comenzar con 'E'")
                self.pausa()
                return
            num_doc = num_doc[1:]
            
        elif tipo_persona == '3':
            tipo_doc = 'J'
            print("\n✅ Seleccionó: Empresa (J)")
            print("📝 Formato requerido: J + 8 dígitos")
            print("   Ejemplo: J12345678")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('J'):
                print("❌ El documento debe comenzar con 'J'")
                self.pausa()
                return
            num_doc = num_doc[1:]
            
        elif tipo_persona == '4':
            tipo_doc = 'G'
            print("\n✅ Seleccionó: Gobierno / Institución (G)")
            print("📝 Formato requerido: G + 8 dígitos")
            print("   Ejemplo: G12345678")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('G'):
                print("❌ El documento debe comenzar con 'G'")
                self.pausa()
                return
            num_doc = num_doc[1:]
            
        elif tipo_persona == '5':
            tipo_doc = 'C'
            print("\n✅ Seleccionó: Consejo Comunal (C)")
            print("📝 Formato requerido: C + 8 dígitos")
            print("   Ejemplo: C12345678")
            num_doc = input("Documento completo: ").upper()
            
            if not num_doc.startswith('C'):
                print("❌ El documento debe comenzar con 'C'")
                self.pausa()
                return
            num_doc = num_doc[1:]
            
        elif tipo_persona == '6':
            tipo_doc = 'PASAPORTE'
            print("\n✅ Seleccionó: Pasaporte")
            print("📝 Ingrese número de pasaporte (6-12 caracteres)")
            print("   Ejemplo: ABC123456")
            num_doc = input("Pasaporte: ").upper()
            
        else:
            print("❌ Opción no válida")
            self.pausa()
            return
        
        direccion = input("\nDirección (opcional): ") or None
        telefono = input("Teléfono (opcional): ") or None
        email = input("Email (opcional): ") or None
        url = input("URL (opcional): ") or None
        
        if self.proveedor_service.crear(
            razon_social, sector, tipo_doc, num_doc,
            direccion, telefono, email, url
        ):
            print("\n✅ Proveedor creado exitosamente")
            
            self.registrar_auditoria(
                accion="CREAR",
                tabla="proveedor",
                registro_id=self.proveedor_service.buscar_por_documento(tipo_doc+num_doc)['idproveedor'],
                datos_nuevos=f"Proveedor: {razon_social}, Doc: {tipo_doc}-{num_doc}"
            )
        else:
            print("\n❌ Error al crear el proveedor")
        
        self.pausa()
    
    @requiere_permiso('proveedores_ver')
    def _listar_proveedores(self):
        """Lista todos los proveedores"""
        self.mostrar_cabecera("LISTADO DE PROVEEDORES")
        
        proveedores = self.proveedor_service.listar()
        
        if not proveedores:
            print("📭 No hay proveedores registrados")
        else:
            print(f"{'ID':<5} {'RAZÓN SOCIAL':<30} {'DOCUMENTO':<20} {'TELÉFONO':<15} {'ARCHIVOS':<10}")
            print("-" * 80)
            for p in proveedores:
                archivos = self.proveedor_archivo_service.listar_archivos_proveedor(p['idproveedor'])
                tiene_archivos = "📁" if archivos else ""
                documento = f"{p['tipo_documento']}-{p['num_documento']}"
                telefono_val = p.get('telefono', '') or ''
                print(f"{p['idproveedor']:<5} {p['razon_social']:<30} {documento:<20} {telefono_val:<15} {tiene_archivos:<10}")
        
        self.pausa()
    
    @requiere_permiso('proveedores_ver')
    def _buscar_proveedor(self):
        """Busca un proveedor por ID o documento"""
        self.mostrar_cabecera("BUSCAR PROVEEDOR")
        
        print("1. Buscar por ID")
        print("2. Buscar por documento")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            try:
                idprov = int(input("ID del proveedor: "))
                proveedor = self.proveedor_service.obtener_por_id(idprov)
                if proveedor:
                    self._mostrar_detalle_proveedor(proveedor)
                    
                    self.registrar_auditoria(
                        accion="CONSULTAR",
                        tabla="proveedor",
                        registro_id=idprov,
                        datos_nuevos=f"Proveedor: {proveedor['razon_social']}"
                    )
                else:
                    print(f"❌ No existe proveedor con ID {idprov}")
            except:
                print("❌ ID inválido")
        
        elif opcion == '2':
            doc = input("Número de documento (ej: J12345678): ").upper()
            if doc and doc[0] in ['V', 'E', 'J', 'G', 'C']:
                tipo = doc[0]
                numero = doc[1:]
                proveedores = self.proveedor_service.listar()
                encontrado = None
                for p in proveedores:
                    if p['tipo_documento'] == tipo and p['num_documento'] == numero:
                        encontrado = p
                        break
                if encontrado:
                    self._mostrar_detalle_proveedor(encontrado)
                    
                    self.registrar_auditoria(
                        accion="CONSULTAR",
                        tabla="proveedor",
                        registro_id=encontrado['idproveedor'],
                        datos_nuevos=f"Búsqueda por documento: {doc}"
                    )
                else:
                    print(f"❌ No existe proveedor con documento {doc}")
            else:
                print("❌ Formato de documento inválido")
        
        self.pausa()
    
    def _mostrar_detalle_proveedor(self, p):
        """Muestra detalles completos de un proveedor"""
        print(f"\n📌 ID: {p['idproveedor']}")
        print(f"📌 Razón Social: {p['razon_social']}")
        print(f"📌 Sector Comercial: {p.get('sector_comercial', 'No especificado')}")
        print(f"📌 Documento: {p['tipo_documento']}-{p['num_documento']}")
        print(f"📌 Dirección: {p.get('direccion', 'No registrada')}")
        print(f"📌 Teléfono: {p.get('telefono', 'No registrado')}")
        print(f"📌 Email: {p.get('email', 'No registrado')}")
        print(f"📌 URL: {p.get('url', 'No registrada')}")
        
        archivos = self.proveedor_archivo_service.listar_archivos_proveedor(p['idproveedor'])
        if archivos:
            print(f"\n📁 ARCHIVOS ASOCIADOS ({len(archivos)}):")
            for a in archivos:
                tamano = self.proveedor_archivo_service.obtener_tamano_legible(a['tamano'])
                print(f"   - {a['nombre_archivo']} ({tamano})")
        else:
            print("\n📁 No hay archivos asociados")
    
    @requiere_permiso('proveedores_editar')
    def _editar_proveedor(self):
        """Edita un proveedor existente"""
        self.mostrar_cabecera("EDITAR PROVEEDOR")
        
        try:
            idprov = int(input("ID del proveedor a editar: "))
            proveedor = self.proveedor_service.obtener_por_id(idprov)
            
            if not proveedor:
                print(f"❌ No existe proveedor con ID {idprov}")
                self.pausa()
                return
            
            print(f"\nEditando: {proveedor['razon_social']}")
            print("(Deje en blanco para mantener el valor actual)")
            print()
            
            datos_anteriores = f"Proveedor: {proveedor['razon_social']}, Doc: {proveedor['tipo_documento']}-{proveedor['num_documento']}"
            
            razon = input(f"Razón Social [{proveedor['razon_social']}]: ") or proveedor['razon_social']
            sector = input(f"Sector Comercial [{proveedor['sector_comercial']}]: ") or proveedor['sector_comercial']
            
            print("\n¿Cambiar tipo de documento? (s/N): ", end="")
            cambiar_tipo = input().lower()
            
            if cambiar_tipo == 's':
                print("\n" + "="*60)
                print("🔍 NUEVO TIPO DE DOCUMENTO")
                print("="*60)
                print("1. 🇻🇪 Venezolano (V) → V12345678")
                print("2. 🌎 Extranjero (E) → E87654321")
                print("3. 🏢 Empresa (J) → J12345678")
                print("4. 🏛️ Gobierno (G) → G12345678")
                print("5. 👥 Consejo Comunal (C) → C12345678")
                print("6. 🛂 Pasaporte → texto libre")
                print("="*60)
                
                tipo_op = input("Seleccione nuevo tipo (1-6): ").strip()
                
                if tipo_op == '1':
                    tipo_doc = 'V'
                    print("Ingrese documento completo (ej: V12345678):")
                    doc_completo = input("Documento: ").upper()
                    if doc_completo.startswith('V'):
                        num_doc = doc_completo[1:]
                    else:
                        print("❌ Debe comenzar con V")
                        self.pausa()
                        return
                elif tipo_op == '2':
                    tipo_doc = 'E'
                    print("Ingrese documento completo (ej: E87654321):")
                    doc_completo = input("Documento: ").upper()
                    if doc_completo.startswith('E'):
                        num_doc = doc_completo[1:]
                    else:
                        print("❌ Debe comenzar con E")
                        self.pausa()
                        return
                elif tipo_op == '3':
                    tipo_doc = 'J'
                    print("Ingrese documento completo (ej: J12345678):")
                    doc_completo = input("Documento: ").upper()
                    if doc_completo.startswith('J'):
                        num_doc = doc_completo[1:]
                    else:
                        print("❌ Debe comenzar con J")
                        self.pausa()
                        return
                elif tipo_op == '4':
                    tipo_doc = 'G'
                    print("Ingrese documento completo (ej: G12345678):")
                    doc_completo = input("Documento: ").upper()
                    if doc_completo.startswith('G'):
                        num_doc = doc_completo[1:]
                    else:
                        print("❌ Debe comenzar con G")
                        self.pausa()
                        return
                elif tipo_op == '5':
                    tipo_doc = 'C'
                    print("Ingrese documento completo (ej: C12345678):")
                    doc_completo = input("Documento: ").upper()
                    if doc_completo.startswith('C'):
                        num_doc = doc_completo[1:]
                    else:
                        print("❌ Debe comenzar con C")
                        self.pausa()
                        return
                elif tipo_op == '6':
                    tipo_doc = 'PASAPORTE'
                    num_doc = input("Número de pasaporte: ").upper()
                else:
                    print("❌ Opción no válida")
                    self.pausa()
                    return
            else:
                tipo_doc = proveedor['tipo_documento']
                num_doc = proveedor['num_documento']
            
            direccion = input(f"Dirección [{proveedor.get('direccion', '')}]: ") or proveedor.get('direccion')
            telefono = input(f"Teléfono [{proveedor.get('telefono', '')}]: ") or proveedor.get('telefono')
            email = input(f"Email [{proveedor.get('email', '')}]: ") or proveedor.get('email')
            url = input(f"URL [{proveedor.get('url', '')}]: ") or proveedor.get('url')
            
            if self.proveedor_service.actualizar(
                idprov, razon, sector, tipo_doc, num_doc,
                direccion, telefono, email, url
            ):
                print("\n✅ Proveedor actualizado correctamente")
                
                datos_nuevos = f"Proveedor: {razon}, Doc: {tipo_doc}-{num_doc}"
                self.registrar_auditoria(
                    accion="MODIFICAR",
                    tabla="proveedor",
                    registro_id=idprov,
                    datos_anteriores=datos_anteriores,
                    datos_nuevos=datos_nuevos
                )
            else:
                print("\n❌ Error al actualizar el proveedor")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('proveedores_eliminar')
    def _eliminar_proveedor(self):
        """Elimina un proveedor"""
        self.mostrar_cabecera("ELIMINAR PROVEEDOR")
        
        try:
            idprov = int(input("ID del proveedor a eliminar: "))
            
            proveedor = self.proveedor_service.obtener_por_id(idprov)
            if not proveedor:
                print(f"❌ No existe proveedor con ID {idprov}")
                self.pausa()
                return
            
            datos_proveedor = f"Proveedor: {proveedor['razon_social']}, Doc: {proveedor['tipo_documento']}-{proveedor['num_documento']}"
            
            print(f"\n¿Está seguro de eliminar a {proveedor['razon_social']}?")
            confirmacion = input("Esta acción no se puede deshacer (escriba 'ELIMINAR' para confirmar): ")
            
            if confirmacion == 'ELIMINAR':
                if self.proveedor_service.eliminar(idprov):
                    print("✅ Proveedor eliminado correctamente")
                    
                    self.registrar_auditoria(
                        accion="ELIMINAR",
                        tabla="proveedor",
                        registro_id=idprov,
                        datos_anteriores=datos_proveedor
                    )
                else:
                    print("❌ Error al eliminar el proveedor (puede tener ingresos asociados)")
            else:
                print("Operación cancelada")
        
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('proveedores_ver')
    def _menu_archivos_proveedor(self, idproveedor):
        """Menú de archivos de un proveedor específico"""
        proveedor = self.proveedor_service.obtener_por_id(idproveedor)
        if not proveedor:
            print(f"❌ No existe proveedor con ID {idproveedor}")
            self.pausa()
            return
        
        while True:
            self.mostrar_cabecera(f"ARCHIVOS DE: {proveedor['razon_social']}")
            
            archivos = self.proveedor_archivo_service.listar_archivos_proveedor(idproveedor)
            
            if archivos:
                print(f"📋 ARCHIVOS DE: {proveedor['razon_social']}")
                print(f"{'ID':<5} {'NOMBRE DEL ARCHIVO':<50} {'TIPO':<20} {'TAMAÑO':<10} {'FECHA':<20}")
                print("-" * 105)
                for a in archivos:
                    tamano = self.proveedor_archivo_service.obtener_tamano_legible(a['tamano'])
                    fecha = a['fecha_subida'].strftime('%Y-%m-%d %H:%M') if a['fecha_subida'] else ''
                    nombre = a['nombre_archivo'][:47] + "..." if len(a['nombre_archivo']) > 47 else a['nombre_archivo']
                    print(f"{a['idarchivo']:<5} {nombre:<50} {a['tipo_archivo'][:18]:<20} {tamano:<10} {fecha:<20}")
                print()
            else:
                print(f"📭 No hay archivos para {proveedor['razon_social']}")
                print()
            
            print("1. Subir nuevo archivo")
            print("2. Descargar archivo")
            print("3. Eliminar archivo")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._subir_archivo_proveedor(idproveedor)
            elif opcion == '2':
                self._descargar_archivo_por_id_menu(idproveedor)
            elif opcion == '3':
                self._eliminar_archivo_por_id_menu(idproveedor)
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    @requiere_permiso('proveedores_editar')
    def _subir_archivo_proveedor(self, idproveedor):
        """Sube un archivo para un proveedor"""
        self.mostrar_cabecera("SUBIR ARCHIVO")
        
        print("📁 Formatos permitidos:")
        print("  - Imágenes: .jpg, .png, .gif")
        print("  - Documentos: .pdf, .doc, .docx")
        print("  - Hojas de cálculo: .xls, .xlsx, .csv")
        print("  - Texto: .txt")
        print(f"  Tamaño máximo: 10 MB")
        print()
        
        ruta = input("Ruta completa del archivo: ").strip()
        ruta = ruta.replace('"', '').replace("'", "")
        
        if not os.path.exists(ruta):
            print("❌ El archivo no existe")
            self.pausa()
            return
        
        descripcion = input("Descripción (opcional): ").strip() or None
        
        idarchivo = self.proveedor_archivo_service.subir_archivo(idproveedor, ruta, descripcion)
        
        if idarchivo:
            print(f"✅ Archivo subido correctamente (ID: {idarchivo})")
            
            self.registrar_auditoria(
                accion="SUBIR",
                tabla="proveedor_archivos",
                registro_id=idarchivo,
                datos_nuevos=f"Archivo subido para proveedor ID {idproveedor}: {os.path.basename(ruta)}"
            )
        else:
            print("❌ Error al subir el archivo")
        
        self.pausa()
    
    def _descargar_archivo_por_id(self, idarchivo):
        """Descarga un archivo por su ID"""
        archivo = self.proveedor_archivo_service.obtener_archivo(idarchivo)
        if not archivo:
            print(f"❌ No existe archivo con ID {idarchivo}")
            self.pausa()
            return
        
        print(f"\n📌 Archivo: {archivo['nombre_archivo']}")
        print(f"📌 Proveedor: {archivo['proveedor']}")
        print(f"📌 Tamaño: {self.proveedor_archivo_service.obtener_tamano_legible(archivo['tamano'])}")
        print()
        
        ruta_destino = input("Ruta donde guardar (Enter para Descargas/): ").strip()
        if not ruta_destino:
            import os
            home = os.path.expanduser("~")
            ruta_destino = os.path.join(home, "Descargas", archivo['nombre_archivo'])
        
        if self.proveedor_archivo_service.guardar_archivo(idarchivo, ruta_destino):
            print(f"✅ Archivo guardado en: {ruta_destino}")
            
            self.registrar_auditoria(
                accion="DESCARGAR",
                tabla="proveedor_archivos",
                registro_id=idarchivo,
                datos_nuevos=f"Archivo descargado: {archivo['nombre_archivo']}"
            )
        else:
            print("❌ Error al guardar el archivo")
        
        self.pausa()
    
    def _descargar_archivo_por_id_menu(self, idproveedor):
        try:
            idarchivo = int(input("ID del archivo a descargar: "))
            self._descargar_archivo_por_id(idarchivo)
        except ValueError:
            print("❌ ID inválido")
            self.pausa()
    
    def _eliminar_archivo_por_id(self, idarchivo):
        confirmacion = input(f"¿Está seguro de eliminar el archivo ID {idarchivo}? (s/N): ").lower()
        if confirmacion == 's':
            if self.proveedor_archivo_service.eliminar_archivo(idarchivo):
                print("✅ Archivo eliminado correctamente")
                
                self.registrar_auditoria(
                    accion="ELIMINAR",
                    tabla="proveedor_archivos",
                    registro_id=idarchivo,
                    datos_anteriores=f"Archivo ID {idarchivo} eliminado"
                )
            else:
                print("❌ Error al eliminar el archivo")
        else:
            print("Operación cancelada")
        
        self.pausa()
    
    def _eliminar_archivo_por_id_menu(self, idproveedor):
        try:
            idarchivo = int(input("ID del archivo a eliminar: "))
            self._eliminar_archivo_por_id(idarchivo)
        except ValueError:
            print("❌ ID inválido")
            self.pausa()
    
    def _listar_todos_archivos(self):
        """Lista todos los archivos de todos los proveedores"""
        self.mostrar_cabecera("LISTA DE PROVEEDORES (ARCHIVOS)")
        
        proveedores = self.proveedor_service.listar()
        
        todos_archivos = []
        for p in proveedores:
            archivos = self.proveedor_archivo_service.listar_archivos_proveedor(p['idproveedor'])
            for a in archivos:
                a['proveedor_nombre'] = p['razon_social']
                a['proveedor_id'] = p['idproveedor']
                todos_archivos.append(a)
        
        if not todos_archivos:
            print("📭 No hay archivos subidos por ningún proveedor")
            self.pausa()
            return
        
        print(f"{'ID':<5} {'PROVEEDOR':<25} {'NOMBRE DEL ARCHIVO':<50} {'TIPO':<20} {'TAMAÑO':<10} {'FECHA':<15}")
        print("-" * 125)
        for a in todos_archivos:
            tamano = self.proveedor_archivo_service.obtener_tamano_legible(a['tamano'])
            fecha = a['fecha_subida'].strftime('%Y-%m-%d') if a['fecha_subida'] else ''
            nombre = a['nombre_archivo'][:47] + "..." if len(a['nombre_archivo']) > 47 else a['nombre_archivo']
            proveedor = a['proveedor_nombre'][:23] + "..." if len(a['proveedor_nombre']) > 23 else a['proveedor_nombre']
            print(f"{a['idarchivo']:<5} {proveedor:<25} {nombre:<50} {a['tipo_archivo'][:18]:<20} {tamano:<10} {fecha:<15}")
        print()
        
        while True:
            print("\nOpciones:")
            print("1. Descargar archivo por ID")
            print("2. Eliminar archivo por ID")
            print("3. Subir nuevo archivo (seleccionar proveedor)")
            print("4. Ver archivos de un proveedor específico")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                try:
                    idarchivo = int(input("ID del archivo a descargar: "))
                    self._descargar_archivo_por_id(idarchivo)
                except ValueError:
                    print("❌ ID inválido")
                    self.pausa()
            elif opcion == '2':
                try:
                    idarchivo = int(input("ID del archivo a eliminar: "))
                    self._eliminar_archivo_por_id(idarchivo)
                except ValueError:
                    print("❌ ID inválido")
                    self.pausa()
            elif opcion == '3':
                self._subir_archivo_con_seleccion_proveedor()
            elif opcion == '4':
                try:
                    idprov = int(input("ID del proveedor: "))
                    self._menu_archivos_proveedor(idprov)
                except ValueError:
                    print("❌ ID inválido")
                    self.pausa()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    def _subir_archivo_con_seleccion_proveedor(self):
        proveedores = self.proveedor_service.listar()
        if not proveedores:
            print("❌ No hay proveedores registrados")
            self.pausa()
            return
        
        print("\n📋 PROVEEDORES DISPONIBLES:")
        print(f"{'ID':<5} {'RAZÓN SOCIAL':<30}")
        print("-" * 35)
        for p in proveedores:
            print(f"{p['idproveedor']:<5} {p['razon_social']:<30}")
        print()
        
        try:
            idproveedor = int(input("ID del proveedor: "))
            proveedor = self.proveedor_service.obtener_por_id(idproveedor)
            if not proveedor:
                print("❌ Proveedor no válido")
                self.pausa()
                return
        except ValueError:
            print("❌ ID inválido")
            self.pausa()
            return
        
        self._subir_archivo_proveedor(idproveedor)
    
    @requiere_permiso('inventario_ver')
    def menu_inventario(self):
        """Menú de gestión de inventario"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE INVENTARIO")
            
            alertas = self.inventario_service.obtener_alertas_stock()
            if alertas:
                print("⚠️ ALERTAS DE STOCK:")
                for alerta in alertas[:3]:
                    print(f"   {alerta}")
                print()
            
            print("1. Ver stock completo")
            print("2. Ver resumen de inventario")
            print("3. Artículos con stock crítico")
            print("4. Artículos con stock bajo")
            print("5. Ver detalles de artículo")
            print("6. Registrar ingreso de mercancía")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione una opción: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._ver_stock_completo()
            elif opcion == '2':
                self._ver_resumen_inventario()
            elif opcion == '3':
                self._ver_stock_critico()
            elif opcion == '4':
                self._ver_stock_bajo()
            elif opcion == '5':
                self._ver_detalle_stock()
            elif opcion == '6':
                self._registrar_ingreso()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()

    @requiere_permiso('reportes_ventas')
    def menu_reportes(self):
        """Menú de reportes contables"""
        while True:
            self.mostrar_cabecera("📊 REPORTES CONTABLES")
            
            print("1. 📅 Reporte Diario")
            print("2. 📆 Reporte Semanal")
            print("3. 📆 Reporte Mensual")
            print("4. 📆 Reporte Trimestral")
            print("5. 📆 Reporte Anual")
            print("6. 📥 Exportar a Excel/CSV")
            print("0. Volver")
            print()
            
            opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
            
            if opcion == '1':
                self._reporte_diario()
            elif opcion == '2':
                self._reporte_semanal()
            elif opcion == '3':
                self._reporte_mensual()
            elif opcion == '4':
                self._reporte_trimestral()
            elif opcion == '5':
                self._reporte_anual()
            elif opcion == '6':
                self._exportar_reporte()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()

    def _reporte_diario(self):
        """Muestra reporte de ventas del día"""
        self.mostrar_cabecera("📅 REPORTE DIARIO")
        
        try:
            datos = self.reporte_service.reporte_diario()
            self._mostrar_reporte_contable(datos)
        except Exception as e:
            logger.error(f"Error generando reporte diario: {e}")
            print(f"{self.COLOR_ROJO}❌ Error al generar reporte{self.COLOR_RESET}")
        
        self.pausa()
    
    def _reporte_semanal(self):
        """Muestra reporte de ventas de la semana"""
        self.mostrar_cabecera("📆 REPORTE SEMANAL")
        
        try:
            datos = self.reporte_service.reporte_semanal()
            self._mostrar_reporte_contable(datos)
        except Exception as e:
            logger.error(f"Error generando reporte semanal: {e}")
            print(f"{self.COLOR_ROJO}❌ Error al generar reporte{self.COLOR_RESET}")
        
        self.pausa()
    
    def _reporte_mensual(self):
        """Muestra reporte de ventas del mes"""
        self.mostrar_cabecera("📆 REPORTE MENSUAL")
        
        try:
            datos = self.reporte_service.reporte_mensual()
            self._mostrar_reporte_contable(datos)
        except Exception as e:
            logger.error(f"Error generando reporte mensual: {e}")
            print(f"{self.COLOR_ROJO}❌ Error al generar reporte{self.COLOR_RESET}")
        
        self.pausa()
    
    def _reporte_trimestral(self):
        """Muestra reporte de ventas del trimestre"""
        self.mostrar_cabecera("📆 REPORTE TRIMESTRAL")
        
        try:
            datos = self.reporte_service.reporte_trimestral()
            self._mostrar_reporte_contable(datos)
        except Exception as e:
            logger.error(f"Error generando reporte trimestral: {e}")
            print(f"{self.COLOR_ROJO}❌ Error al generar reporte{self.COLOR_RESET}")
        
        self.pausa()
    
    def _reporte_anual(self):
        """Muestra reporte de ventas del año"""
        self.mostrar_cabecera("📆 REPORTE ANUAL")
        
        try:
            datos = self.reporte_service.reporte_anual()
            self._mostrar_reporte_contable(datos)
        except Exception as e:
            logger.error(f"Error generando reporte anual: {e}")
            print(f"{self.COLOR_ROJO}❌ Error al generar reporte{self.COLOR_RESET}")
        
        self.pausa()
    
    def _mostrar_reporte_contable(self, datos):
        """Muestra un reporte contable formateado"""
        print(f"\n{self.COLOR_AZUL}📊 RESUMEN CONTABLE{self.COLOR_RESET}")
        print("=" * 60)
        print(f"Período: {datos['fecha_inicio']} al {datos['fecha_fin']}")
        print(f"Total de ventas: {datos['total_ventas']}")
        print("-" * 60)
        print(f"{self.COLOR_VERDE}💰 Totales por moneda:{self.COLOR_RESET}")
        print(f"   Bolívares (Bs.): {datos['total_bs']:,.2f}")
        print(f"   Dólares (USD):   ${datos['total_usd']:,.2f}")
        print(f"   Euros (EUR):     €{datos['total_eur']:,.2f}")
        print(f"{self.COLOR_AMARILLO}📊 IGTF Total: Bs. {datos['igtf_total']:,.2f}{self.COLOR_RESET}")
        print("-" * 60)
        print(f"{self.COLOR_CYAN}📅 Detalle por día:{self.COLOR_RESET}")
        print(f"{'Fecha':<12} {'Ventas':<8} {'Bs.':<15} {'USD':<12} {'EUR':<12}")
        print("-" * 60)
        
        # Ordenar fechas cronológicamente
        fechas_ordenadas = sorted(datos['detalle'].keys())
        
        for fecha in fechas_ordenadas:
            det = datos['detalle'][fecha]
            
            # Formatear fecha de manera segura
            try:
                # Intentar formato YYYY-MM-DD
                if '-' in fecha and len(fecha.split('-')) == 3:
                    año, mes, dia = fecha.split('-')
                    fecha_formateada = f"{dia}/{mes}/{año}"
                else:
                    # Si ya viene en otro formato, usarla directamente
                    fecha_formateada = fecha
            except:
                fecha_formateada = fecha
            
            # Formatear números con separadores
            try:
                bs_str = f"{det['bs']:,.2f}".replace(',', ' ')
            except:
                bs_str = "0.00"
            
            try:
                usd_str = f"{det['usd']:,.2f}".replace(',', ' ')
            except:
                usd_str = "0.00"
            
            try:
                eur_str = f"{det['eur']:,.2f}".replace(',', ' ')
            except:
                eur_str = "0.00"
            
            # Imprimir línea con formato corregido
            print(f"{fecha_formateada:<12} {det['ventas']:<8} {bs_str:>14} bs {usd_str:>10} $ {eur_str:>8} €")

    def _exportar_reporte(self):
        """Exporta reporte a CSV"""
        self.mostrar_cabecera("📥 EXPORTAR REPORTE")
        
        print("Seleccione período a exportar:")
        print("1. Diario")
        print("2. Semanal")
        print("3. Mensual")
        print("4. Trimestral")
        print("5. Anual")
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            datos = self.reporte_service.reporte_diario()
        elif opcion == '2':
            datos = self.reporte_service.reporte_semanal()
        elif opcion == '3':
            datos = self.reporte_service.reporte_mensual()
        elif opcion == '4':
            datos = self.reporte_service.reporte_trimestral()
        elif opcion == '5':
            datos = self.reporte_service.reporte_anual()
        else:
            print("❌ Opción no válida")
            self.pausa()
            return
        
        try:
            ruta = self.reporte_service.exportar_a_csv(datos)
            print(f"\n{self.COLOR_VERDE}✅ Reporte exportado a: {ruta}{self.COLOR_RESET}")
            print("   Puede abrirlo con Excel para análisis contable")
        except Exception as e:
            logger.error(f"Error exportando reporte: {e}")
            print(f"{self.COLOR_ROJO}❌ Error al exportar reporte{self.COLOR_RESET}")
        
        self.pausa()    

    # ======================================================
    # NUEVOS MÉTODOS PARA MODIFICAR TASAS DE CAMBIO
    # ======================================================
    
    def _modificar_tasas(self):
        """Permite modificar las tasas de cambio USD y EUR manualmente"""
        self.mostrar_cabecera("💱 MODIFICAR TASAS DE CAMBIO")
        
        usuario = self.trabajador_service.get_usuario_actual()
        if not usuario:
            print(f"{self.COLOR_ROJO}❌ Debe iniciar sesión para modificar tasas{self.COLOR_RESET}")
            self.pausa()
            return
        
        print("Tasas actuales:")
        
        # Obtener tasas actuales
        tasas_actuales = self.obtener_tasas_actuales()
        
        if tasas_actuales['USD']:
            print(f"  💵 USD: 1 = {self.COLOR_VERDE}Bs. {tasas_actuales['USD']:.2f}{self.COLOR_RESET}")
        else:
            print(f"  💵 USD: {self.COLOR_ROJO}No registrada{self.COLOR_RESET}")
        
        if tasas_actuales['EUR']:
            print(f"  💶 EUR: 1 = {self.COLOR_VERDE}Bs. {tasas_actuales['EUR']:.2f}{self.COLOR_RESET}")
        else:
            print(f"  💶 EUR: {self.COLOR_ROJO}No registrada{self.COLOR_RESET}")
        
        print("\n" + "="*60)
        print("¿Qué tasa desea modificar?")
        print("1. 💵 Dólar (USD)")
        print("2. 💶 Euro (EUR)")
        print("3. Ambas")
        print("0. Volver")
        
        opcion = input(f"{self.COLOR_AMARILLO}🔹 Seleccione: {self.COLOR_RESET}").strip()
        
        if opcion == '1':
            self._modificar_tasa_unica('USD', usuario)
            self.pausa()
        elif opcion == '2':
            self._modificar_tasa_unica('EUR', usuario)
            self.pausa()
        elif opcion == '3':
            self._modificar_tasa_unica('USD', usuario)
            self._modificar_tasa_unica('EUR', usuario)
            self.pausa()
        elif opcion == '0':
            return
        else:
            print("❌ Opción no válida")
            self.pausa()
    
    def _modificar_tasa_unica(self, moneda, usuario):
        """Modifica una tasa específica"""
        print(f"\n{self.COLOR_AMARILLO}💰 Modificar tasa {moneda}{self.COLOR_RESET}")
        print("="*40)
        
        try:
            nueva_tasa = float(input(f"Nuevo valor para 1 {moneda} = Bs. ").strip())
            if nueva_tasa <= 0:
                print("❌ La tasa debe ser positiva")
                return
            
            # Registrar en el servicio de tasas
            if hasattr(self.venta_service, 'tasa_service') and self.venta_service.tasa_service:
                nombre_usuario = f"{usuario['nombre']} {usuario['apellidos']}"
                
                if self.venta_service.tasa_service.registrar_tasa_manual(
                    moneda=moneda,
                    tasa=nueva_tasa,
                    usuario=nombre_usuario
                ):
                    print(f"{self.COLOR_VERDE}✅ Tasa {moneda} actualizada a Bs. {nueva_tasa:.2f}{self.COLOR_RESET}")
                    
                    # Registrar en auditoría
                    self.registrar_auditoria(
                        accion="MODIFICAR_TASA",
                        tabla="tasa_cambio",
                        registro_id=0,
                        datos_nuevos=f"Tasa {moneda} actualizada a {nueva_tasa}"
                    )
                else:
                    print(f"{self.COLOR_ROJO}❌ Error al actualizar tasa{self.COLOR_RESET}")
            else:
                print(f"{self.COLOR_ROJO}❌ Servicio de tasas no disponible{self.COLOR_RESET}")
                
        except ValueError:
            print("❌ Ingrese un número válido")
    
    def _ver_stock_completo(self):
        self.mostrar_cabecera("STOCK COMPLETO")
        print(self.inventario_service.mostrar_tabla_stock())
        self.pausa()
    
    def _ver_resumen_inventario(self):
        self.mostrar_cabecera("RESUMEN DE INVENTARIO")
        print(self.inventario_service.mostrar_resumen_stock())
        self.pausa()
    
    def _ver_stock_critico(self):
        self.mostrar_cabecera("STOCK CRÍTICO (menos de 3 unidades)")
        
        articulos = self.inventario_service.listar_con_stock()
        criticos = [a for a in articulos if a['nivel_stock'] == 'CRÍTICO']
        
        if not criticos:
            print("✅ No hay artículos con stock crítico")
        else:
            print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'STOCK':<10}")
            print("-" * 60)
            for art in criticos:
                print(f"{art['color']}{art['idarticulo']:<5} {art['codigo']:<15} {art['nombre']:<30} {art['stock_actual']:<10}{self.inventario_service.COLOR_RESET}")
        
        self.pausa()
    
    def _ver_stock_bajo(self):
        self.mostrar_cabecera("STOCK BAJO (entre 3 y 5 unidades)")
        
        articulos = self.inventario_service.listar_con_stock()
        bajos = [a for a in articulos if a['nivel_stock'] == 'BAJO']
        
        if not bajos:
            print("✅ No hay artículos con stock bajo")
        else:
            print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'STOCK':<10}")
            print("-" * 60)
            for art in bajos:
                print(f"{art['color']}{art['idarticulo']:<5} {art['codigo']:<15} {art['nombre']:<30} {art['stock_actual']:<10}{self.inventario_service.COLOR_RESET}")
        
        self.pausa()
    
    def _ver_detalle_stock(self):
        self.mostrar_cabecera("DETALLE DE STOCK")
        
        try:
            idart = int(input("ID del artículo: "))
            art = self.articulo_service.obtener_por_id(idart)
            
            if not art:
                print(f"❌ No existe artículo con ID {idart}")
                self.pausa()
                return
            
            stock = self.inventario_service.obtener_stock_articulo(idart)
            nivel = self.inventario_service.obtener_nivel_stock(stock)
            
            print(f"\n📌 Artículo: {art['nombre']}")
            print(f"📌 Código: {art['codigo']}")
            print(f"📌 Stock actual: {stock} unidades")
            print(f"📌 Estado: {nivel['color']}{nivel['emoji']} {nivel['nivel']}{self.inventario_service.COLOR_RESET}")
            print(f"📌 {nivel['mensaje']}")
            
        except Exception as e:
            print(f"❌ Error: {e}")
        
        self.pausa()
    
    @requiere_permiso('inventario_ingresos')
    def _registrar_ingreso(self):
        """Registra un nuevo ingreso de mercancía"""
        self.mostrar_cabecera("REGISTRAR INGRESO")
        
        proveedores = self.proveedor_service.listar()
        if not proveedores:
            print("❌ No hay proveedores registrados.")
            print("   Por favor, cree un proveedor primero (Opción 3 → Opción 3)")
            self.pausa()
            return
        
        print("Proveedores disponibles:")
        for p in proveedores:
            print(f"  {p['idproveedor']}. {p['razon_social']}")
        
        try:
            idproveedor = int(input("\nID del proveedor: "))
            proveedor = self.proveedor_service.obtener_por_id(idproveedor)
            if not proveedor:
                print("❌ Proveedor no válido")
                self.pausa()
                return
        except:
            print("❌ ID inválido")
            self.pausa()
            return
        
        print("\nTipo de comprobante:")
        print("  1. Factura")
        print("  2. Boleta")
        print("  3. Guía")
        tipo_map = {'1': 'FACTURA', '2': 'BOLETA', '3': 'GUIA'}
        tipo_op = input("Seleccione: ").strip()
        tipo_comprobante = tipo_map.get(tipo_op, 'FACTURA')
        
        serie = input("Serie (ej. F001): ")
        numero = input("Número: ")
        
        detalle = []
        print("\n📦 AGREGAR PRODUCTOS AL INGRESO")
        print("="*40)
        
        print("\n📋 ARTÍCULOS DISPONIBLES:")
        articulos = self.articulo_service.listar()
        if not articulos:
            print("❌ No hay artículos registrados. Cree artículos primero.")
            self.pausa()
            return
        
        print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'CATEGORÍA':<20}")
        print("-" * 70)
        for a in articulos:
            cat_nombre = a.get('categoria', '') or 'N/A'
            print(f"{a['idarticulo']:<5} {a['codigo']:<15} {a['nombre']:<30} {cat_nombre:<20}")
        print()
        
        while True:
            print("\n--- Agregar producto ---")
            codigo = input("Código del artículo (0 para terminar, '?' para ver lista): ")
            
            if codigo == '0':
                break
            elif codigo == '?':
                print("\n📋 ARTÍCULOS DISPONIBLES:")
                print(f"{'ID':<5} {'CÓDIGO':<15} {'NOMBRE':<30} {'CATEGORÍA':<20}")
                print("-" * 70)
                for a in articulos:
                    cat_nombre = a.get('categoria', '') or 'N/A'
                    print(f"{a['idarticulo']:<5} {a['codigo']:<15} {a['nombre']:<30} {cat_nombre:<20}")
                continue
            
            art = self.articulo_service.buscar_por_codigo(codigo)
            if not art:
                try:
                    idart = int(codigo)
                    art = self.articulo_service.obtener_por_id(idart)
                except:
                    pass
            
            if not art:
                print("❌ Artículo no encontrado. Use '?' para ver la lista.")
                continue
            
            categoria_nombre = art.get('categoria', '') or 'No especificada'
            
            print(f"📌 Artículo seleccionado: {art['nombre']}")
            print(f"   Código: {art['codigo']}")
            print(f"   Categoría: {categoria_nombre}")
            
            try:
                cantidad = int(input("Cantidad a ingresar: "))
                if cantidad <= 0:
                    print("❌ La cantidad debe ser positiva")
                    continue
                precio = float(input("Precio de compra: "))
                if precio <= 0:
                    print("❌ El precio debe ser positivo")
                    continue
            except ValueError:
                print("❌ Cantidad o precio inválido")
                continue
            
            detalle.append({
                'idarticulo': art['idarticulo'],
                'cantidad': cantidad,
                'precio_compra': precio
            })
            print(f"✅ {art['nombre']} agregado - {cantidad} unidades a Bs. {precio:.2f}")
        
        if not detalle:
            print("❌ Debe agregar al menos un producto")
            self.pausa()
            return
        
        print("\n" + "="*50)
        print("📋 RESUMEN DEL INGRESO")
        print("="*50)
        print(f"Proveedor: {proveedor['razon_social']}")
        print(f"Comprobante: {tipo_comprobante} {serie}-{numero}")
        print("\nProductos:")
        total = 0
        for item in detalle:
            art = self.articulo_service.obtener_por_id(item['idarticulo'])
            subtotal = item['cantidad'] * item['precio_compra']
            total += subtotal
            print(f"  - {art['nombre']}: {item['cantidad']} und @ Bs.{item['precio_compra']:.2f} = Bs.{subtotal:.2f}")
        print(f"\n💰 TOTAL: Bs.{total:.2f}")
        print("="*50)
        
        confirmar = input(f"{self.COLOR_AMARILLO}¿Confirmar ingreso? (s/N): {self.COLOR_RESET}").lower()
        if confirmar != 's':
            print("Operación cancelada")
            self.pausa()
            return
        
        usuario = self.trabajador_service.get_usuario_actual()
        idingreso = self.ingreso_service.registrar_ingreso(
            usuario['idtrabajador'], idproveedor, tipo_comprobante,
            serie, numero, 16.0, detalle
        )
        
        if idingreso:
            print(f"\n{self.COLOR_VERDE}✅ Ingreso #{idingreso} registrado correctamente{self.COLOR_RESET}")
            print("📦 Stock actualizado automáticamente")
            
            self.registrar_auditoria(
                accion="CREAR",
                tabla="ingreso",
                registro_id=idingreso,
                datos_nuevos=f"Ingreso #{idingreso} - Proveedor: {proveedor['razon_social']} - Total: Bs.{total:.2f}"
            )
        else:
            print(f"\n{self.COLOR_ROJO}❌ Error al registrar el ingreso{self.COLOR_RESET}")
        
        self.pausa()
    
    def run(self):
        """Ejecuta el sistema"""
        if not self.conectar_db():
            return
        
        while True:
            opcion = self.mostrar_menu_principal()
            
            # NUEVA OPCIÓN PARA MODIFICAR TASAS
            if opcion.upper() == 'X':
                self._modificar_tasas()
                continue
            
            if opcion == '1':
                if self.rol_service.tiene_permiso('clientes_ver'):
                    self.menu_clientes()
                else:
                    print("❌ No tiene permisos para acceder a clientes")
                    self.pausa()
            elif opcion == '2':
                if self.rol_service.tiene_permiso('articulos_ver'):
                    self.menu_articulos()
                else:
                    print("❌ No tiene permisos para acceder a artículos")
                    self.pausa()
            elif opcion == '3':
                if self.rol_service.tiene_permiso('proveedores_ver'):
                    self.menu_proveedores()
                else:
                    print("❌ No tiene permisos para acceder a proveedores")
                    self.pausa()
            elif opcion == '4':
                if self.rol_service.tiene_permiso('ventas_ver'):
                    self.menu_ventas()
                else:
                    print("❌ No tiene permisos para acceder a ventas")
                    self.pausa()
            elif opcion == '5':
                if self.rol_service.tiene_permiso('inventario_ver'):
                    self.menu_inventario()
                else:
                    print("❌ No tiene permisos para acceder a inventario")
                    self.pausa()
            elif opcion == '6':
                if self.rol_service.tiene_permiso('reportes_ventas'):
                    self.menu_reportes()
                else:
                    print("❌ No tiene permisos para acceder a reportes")
                    self.pausa()
            elif opcion == '7':
                if self.trabajador_service.get_usuario_actual() and self.rol_service.tiene_permiso('usuarios_ver'):
                    self.menu_administracion_usuarios()
                else:
                    print("❌ No tiene permisos para acceder a esta opción")
                    self.pausa()
            elif opcion == '8':
                if self.trabajador_service.get_usuario_actual():
                    self.trabajador_service.logout()
                    self.pausa()
                else:
                    self.menu_login()
            elif opcion == '0':
                print(f"\n{self.COLOR_VERDE}👋 ¡Hasta luego!{self.COLOR_RESET}")
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
        
        self.db.cerrar()

if __name__ == "__main__":
    sistema = SistemaVentas()
    sistema.run()
----- capa_presentacion/input_con_mascara.py -----
import sys
import tty
import termios

def leer_con_mascara(mascara):
    """
    Lee entrada del usuario aplicando una máscara.
    Ejemplo: leer_con_mascara("DD/MM/YYYY")
    """
    import sys
    import tty
    import termios
    
    print(f"\r{mascara}", end='', flush=True)
    
    pos = 0
    resultado = list(mascara)
    lugares = [i for i, char in enumerate(mascara) if char in ('D', 'M', 'Y')]
    
    # Guardar configuración original de la terminal
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    
    try:
        # Configurar terminal para modo raw
        tty.setraw(sys.stdin.fileno())
        
        while pos < len(lugares):
            char = sys.stdin.read(1)
            
            if ord(char) == 3:  # Ctrl+C
                raise KeyboardInterrupt
            elif ord(char) == 127 or ord(char) == 8:  # Backspace
                if pos > 0:
                    pos -= 1
                    resultado[lugares[pos]] = mascara[lugares[pos]]
                    print(f"\r{''.join(resultado)}", end='', flush=True)
            elif char.isdigit():
                if pos < len(lugares):
                    resultado[lugares[pos]] = char
                    pos += 1
                    print(f"\r{''.join(resultado)}", end='', flush=True)
    finally:
        # Restaurar configuración original
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        print()
    
    # Extraer las partes de la fecha
    partes = ''.join(resultado).split('/')
    if len(partes) == 3:
        return f"{partes[0]}/{partes[1]}/{partes[2]}"
    return ''.join(resultado)
----- capa_presentacion/menu_principal_backup.py -----
#!/usr/bin/env python3
"""
Menú principal del sistema de ventas (Interfaz de consola)
"""
import os
import sys
from datetime import datetime

# Añadir el directorio padre al path para importar módulos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from capa_datos.conexion import ConexionDB
from capa_datos.categoria_repo import CategoriaRepositorio
from capa_datos.cliente_repo import ClienteRepositorio
from capa_datos.articulo_repo import ArticuloRepositorio
from capa_datos.proveedor_repo import ProveedorRepositorio
from capa_datos.trabajador_repo import TrabajadorRepositorio
from capa_datos.venta_repo import VentaRepositorio
from capa_datos.ingreso_repo import IngresoRepositorio
from capa_datos.lote_repo import LoteRepositorio

from capa_negocio.categoria_service import CategoriaService
from capa_negocio.cliente_service import ClienteService
from capa_negocio.articulo_service import ArticuloService
from capa_negocio.trabajador_service import TrabajadorService
from capa_negocio.venta_service import VentaService
from capa_negocio.base_service import BaseService

from loguru import logger

# Configurar logger
logger.remove()
logger.add(sys.stderr, format="<level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>")

class SistemaVentas:
    """Clase principal del sistema"""
    
    def __init__(self):
        self.db = ConexionDB()
        self.conn = None
        self.trabajador_service = None
        self.categoria_service = None
        self.cliente_service = None
        self.articulo_service = None
        self.venta_service = None
    
    def conectar_db(self):
        """Establece conexión con la base de datos"""
        self.conn = self.db.conectar()
        if not self.conn:
            print("❌ No se pudo conectar a la base de datos")
            return False
        
        # Inicializar repositorios
        trabajador_repo = TrabajadorRepositorio(self.conn)
        categoria_repo = CategoriaRepositorio(self.conn)
        cliente_repo = ClienteRepositorio(self.conn)
        articulo_repo = ArticuloRepositorio(self.conn)
        venta_repo = VentaRepositorio(self.conn)
        
        # Inicializar servicios
        self.trabajador_service = TrabajadorService(trabajador_repo)
        self.categoria_service = CategoriaService(categoria_repo)
        self.cliente_service = ClienteService(cliente_repo)
        self.articulo_service = ArticuloService(articulo_repo, self.categoria_service)
        self.venta_service = VentaService(
            venta_repo, 
            self.cliente_service, 
            self.trabajador_service, 
            self.articulo_service
        )
        
        return True
    
    def limpiar_pantalla(self):
        """Limpia la pantalla de la consola"""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def pausa(self):
        """Pausa la ejecución hasta que el usuario presione Enter"""
        input("\n🔹 Presione Enter para continuar...")
    
    def mostrar_cabecera(self, titulo):
        """Muestra una cabecera formateada"""
        self.limpiar_pantalla()
        print("=" * 60)
        print(f"{titulo:^60}")
        print("=" * 60)
        print()
    
    def mostrar_menu_principal(self):
        """Muestra el menú principal"""
        self.mostrar_cabecera("SISTEMA DE VENTAS - 3 CAPAS")
        
        usuario = self.trabajador_service.get_usuario_actual()
        if usuario:
            print(f"👤 Usuario: {usuario['nombre']} {usuario['apellidos']}")
            print()
        
        print("1. Gestión de Categorías")
        print("2. Gestión de Clientes")
        print("3. Gestión de Artículos")
        print("4. Gestión de Ventas")
        print("5. Gestión de Ingresos")
        print("6. Reportes")
        if usuario:
            print("7. Cerrar Sesión")
        else:
            print("7. Iniciar Sesión")
        print("0. Salir")
        print()
        
        return input("🔹 Seleccione una opción: ").strip()
    
    def menu_categorias(self):
        """Menú de gestión de categorías"""
        while True:
            self.mostrar_cabecera("GESTIÓN DE CATEGORÍAS")
            print("1. Listar categorías")
            print("2. Buscar categoría por ID")
            print("3. Crear categoría")
            print("4. Actualizar categoría")
            print("5. Eliminar categoría")
            print("0. Volver")
            print()
            
            opcion = input("🔹 Seleccione una opción: ").strip()
            
            if opcion == '1':
                self.listar_categorias()
            elif opcion == '2':
                self.buscar_categoria()
            elif opcion == '3':
                self.crear_categoria()
            elif opcion == '4':
                self.actualizar_categoria()
            elif opcion == '5':
                self.eliminar_categoria()
            elif opcion == '0':
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
    
    def listar_categorias(self):
        """Lista todas las categorías"""
        self.mostrar_cabecera("LISTADO DE CATEGORÍAS")
        
        categorias = self.categoria_service.listar()
        
        if not categorias:
            print("📭 No hay categorías registradas")
        else:
            print(f"{'ID':<5} {'NOMBRE':<30} {'DESCRIPCIÓN':<40}")
            print("-" * 75)
            for cat in categorias:
                desc = cat['descripcion'][:37] + "..." if cat['descripcion'] and len(cat['descripcion']) > 40 else cat['descripcion'] or ""
                print(f"{cat['idcategoria']:<5} {cat['nombre']:<30} {desc:<40}")
        
        self.pausa()
    
    def buscar_categoria(self):
        """Busca una categoría por ID"""
        self.mostrar_cabecera("BUSCAR CATEGORÍA")
        
        try:
            idcategoria = int(input("Ingrese ID de categoría: "))
            categoria = self.categoria_service.obtener_por_id(idcategoria)
            
            if categoria:
                print(f"\n📌 ID: {categoria['idcategoria']}")
                print(f"📌 Nombre: {categoria['nombre']}")
                print(f"📌 Descripción: {categoria['descripcion'] or 'Sin descripción'}")
            else:
                print(f"❌ No existe categoría con ID {idcategoria}")
        except ValueError:
            print("❌ Debe ingresar un número válido")
        
        self.pausa()
    
    def crear_categoria(self):
        """Crea una nueva categoría"""
        self.mostrar_cabecera("CREAR CATEGORÍA")
        
        nombre = input("Ingrese nombre de categoría: ")
        descripcion = input("Ingrese descripción (opcional): ") or None
        
        if self.categoria_service.crear(nombre, descripcion):
            print("✅ Categoría creada exitosamente")
        else:
            print("❌ No se pudo crear la categoría")
        
        self.pausa()
    
    def actualizar_categoria(self):
        """Actualiza una categoría"""
        self.mostrar_cabecera("ACTUALIZAR CATEGORÍA")
        
        try:
            idcategoria = int(input("Ingrese ID de categoría a actualizar: "))
            categoria = self.categoria_service.obtener_por_id(idcategoria)
            
            if not categoria:
                print(f"❌ No existe categoría con ID {idcategoria}")
                self.pausa()
                return
            
            print(f"\n📌 Datos actuales:")
            print(f"   Nombre: {categoria['nombre']}")
            print(f"   Descripción: {categoria['descripcion'] or 'Sin descripción'}")
            print()
            
            nombre = input("Nuevo nombre (Enter para mantener): ") or categoria['nombre']
            descripcion = input("Nueva descripción (Enter para mantener): ") or categoria['descripcion']
            
            if self.categoria_service.actualizar(idcategoria, nombre, descripcion):
                print("✅ Categoría actualizada exitosamente")
            else:
                print("❌ No se pudo actualizar la categoría")
        except ValueError:
            print("❌ Debe ingresar un número válido")
        
        self.pausa()
    
    def eliminar_categoria(self):
        """Elimina una categoría"""
        self.mostrar_cabecera("ELIMINAR CATEGORÍA")
        
        try:
            idcategoria = int(input("Ingrese ID de categoría a eliminar: "))
            
            confirmacion = input(f"¿Está seguro de eliminar la categoría {idcategoria}? (s/N): ")
            if confirmacion.lower() == 's':
                if self.categoria_service.eliminar(idcategoria):
                    print("✅ Categoría eliminada exitosamente")
                else:
                    print("❌ No se pudo eliminar la categoría (puede tener artículos asociados)")
            else:
                print("Operación cancelada")
        except ValueError:
            print("❌ Debe ingresar un número válido")
        
        self.pausa()
    
    def menu_login(self):
        """Menú de inicio de sesión"""
        self.mostrar_cabecera("INICIAR SESIÓN")
        
        usuario = input("Usuario: ")
        password = input("Contraseña: ")
        
        if self.trabajador_service.login(usuario, password):
            print("✅ Sesión iniciada correctamente")
        else:
            print("❌ Error al iniciar sesión")
        
        self.pausa()
    
    def menu_logout(self):
        """Cerrar sesión"""
        self.trabajador_service.logout()
        self.pausa()
    
    def run(self):
        """Ejecuta el sistema"""
        if not self.conectar_db():
            return
        
        while True:
            opcion = self.mostrar_menu_principal()
            
            if opcion == '1':
                self.menu_categorias()
            elif opcion == '2':
                print("🔧 Módulo de clientes en desarrollo")
                self.pausa()
            elif opcion == '3':
                print("🔧 Módulo de artículos en desarrollo")
                self.pausa()
            elif opcion == '4':
                print("🔧 Módulo de ventas en desarrollo")
                self.pausa()
            elif opcion == '5':
                print("🔧 Módulo de ingresos en desarrollo")
                self.pausa()
            elif opcion == '6':
                print("🔧 Módulo de reportes en desarrollo")
                self.pausa()
            elif opcion == '7':
                if self.trabajador_service.get_usuario_actual():
                    self.menu_logout()
                else:
                    self.menu_login()
            elif opcion == '0':
                print("\n👋 ¡Hasta luego!")
                break
            else:
                print("❌ Opción no válida")
                self.pausa()
        
        self.db.cerrar()

if __name__ == "__main__":
    sistema = SistemaVentas()
    sistema.run()
----- capa_presentacion/decoradores.py -----
from functools import wraps
from loguru import logger
from capa_negocio.rol_service import PermisoDenegadoError

def requiere_permiso(permiso: str):
    """Decorador para verificar permisos en métodos de menú"""
    def decorator(func):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            try:
                # Verificar si el usuario tiene el permiso
                if hasattr(self, 'rol_service') and self.rol_service:
                    self.rol_service.verificar_permiso(permiso)
                return func(self, *args, **kwargs)
            except PermisoDenegadoError as e:
                logger.warning(f"⛔ Acceso denegado: {e}")
                print(f"\n⛔ No tiene permisos para realizar esta operación.")
                print(f"   Permiso requerido: {permiso}")
                if hasattr(self, 'pausa'):
                    self.pausa()
                return None
        return wrapper
    return decorator
